-- Carcassonne and all expansions w/ automated scripting
-- Scripting by Sancho
-- The rules are based on the contents of Carcassonne Annotated Rules (CAR) v7.4.

--Tile Script Info
-- Each tile should have a script including variables needed to represent the information on the tile. The data format is as follows:
-- *In all examples, the "starting piece" is used*
-- *It should be noted that the "top" and "topleft" is from the perspective of the white player. All of the tiles are, in actuality, rotated ky 180 degrees, which is taken into account in code with TILE_STANDARD_ROTATION
-- Data Format:
--  sides - table of strings ( ie. {'City', 'Road', 'Field', 'Road'} ) Specifies the feature on each side of the tile, starting from the "top" clockwise (top is arbitrary, but must be consistent amoung pieces)
--             features: 'City', 'Road', 'Field', 'River', 'Abbey'
--  (optional) linkedQuadrants - table of tables of ints ( ie. {{2, 4}} ) Each table specifies which features are linked together, starting from the "top" at 1 and increasing clockwise.
--             This only applies for features that take the middle of the side (ie. roads, rivers)
--             In the example, the right side is linked to the left side (the road)
--  (optional) linkedOctants - table of tables of ints ( ie. {{5, 6}, {7, 12}, {8, 9, 10, 11}} ) Each table specifies which half of each quadrant is linked to others, starting from the "topleft" at 5 and increasing clockwise.
--             This is necessary for fields and cities, in particular, since both halves of a quadrant aren't always linked to each other.
--             Also, this specifies how the fields on each half of a road feature are linked to other fields. Therefore, each road quadrant may also have 2 corresponding octants specified for that same side.
--             In the example, the topleft and topright octants are linked
--                             the righttop and lefttop octants are linked (This is the field on the top half of the road)
--                             the rightbottom, bottomright, bottomleft, and leftbottom octants are linked (this is the field on the bottom half of the road)
--  (optional) specialFeatures - table of tables containing a string (which specifies the feature), (optional) table of ints, and (optional) table of exactly 2 floats ( ie. {{'City-Field', {5, 6, 7, 12}, nil}} )
--             The table of ints specifies what quadrants or octants this feature is linked to (if any).
--             The table of floats specifies the relative x and z coordinates of the feature on this piece (if a figure can be placed on the feature).
--             features:
--                  Base features ('City', 'Road', 'Field', 'Abbey') - this allows for additional locations for specifying the base features.
--                       this is useful for defining additional snap points, as well as allowing features which aren't connected to any quadrant or octant (there are a few fields like this).
--                  'Cloister' = cloister - specifies the location of a cloister. Links are not used for this feature.
--                  'City-Field' = city-field link - if the cities specified are completed, they score points to the specified fields. Multiple different cities and fields specified
--                             are NOT linked to each other, only fields are linked to cities (and vice versa, in the case of using old rules TODO: implement later?). Coordinates are not used for this feature.
--                  'Road Intersection' = links roads to each other or other features. This is used for wagons.
--                  Linked Features with no coordinates: 'Coat of Arms', 'Inn', 'Cathedral', 'Princess'
--                  Unlinked Features of the tile: 'Volcano', 'Dragon', 'Hill'
--                  'Garden' - specifies the location of a garden. Links are not used for this feature.

DEBUG_BUTTONS = false
AUTOLOCK = true

debugMode = 0
--debugLogTabIndex = -1

TILE_POSITION_MARGIN = 0.02
TILE_ROTATION_MARGIN = 0.015
TILE_SPACING = 1.59 --how far apart tiles or spaced (should be the same as the tile grid setting)
TILE_THICKNESS = 0.005 --about how much thicker each tile makes a stack when added (keep in mind this is probably not as thick as the tile actually is on its own)
TILE_STANDARD_ROTATION = 2 --every tile is rotated this much so that the perceived rotation of the tiles matches the actual rotation in the code
TILE_180_ROTATION = 2

MIDDLE_LOCATION = {x = 0.795, z = -0.795}
MIDDLE_OFFSET = {x = 25 * TILE_SPACING, z = 25 * TILE_SPACING}

SIDE_DELTA = {{x=0,z=-1},{x=-1,z=0},{x=0,z=1},{x=1,z=0}}

NEUTRAL_ITEMS_LOCATION = {x = 15.5, y = 1.5, z = 28.0}

NEUTRAL_COLOR = {r=0.5,g=0.5,b=0.5}
ERROR_COLOR = {r=1,g=0,b=0}

PLAYER_COLORS = {'Green', 'Purple', 'White', 'Blue', 'Red', 'Pink'}

--The following figure definitions were specified in the CAR (Carcassonne Annoted Rules).
--Although not all figures have the same properties, their relative similarities may simpify code
FOLLOWER_TYPES = {'Follower', 'Big Follower', 'Phantom', 'Abbot', 'Mayor', 'Wagon'}
SPECIAL_FIGURE_TYPES = {'Shepherd', 'Builder', 'Pig', 'Barn'}
NEUTRAL_FIGURE_TYPES = {'Count', 'Dragon', 'Fairy', 'Tower Block'}

SHEEP_TOKEN_TYPES = {'Sheep', 'Wolf'}
TRADE_TOKEN_TYPES = {'Wheat Token', 'Wine Token', 'Cloth Token'}
GOLD_BAR_NAME = 'Gold Bar'

SCORE_COUNTER_GUIDS = {
    ['Green'] = '28bdff',
    ['Pink'] = '7ef326',
    ['Purple'] = 'f206e4',
    ['Blue'] = '9d1e70',
    ['Red'] = '4e3519',
    ['White'] = '1ecf3f'
}

FLOATING_BUTTON_HEIGHT = 40.0
FLOATING_BUTTON_HEIGHT_LOW = 20.0

FIGURE_DISTANCE_FROM_EDGE = 0.1 --percentage distance from the edge that each quadrant/octant exists

FIGURE_RETURN_DELAY = 0.4 --seconds to wait while returning a figure in order to prevent double-scoring
FIGURE_PRAISE_DELAY = 2.5 --seconds to wait while figure is spinning before it is returned

STARTING_TILE_GUID = 'c107f0'
TILE_STACK_GUID = '16d9db'

PLAY_AREA_SCRIPTING_ZONE_GUID = '799064'

FIGUREPAD_GUIDs = {
    ['Green'] = 'cee9ef',
    ['Purple'] = '7b6639',
    ['White'] = 'b013fc',
    ['Blue'] = '37df2f',
    ['Red'] = '4a5985',
    ['Pink'] = '7ed1bb'
}

figurePositions = {}

PLAYER_POSSESSION_AREAS = {
    ['Green'] = {x=25, z=12.04, rotation=3},
    ['Purple'] = {x=25, z=-12.1, rotation=3},
    ['White'] = {x=12.07, z=-25.0, rotation=2},
    ['Blue'] = {x=-12.1, z=-25.0, rotation=2},
    ['Red'] = {x=-24.96, z=-12.08, rotation=1},
    ['Pink'] = {x=-24.96, z=12.12, rotation=1}
}
playerPossessionScriptingZones = {}

PLAYER_POSSESSION_ZONE_HEIGHT = 2
PLAYER_POSSESSION_ZONE_DEPTH = 6.0
PLAYER_POSSESSION_ZONE_WIDTH = 6

-- Guid for object we will put button on
BUTTON_BOARD_GUID = '2b44bf'

showMarkers = 'Scoring'
showMarkersButtonParam = {
    index = 0, label = 'Show\nMarkers:\n' .. showMarkers, click_function = 'showMarkersToggleButton',
    position = {-0.8,0.1,0.0}, width = 750, height=600, font_size = 150, function_owner = nil
}

endGameButtonParam = {
    index = 1, label = 'Start\nGame', click_function = 'gameToggleButton',
    position = {1.0, 0.1, 0.0}, width = 750, height=600, font_size = 150, function_owner = nil
}

skipTurnButtonParam = {
   index = 2, label = 'Skip\nTurn', click_function = 'skipTurnButton',
   position = {2.8, 0.1, 0.0}, width = 750, height=600, font_size = 150, function_owner = nil
}

debugButtonParam = {
   index = 3, label = 'Debug mode:\n' .. debugMode, click_function = 'switchDebugLevel',
   position = {-2.7, 0.1, 2.3}, rotation = {0.0, 270.0, 0.0}, width = 1000, height=500, font_size = 150, function_owner = nil
}

showTransversalParam = {
   index = 4, label = 'Show\nTransversal', click_function = 'debugShowTransversal',
   position = {-2.7, 0.1, 4.6}, rotation = {0.0, 270.0, 0.0}, width = 1000, height=500, font_size = 150, function_owner = nil
}

expansionBags = {
    ['InC'] = {guid = '95eb56', contents = {
        ['InCTiles'] = {guid = '122dff'}
        -- ['InCBigFollower'] = {guid = 'e5ec48', contents =
        --     {['Green'] = {guid = 'd9ab61'}, ['Purple'] = {guid = '62c526'}, ['White'] = {guid = '85ef73'}, ['Blue'] = {guid = 'f741b3'}, ['Red'] = {guid = 'ac3616'}, ['Yellow'] = {guid = '2456df'}}
        -- }
    }},
    ['TnB'] = {guid = '09fab1', contents = {
        ['TnBTiles'] = {guid = 'a88997'},
        -- ['TnBBuilder'] = {guid = 'a3aea6', contents =
        --     {['Green'] = {guid = '61cb95'}, ['Purple'] = {guid = '4ea21e'}, ['White'] = {guid = 'e11ef8'}, ['Blue'] = {guid = '128a06'}, ['Red'] = {guid = 'b12bcc'}, ['Yellow'] = {guid = '967ed5'}}
        -- },
        -- ['TnBPig'] = {guid = 'a3aea6', contents =
        --     {['Green'] = {guid = 'a180e1'}, ['Purple'] = {guid = '3f96a3'}, ['White'] = {guid = '2eb691'}, ['Blue'] = {guid = '8f7df7'}, ['Red'] = {guid = 'cc6164'}, ['Yellow'] = {guid = '26c485'}}
        -- },
        ['TnBClothTokenStack'] = {guid = 'ebd019'},
        ['TnBWineTokenStack'] = {guid = '55a94f'},
        ['TnBWheatTokenStack'] = {guid = '7a829b'}
    }},
    ['PnD'] = {guid = '564958', contents = {
        ['PnDTiles'] = {guid = '89bb59'},
        ['PnDDragon'] = {guid = 'e191ec'},
        ['PnDFairy'] = {guid = '46278a'}
    }},
    ['Tower'] = {guid = 'd59a8b', contents = {}},
    ['AnM'] = {guid = '9295b3', contents = {
        ['AnMTiles'] = {guid = '44e318'},
        ['AnMAbbey'] = {guid = '7e2126'},
        ['AnMMayor'] = {guid = '3cee76'},
        ['AnMWagon'] = {guid = 'e0467b'},
        ['AnMBarn'] = {guid = '306ca2'}
    }},
    ['CoC'] = {guid = 'd3189b', contents = {
        ['CoCCount'] = {guid = 'fba388'},
        ['CoCCarcassonneTiles'] = {guid = 'af8d39', contents = {
            [1] = {guid = '9c4fe7'},
            [2] = {guid = 'a6ff3c'},
            [3] = {guid = '9fd64f'},
            [4] = {guid = 'b0410c'},
            [5] = {guid = '78d5ee'},
            [6] = {guid = '8a1ed2'},
            [7] = {guid = 'a0ef6a'},
            [8] = {guid = '31cbd2'},
            [9] = {guid = '49a323'},
            [10] = {guid = '78a086'},
            [11] = {guid = '5cc6c2'},
            [12] = {guid = '233a1a'},
        }}
    }},
    ['KnRB'] = {guid = '927621', contents = {
        ['KnRBTiles'] = {guid = 'f5773a'},
        ['KnRBKing'] = {guid = 'c3021c'},
        ['KnRBRobber'] = {guid = '26c11d'}
    }},
    ['Cult'] = {guid = 'da553b', contents = {
        ['CultTiles'] = {guid = '96ff26'},
        ['CultBonusTile'] = {guid = '754953'}
    }},
    ['Flier'] = {guid = 'a50c26', contents = {
        ['FlierTiles'] = {guid = 'f006d5'},
        ['FlierDie'] = {guid = 'dc7bf3'}
    }},
    ['Goldmines'] = {guid = '080d67', contents = {
        ['GoldminesTiles'] = {guid = 'bc8fac'},
        ['GoldminesGold'] = {guid = 'd013b9'}
    }},
    ['HnS'] = {guid = 'a50c27', contents = {
        ['HnSTiles'] = {guid = '3fb950'},
        ['HnSSheepBag'] = {guid = '12bf5b'}
    }},
    ['River'] = {guid = '51fd29', contents = {
        ['EndTiles'] = {guid = 'aab569'},
        ['BodyTiles'] = {guid = 'd5e587'},
    }},
    ['RiverII'] = {guid = '5a29f0', contents = {
        ['EndTiles'] = {guid = '71858f', contents = {
            ['Volcano Lake'] = {guid = 'a423e8'}
        }},
        ['BodyTiles'] = {guid = 'c6344e'},
    }},
    ['RiverBB5'] = {guid = '592f3a', contents = {
        ['EndTiles'] = {guid = '7d1715'},
        ['BodyTiles'] = {guid = 'e9d3b0'},
    }}
}

controlPanelSettings = {
--Starting tiles
    ['StartingTileBase'] = true,
    ['StartingTileRiver'] = false,
    ['StartingTileRiverII'] = false,
    ['StartingTileRiverBB5'] = false,
    ['StartingTileCoC'] = false,
    ['StartingTileWoF'] = false,
    ['StartingTileSchool'] = false,
    ['StartingTileWindRoses'] = false,
--Base + Major expansions
    ['BaseTiles'] = true,
    ['BaseFollower'] = true,
    ['BaseNumFollowers'] = 7,
    ['BaseNerfSmallCity'] = false,
    ['InCTiles'] = false,
    ['InCBigFollower'] = false,
    ['TnBTiles'] = false,
    ['TnBBuilder'] = false,
    ['TnBPig'] = false,
    ['TnBTradeGoods'] = false,
    ['PnDTiles'] = false,
    ['PnDDragon'] = false,
    ['PnDFairy'] = false,
    ['PnDMagicPortal'] = false,
    ['PnDPrincess'] = false,
    ['TowerTiles'] = false,
    ['TowerTowers'] = false,
    ['TowerNumTowers'] = 10,
    ['AnMTiles'] = false,
    ['AnMAbbey'] = false,
    ['AnMMayor'] = false,
    ['AnMWagon'] = false,
    ['AnMBarn'] = false,
    ['KnRBTiles'] = false,
    ['KnRBKing'] = false,
    ['KnRBRobber'] = false,
    ['CultTiles'] = false,

    ['HnSTiles'] = false,
    ['HnSShepherd'] = false,
    ['HnSHills'] = false,
    ['HnSBuryHills'] = true,
    ['HnSVineyards'] = false,
--Mini expansions
    ['FlierTiles'] = false,
    ['FlierFlier'] = false,
    ['GoldminesTiles'] = false,
    ['GoldminesGold'] = false
}

--[<setting name>] = {[<expansion bag>] = {[<item name>] = {}}}
tileSettings = {
    ['InCTiles'] = {['InC'] = {['InCTiles'] = {}}},
    ['TnBTiles'] = {['TnB'] = {['TnBTiles'] = {}}},
    ['PnDTiles'] = {['PnD'] = {['PnDTiles'] = {}}},
    ['TowerTiles'] = {['Tower'] = {['TowerTiles'] = {}}},
    ['AnMTiles'] = {['AnM'] = {['AnMTiles'] = {}}},
    ['KnRBTiles'] = {['KnRB'] = {['KnRBTiles'] = {}}},
    ['CultTiles'] = {['Cult'] = {
            ['CultTiles'] = {},
            ['CultBonusTile'] = {}
        }
    },
    ['HnSTiles'] = {['HnS'] = {['HnSTiles'] = {}}},
    ['FlierTiles'] = {['Flier'] = {['FlierTiles'] = {}}},
    ['GoldminesTiles'] = {['Goldmines'] = {['GoldminesTiles'] = {}}}
}

--[<setting name>] = {[<expansion bag>] = {[<item name>] = {position={<position on table>}, rotation={<rotation>}, shuffle=<should shuffle>, lock=<should lock>}}}
startingTileSettings = {
    ['StartingTileRiverII'] = {['RiverII'] = {
        ['EndTiles'] = {position = {x=-0.795, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['BodyTiles'] = {position = {x=2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=180}, shuffle = true, lock = false},
    }},
    ['StartingTileRiverBB5'] = {['RiverBB5'] = {
        ['EndTiles'] = {position = {x=-0.795, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['BodyTiles'] = {position = {x=2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=180}, shuffle = true, lock = false},
    }},
    ['StartingTileRiver'] = {['River'] = {
        ['EndTiles'] = {position = {x=-0.795, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['BodyTiles'] = {position = {x=2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=180}, shuffle = true, lock = false},
    }},
    ['StartingTileCoC'] = {
        ['CoC'] = {
            ['CoCCarcassonneTiles'] = {position = {x=-0.795, y=2.32, z=11.925}, rotation = {x=0,y=180,z=180}, shuffle = false, lock = false, contents = {
                [1] = {position = {x=-2.385, y=2.0, z=0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [2] = {position = {x=-0.795, y=2.0, z=0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [3] = {position = {x=0.795, y=2.0, z=0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [4] = {position = {x=2.385, y=2.0, z=0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [5] = {position = {x=-2.385, y=2.0, z=-0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [6] = {position = {x=-0.795, y=2.0, z=-0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [7] = {position = {x=0.795, y=2.0, z=-0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [8] = {position = {x=2.385, y=2.0, z=-0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [9] = {position = {x=-2.385, y=2.0, z=-2.385}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [10] = {position = {x=-0.795, y=2.0, z=-2.385}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [11] = {position = {x=0.795, y=2.0, z=-2.385}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [12] = {position = {x=2.385, y=2.0, z=-2.385}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
            }}
        }
    }
}

--[<setting name>] = {name = <display name>, mesh = <model file>, diffuse = <diffuse file>, offset = {x=<x offset>, z=<z offset>}, scale = {<model scale>}, use_snap_points=<use snap points>, num=<setting with number to spawn>}
figureSettings = {
    ['BaseFollower'] = {name = 'Follower', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXS19OU3N4cDdCS2c', diffuse = 'http://i.imgur.com/s2rhBCd.jpg', offset = {x = 5.15, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true, num = 'BaseNumFollowers'},
    ['InCBigFollower'] = {name = 'Big Follower', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXS19OU3N4cDdCS2c', diffuse = 'http://i.imgur.com/s2rhBCd.jpg', offset = {x = -0.8, z = 0.5}, scale = {0.6, 0.6, 0.5}, use_snap_points = true},
    ['TnBBuilder'] = {name = 'Builder', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXcXJzc0NCaXVHaUk', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -0.8, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true}, --should probably be closer to {0.5, 0.42, 0.5}
    ['TnBPig'] = {name = 'Pig', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXRllCMGF3aDNQX00', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -2.25, z = 0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true}, --should probably be closer to {0.45, 0.5, 0.5}
    ['AnMMayor'] = {name = 'Mayor', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXQ09DaUZ5cThGS0E', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -2.25, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true},
    ['AnMWagon'] = {name = 'Wagon', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXOTNZT2NNVk02STQ', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -3.7, z = 0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true},
    ['AnMBarn'] = {name = 'Barn', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXZjNhXzZPUGo1RDg', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -3.7, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = false},
    ['HnSShepherd'] = {name = 'Shepherd', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXbjJHZXIwc1U2VTg', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -5.15, z = 0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true},
    ['CIIAbbot'] = {name = 'Abbot', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXQ2M4NkxxQ2JGRFE', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -5.15, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true}
}

--[<steam_id>] = {['Intro'] = <intro string>, [<figure name>] = {<custom figure settings>}}
vipFigureSettings = {
    -- ['76561197962338210'] = {
    --     ['Intro'] = "You are being joined by %s, the creator of Scripted Carcassonne."
    -- },
    -- ['76561197972020303'] = {
    --     ['Intro'] = "You are being joined by %s, contributor to the Carcassonne mod."
    -- },
    ['9999999999999999999'] = {
        ['Intro'] = "You are being joined by %s, the TTS Carcassonne Tournament champion. All hail the king!",
        ['BaseFollower'] = {name = 'Follower', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXdmtGZ1lzZ085RFE', diffuse = 'http://i.imgur.com/s2rhBCd.jpg', offset = {x = 5.15, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true, num = 'BaseNumFollowers'},
    }
}

--[<setting name>] = {[<expansion bag>] = {[<item name>] = {width = <width of object>}}}
neutralFigureSettings = {
    ['TnBTradeGoods'] = {['TnB'] = {
            ['TnBClothTokenStack'] = {width = 1.0},
            ['TnBWineTokenStack'] = {width = 1.0},
            ['TnBWheatTokenStack'] = {width = 1.0}
        }
    },
    ['KnRBKing'] = {['KnRB'] = {['KnRBKing'] = {width = 2.0}}},
    ['KnRBRobber'] = {['KnRB'] = {['KnRBRobber'] = {width = 2.0}}},
    ['HnSShepherd'] = {['HnS'] = {['HnSSheepBag'] = {width = 1.5}}},
    ['PnDFairy'] = {['PnD'] = {['PnDFairy'] = {width = 1.0}}},
    ['PnDDragon'] = {['PnD'] = {['PnDDragon'] = {width = 2.0}}},
    ['FlierFlier'] = {['Flier'] = {['FlierDie'] = {width = 1.0}}},
    ['GoldminesGold'] = {['Goldmines'] = {['GoldminesGold'] = {width = 1.5}}}
}

tileGrid = {}
lastPlacedTileX = nil
lastPlacedTileZ = nil

droplock = false
spamLock = false
scoring = false
gameover = true

wagonLocations = {}
hasAvailableWagonFeature = {}
--used when the player order must be transversed within someone's turn
currentMiniTurn = nil

transversedGrid = {}
transversedFeaturePositions = {}
transversedTileCoords = {}
transversedSpecialFeatures = {}
transversedFollowers = {}
transversedSpecialFigures = {}
transversedSheepTokens = {}
transversedGoldBars = {}

followersScored = {}
removedFigures = {}
featureMarkers = {}
scoringRewards = {}

largestCity = 0
longestRoad = 0
scoreSummary = {}
activePlayers = {}
currentPlayer = nil

shepherdAwaitingAction = nil
newBarn = nil
hasBuilderAwaitingAction = false
hasAlreadyTakenBuilderTile = false
buriedTile = nil
dragonHasAwaken = false
dragonMoveNumber = 1
dragonIllegalTiles = {}
tileHasVolcano = false
tileHasMagicPortal = false
flier = nil
flierOffset = nil
seducedKnights = {}

turnState = nil

stateMachine = {
    ['begin turn'] = {
        ['next'] = 'reward fairy'
    },
    ['reward fairy'] = {
        ['next'] = 'eliminate oldest flea'
    },
    ['eliminate oldest flea'] = {
        ['next'] = 'awaiting tile placement'
    },
    ['awaiting tile placement'] = {
        ['tile placed'] = 'check added tile features',
    },
    ['check added tile features'] = {
        ['next'] = 'check added tile feature - hill'
    },
    ['check added tile feature - hill'] = {
        ['next'] = 'check added tile feature - volcano'
    },
    ['check added tile feature - volcano'] = {
        ['next'] = 'check added tile feature - magic portal',
        ['dragon moved'] = 'check added tile feature - volcano - delay'
    },
    ['check added tile feature - volcano - delay'] = {
        ['next'] = 'check added tile feature - volcano - lock'
    },
    ['check added tile feature - volcano - lock'] = {
        ['next'] = 'check added tile feature - magic portal'
    },
    ['check added tile feature - magic portal'] = {
        ['next'] = 'check added tile feature - gold'
    },
    ['check added tile feature - gold'] = {
        ['next'] = 'check added tile feature extensions',
        ['has gold'] = 'place gold on tile'
    },
    ['place gold on tile'] = {
        ['next'] = 'awaiting gold placement'
    },
    ['awaiting gold placement'] = {
        ['next'] = 'check added tile feature extensions'
    },
    ['check added tile feature extensions'] = {
        ['next'] = 'awaiting figure decision'
    },
    ['awaiting figure decision'] = {
        ['skip figure'] = 'post figure events',
        ['retrieve abbot'] = 'retrieve abbot',
        ['placed figure'] = 'post figure events',
        ['placed shepherd'] = 'initialize shepherd',
        ['placed flier'] = 'wait for flier roll',
        ['placed fairy'] = 'post figure events',
        ['seduce knight'] = 'seduce knight'
    },
    ['retrieve abbot'] = {
        ['figures returned'] = 'retrieve abbot - delay'
    },
    ['retrieve abbot - delay'] = {
        ['next'] = 'post figure events'
    },
    ['wait for flier roll'] = {
        ['die rolled'] = 'check flier destination'
    },
    ['check flier destination'] = {
        ['feature available'] = 'awaiting flier decision',
        ['feature unavailable'] = 'return flier'
    },
    ['awaiting flier decision'] = {
        ['placed flier'] = 'post figure events'
    },
    ['return flier'] = {
        ['figures returned'] = 'return flier - delay'
    },
    ['return flier - delay'] = {
        ['next'] = 'post figure events'
    },
    ['seduce knight'] = {
        ['figures returned'] = 'seduce knight - delay'
    },
    ['seduce knight - delay'] = {
        ['next'] = 'post figure events'
    },
    ['post figure events'] = {
        ['next'] = 'post figure event - prompt shepherd'
    },
    ['post figure event - prompt shepherd'] = {
        ['next'] = 'check added tile feature - dragon'
    },
    ['initialize shepherd'] = {
        ['next'] = 'initialize shepherd - finish'
    },
    ['initialize shepherd - finish'] = {
        ['next'] = 'post figure events'
    },
    ['check added tile feature - dragon'] = {
        ['has dragon'] = 'post figure event - dragon movement',
        ['no dragon'] = 'score features'
    },
    ['post figure event - dragon movement'] = {
        ['next'] = 'score features',
        ['figures returned'] = 'post figure event - dragon movement - delay',
        ['dragon moved'] = 'post figure event - dragon movement - delay'
    },
    ['post figure event - dragon movement - delay'] = {
        ['next'] = 'post figure event - dragon movement - lock'
    },
    ['post figure event - dragon movement - lock'] = {
        ['next'] = 'post figure event - dragon movement'
    },
    ['score features'] = {
        ['next'] = 'post scoring events',
        ['figures returned'] = 'score features - delay'
    },
    ['score features - delay'] = {
        ['next'] = 'score features',
    },
    ['post scoring events'] = {
        ['next'] = 'reward gold'
    },
    ['reward gold'] = {
        ['next'] = 'replace finished wagons'
    },
    ['replace finished wagons'] = {
        ['next'] = 'check for extra builder turn',
    },
    ['check for extra builder turn'] = {
        ['has builder'] = 'awaiting tile placement',
        ['no builder'] = 'end turn'
    },
    ['end turn'] = {
        ['next'] = 'begin turn'
    },
    ['game over'] = {
        ['next'] = 'game over',
        ['figures returned'] = 'game over - delay'
    },
    ['game over - delay'] = {
        ['next'] = 'game over',
    }
}

function stateHandler()
    if turnState == nil then
        --game hasn't started yet. This should never happen.
        return
    end
    debugMessage(1, "stateHandler - " .. turnState)
    if turnState == 'begin turn' then
        hasAlreadyTakenBuilderTile = false
        wagonLocations = {}
        hasAvailableWagonFeature = {}
        newBarn = nil
        lastPlacedTileX = nil
        return nextState('next')
    elseif turnState == 'reward fairy' then
        return rewardFairy()
    elseif turnState == 'eliminate oldest flea' then
        return nextState('next')
    elseif turnState == 'awaiting tile placement' then
        return
    elseif turnState == 'check added tile features' then
        buriedTile = nil
        tileHasVolcano = false
        tileHasMagicPortal = false
        seducedKnights = {}
        currentPlayerAbbot = nil
        shepherdAwaitingAction = nil
        hasBuilderAwaitingAction = false
        return nextState('next')
    elseif turnState == 'check added tile feature - hill' then
        return checkTileForHill()
    elseif turnState == 'check added tile feature - volcano' then
        return checkTileForVolcano()
    elseif turnState == 'check added tile feature - volcano - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=2.00})
    elseif turnState == 'check added tile feature - volcano - lock' then
        getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid).lock()
        return nextState('next')
    elseif turnState == 'check added tile feature - magic portal' then
        return checkTileForMagicPortal()
    elseif turnState == 'check added tile feature - gold' then
        return checkTileForGold()
    elseif turnState == 'place gold on tile' then
        return addGoldToTile(lastPlacedTileX, lastPlacedTileZ)
    elseif turnState == 'awaiting gold placement' then
        gameNotification("Choose a location to place the gold bar", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return displayGoldButtons()
    elseif turnState == 'check added tile feature extensions' then
        return checkAddedTileFeatureExtensions()
    elseif turnState == 'awaiting figure decision' then
        gameNotification("Place a figure if desired.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        local fairy = getObjectFromGUID(expansionBags['PnD'].contents['PnDFairy'].guid)
        if controlPanelSettings['PnDFairy'] and fairy ~= nil then
            fairy.unlock()
            fairy.highlightOn({1,1,1})
        end
        return displayFigureButtons()
    elseif turnState == 'retrieve abbot' then
        return
    elseif turnState == 'retrieve abbot - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'wait for flier roll' then
        getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
        gameNotification("Roll the flier die to determine your flier's distance.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'check flier destination' then
        return checkFlierDestination()
    elseif turnState == 'awaiting flier decision' then
        gameNotification("Place the flier on the destination tile.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'initialize shepherd' then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        if controlPanelSettings['PnDDragon'] then
            return addSheepToTile(shepherd)
        else
            return addSheepToField(shepherd)
        end
    elseif turnState == 'initialize shepherd - finish' then
        shepherdAwaitingAction = nil
        return nextState('next')
    elseif turnState == 'seduce knight' then
        return returnFigures()
    elseif turnState == 'seduce knight - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'return flier' then
        return returnFigures()
    elseif turnState == 'return flier - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'post figure events' then
        getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
        if currentPlayerAbbot ~= nil then
            getObjectFromGUID(currentPlayerAbbot).clearButtons()
        end
        for _, knight in ipairs(seducedKnights) do
            getObjectFromGUID(knight).clearButtons()
        end
        local fairy = getObjectFromGUID(expansionBags['PnD'].contents['PnDFairy'].guid)
        if controlPanelSettings['PnDFairy'] and fairy ~= nil then
            fairy.lock()
            fairy.highlightOff()
        end
        seducedKnights = {}
        currentPlayerAbbot = nil
        return nextState('next')
    elseif turnState == 'post figure event - prompt shepherd' then
        return promptShepherd()
    elseif turnState == 'check added tile feature - dragon' then
        shepherdAwaitingAction = nil
        return checkTileForDragon()
    elseif turnState == 'post figure event - dragon movement' then
        if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
        if dragonMoveNumber <= 6 then
            return createDragonButtons()
        else
            return nextState('next')
        end
    elseif turnState == 'post figure event - dragon movement - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=1.00})
    elseif turnState == 'post figure event - dragon movement - lock' then
        getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid).lock()
        return nextState('next')
    elseif turnState == 'score features' then
        currentMiniTurn = nil
        for _, tileCoords in ipairs(dragonIllegalTiles) do
            getObjectFromGUID(tileGrid[tileCoords[1]][tileCoords[2]].tile_guid).highlightOff()
        end
        return scoreFeatures()
    elseif turnState == 'score features - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'post scoring events' then
        return nextState('next')
    elseif turnState == 'reward gold' then
        return rewardGold()
    elseif turnState == 'replace finished wagons' then
        return replaceFinishedWagons()
    elseif turnState == 'check for extra builder turn' then
        if hasBuilderAwaitingAction then
            hasAlreadyTakenBuilderTile = true
            allGameMessage(activePlayers[currentPlayer] .."'s builder has allowed them to draw another tile. Please do so, along with the usual actions, before ending your turn.", stringColorToRGB(activePlayers[currentPlayer]), activePlayers[currentPlayer])
            return nextState('has builder')
        else
            return nextState('no builder')
        end
    elseif turnState == 'end turn' then
        return endTurn()
    elseif turnState == 'game over' then
        return scoreFeatures()
    elseif turnState == 'game over - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    end
end

function nextState(action)
    if stateMachine[turnState] ~= nil then
        if stateMachine[turnState][action] ~= nil then
            turnState = stateMachine[turnState][action]
            return stateHandler()
        else
            allErrorMessage("Error: action - " .. action .. " does not exist for current state - " .. turnState, activePlayers[currentPlayer])
        end
    else
        allErrorMessage("Error: current state does not exist - " .. turnState, activePlayers[currentPlayer])
    end
end

function progressState()
    return nextState('next')
end

function progressPartiallyCompleteStates()
    if turnState == 'score features' then
        allGameMessage("Loaded game was in the middle of scoring. Game pieces may need to be removed manually. Skipping to post scoring events. Some unscored pieces may remain.", stringColorToRGB(activePlayers[currentPlayer]), activePlayers[currentPlayer])
        turnState = 'post scoring events'
    end
end

function onload(save_state)
    if save_state ~= nil then
        local saved_data = JSON.decode(save_state)
        if saved_data.showMarkers ~= nil then
            showMarkers = saved_data.showMarkers
            showMarkersButtonParam.label = 'Show\nMarkers:\n' .. showMarkers
        end
        if saved_data.tileGrid ~= nil then tileGrid = saved_data.tileGrid end
        if saved_data.lastPlacedTileX ~= nil then lastPlacedTileX = saved_data.lastPlacedTileX end
        if saved_data.lastPlacedTileZ ~= nil then lastPlacedTileZ = saved_data.lastPlacedTileZ end
        if saved_data.controlPanelSettings ~= nil then
            controlPanelSettings = saved_data.controlPanelSettings
        end
        if saved_data.scores ~= nil then
            for player, score in pairs(saved_data.scores) do
                local scoreCounter = getObjectFromGUID(SCORE_COUNTER_GUIDS[player])
                if scoreCounter ~= nil then
                    scoreCounter.Counter.setValue(score)
                end
            end
        end
        if saved_data.figurePositions ~= nil then figurePositions = saved_data.figurePositions end
        if saved_data.gameover ~= nil then
            gameover = saved_data.gameover
            if not gameover then
                endGameButtonParam.label = 'End game\n(score\npoints)'
            end
        end
        if saved_data.activePlayers ~= nil then activePlayers = saved_data.activePlayers end
        if saved_data.currentPlayer ~= nil then currentPlayer = saved_data.currentPlayer end
        if saved_data.scoreSummary ~= nil then scoreSummary = saved_data.scoreSummary end
        if saved_data.largestCity ~= nil then largestCity = saved_data.largestCity end
        if saved_data.longestRoad ~= nil then longestRoad = saved_data.longestRoad end
        if saved_data.playerPossessionScriptingZones ~= nil then playerPossessionScriptingZones = saved_data.playerPossessionScriptingZones end
        if saved_data.turnState ~= nil then turnState = saved_data.turnState end
        if saved_data.wagonLocations ~= nil then wagonLocations = saved_data.wagonLocations end
        if saved_data.hasAvailableWagonFeature ~= nil then hasAvailableWagonFeature = saved_data.hasAvailableWagonFeature end
        if saved_data.currentMiniTurn ~= nil then currentMiniTurn = saved_data.currentMiniTurn end
        if saved_data.shepherdAwaitingAction ~= nil then shepherdAwaitingAction = saved_data.shepherdAwaitingAction end
        if saved_data.newBarn ~= nil then newBarn = saved_data.newBarn end
        if saved_data.hasBuilderAwaitingAction ~= nil then hasBuilderAwaitingAction = saved_data.hasBuilderAwaitingAction end
        if saved_data.hasAlreadyTakenBuilderTile ~= nil then hasAlreadyTakenBuilderTile = saved_data.hasAlreadyTakenBuilderTile end
        if saved_data.buriedTile ~= nil then buriedTile = saved_data.buriedTile end
        if saved_data.dragonHasAwaken ~= nil then dragonHasAwaken = saved_data.dragonHasAwaken end
        if saved_data.dragonMoveNumber ~= nil then dragonMoveNumber = saved_data.dragonMoveNumber end
        if saved_data.dragonIllegalTiles ~= nil then dragonIllegalTiles = saved_data.dragonIllegalTiles end
        if saved_data.tileHasVolcano ~= nil then tileHasVolcano = saved_data.tileHasVolcano end
        if saved_data.tileHasMagicPortal ~= nil then tileHasMagicPortal = saved_data.tileHasMagicPortal end
        if saved_data.removedFigures ~= nil then removedFigures = saved_data.removedFigures end
        if saved_data.featureMarker_GUIDs ~= nil then
            for _, featureMarker_GUID in ipairs(saved_data.featureMarker_GUIDs) do
                getObjectFromGUID(featureMarker_GUID).destruct()
            end
        end
    else
        local startingTile = getObjectFromGUID(STARTING_TILE_GUID)
        tileGrid[25] = {}
        tileGrid[25][25] = {}
        tileGrid[25][25].tile_guid = STARTING_TILE_GUID
        tileGrid[25][25].rotation = 2
        clearCounters()
    end

    local notes = getNotebookTabs()
    for _, note in ipairs(notes) do
        if note.title == "Debug Log" then
            debugLogTabIndex = note.index
            return
        end
    end
    -- params = {}
    -- params.title = "Debug Log"
    -- params.body = "LOG START"
    -- params.color = "Grey"
    -- debugLogTabIndex = addNotebookTab(params)
    buttonBoard = getObjectFromGUID(BUTTON_BOARD_GUID)
    buttonBoard.createButton(showMarkersButtonParam)
    buttonBoard.createButton(endGameButtonParam)
    buttonBoard.createButton(skipTurnButtonParam)
    if DEBUG_BUTTONS then
        buttonBoard.createButton(debugButtonParam)
        buttonBoard.createButton(showTransversalParam)
    end

    if activePlayers ~= nil and currentPlayer ~= nil then
        if controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat'] ~= nil then
            allGameMessage("Game loaded. It is now " .. activePlayers[currentPlayer] .. "'s turn on state: " .. turnState .. ". " .. activePlayers[currentPlayer] .. " is controlled by " .. stringToBracketedHex(controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat']) .. controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat'] .. ".", stringColorToRGB(activePlayers[currentPlayer]), activePlayers[currentPlayer])
        else
            allGameMessage("Game loaded. It is now " .. activePlayers[currentPlayer] .. "'s turn on state: " .. turnState .. ".", stringColorToRGB(activePlayers[currentPlayer]), activePlayers[currentPlayer])
        end
        allGameMessage("Please note that rewinds are not supported. You may need to clean some things up if the state was saved while the script was running.", NEUTRAL_COLOR)
    end
    progressPartiallyCompleteStates()
    return stateHandler()
end

function onSave()
    --retrieve scores
    local scores = {}
    for player, scoreCounter_GUID in pairs(SCORE_COUNTER_GUIDS) do
        local scoreCounter = getObjectFromGUID(scoreCounter_GUID)
        if scoreCounter ~= nil then
            scores[player] = scoreCounter.Counter.getValue()
        end
    end
    local featureMarker_GUIDs = {}
    if featureMarkers ~= nil then
        for i, featureMarker in ipairs(featureMarkers) do
            featureMarker_GUIDs[i] = featureMarker.getGUID()
        end
    end
    local toSave = {
        showMarkers = showMarkers,
        tileGrid = tileGrid,
        lastPlacedTileX = lastPlacedTileX,
        lastPlacedTileZ = lastPlacedTileZ,
        controlPanelSettings = controlPanelSettings,
        scores = scores,
        figurePositions = figurePositions,
        gameover = gameover,
        activePlayers = activePlayers,
        currentPlayer = currentPlayer,
        scoreSummary = scoreSummary,
        largestCity = largestCity,
        longestRoad = longestRoad,
        playerPossessionScriptingZones = playerPossessionScriptingZones,
        --the following is partial turn data
        turnState = turnState,
        wagonLocations = wagonLocations,
        hasAvailableWagonFeature = hasAvailableWagonFeature,
        currentMiniTurn = currentMiniTurn,
        shepherdAwaitingAction = shepherdAwaitingAction,
        newBarn = newBarn,
        hasBuilderAwaitingAction = hasBuilderAwaitingAction,
        hasAlreadyTakenBuilderTile = hasAlreadyTakenBuilderTile,
        --the following is partial state data (for when a state doesn't completely finish)
        buriedTile = buriedTile,
        dragonHasAwaken = dragonHasAwaken,
        dragonIllegalTiles = dragonIllegalTiles,
        dragonMoveNumber = dragonMoveNumber,
        tileHasVolcano = tileHasVolcano,
        tileHasMagicPortal = tileHasMagicPortal,
        removedFigures = removedFigures,
        --if script was in the middle of making feature markers or deleting, delete them after loading
        featureMarker_GUIDs = featureMarker_GUIDs
    }
    return JSON.encode(toSave)
end

m_Routines = {}

--[[ The Update function. This is called once per frame. --]]
function update()
    --this replaces the built-in coroutine functions, since the built-in ones have the unfortunate side-effect that they continue to run after loading a game. These will not.
    local iNumRoutines = #m_Routines

    for i = iNumRoutines, 1, -1 do
        local sStatus = coroutine.status(m_Routines[i].Co)
        --resume all coroutines with yield 0
        if sStatus == 'suspended' and m_Routines[i].iYield == 0 then
            local bRes = false
            local iYield = 0

            bRes, iYield = coroutine.resume(m_Routines[i].Co) --resume the coroutine and save the value from yield (to allow to use e.g. yield(1) to not have it resumed automatically)

            iYield = iYield or 0 --default to 0 (-> both .yield() and .yield(0) works)
            m_Routines[i].iYield = iYield
        --clear finished routines
        elseif sStatus == 'dead' then
            table.remove(m_Routines, i)
        end
    end
end

function checkControlPanelPrivileges(player)
    if not gameover then
        broadcastToColor('Game has already started', player.sColor, NEUTRAL_COLOR)
        return false
    end
    local PPlayer = Player[player.sColor]
    if PPlayer ~= nil then
        if PPlayer.admin then
            return true
        else
            broadcastToColor('Only promoted players can use the control panel', player.sColor, ERROR_COLOR)
        end
    end
    return false
end

function checkAdminPrivileges(player)
    local PPlayer = Player[player]
    if PPlayer ~= nil then
        if PPlayer.admin then
            return true
        else
            broadcastToColor('Only promoted players can use this button', player, ERROR_COLOR)
        end
    end
    return false
end

function checkGameButtonPrivileges(player)
    local PPlayer = Player[player]
    if PPlayer ~= nil then
        if PPlayer.admin or
        (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
        (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            return true
        else
            broadcastToColor('Only the current player or promoted players can use this button', player, ERROR_COLOR)
        end
    end
    return false
end

function getControlPanelState(p)
    return controlPanelSettings[p.key]
end

function setControlPanelState(p)
    controlPanelSettings[p.key] = p.value
end

--rotates coordinates in steps of 90 degrees
function rotateCoordinates(x, z, rotation)
    if rotation == 1 then
        temp = x
        x = -z
        z = temp
    elseif rotation == 2 then
        x = -x
        z = -z
    elseif rotation == 3 then
        temp = x
        x = z
        z = -temp
    end
    return x, z
end

--rotates coordinates in degrees
function rotateCoordinatesDegrees(x, z, rotation)
    local rad_rotation = math.rad(rotation)
    local new_x = x * math.cos(rad_rotation) - z * math.sin(rad_rotation)
    local new_z = z * math.cos(rad_rotation) + x * math.sin(rad_rotation)
    return new_x, new_z
end

function cbSpawnUnlock()
    gSpawnLock = false
end

function onPlayerChangedColor(player)

end

function onPlayerTurnEnd(player_color_end, player_color_next )

end

function onFlierDiceRolled(params)
    if params.sPlayer ~= nil then
        player = params.sPlayer
        if (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
            (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            if turnState == 'wait for flier roll' then
                local dieValue = getObjectFromGUID(expansionBags['Flier'].contents['FlierDie'].guid).getValue()
                if dieValue > 3 then dieValue = 7 - dieValue end
                debugMessage(1, params.sPlayer .. ' rolled a ' .. dieValue)
                local FLIER_OFFSET = {{x=-1,z=1},{x=0,z=1},{x=1,z=1},{x=1,z=0},{x=1,z=-1},{x=0,z=-1},{x=-1,z=-1},{x=-1,z=0}}
                flierOffset = {x=FLIER_OFFSET[flierDirection].x * dieValue, z=FLIER_OFFSET[flierDirection].z * dieValue}
                debugMessage(1, "Flier direction: " .. flierDirection .. " Flier destination offset: x: " .. flierOffset.x .. " z: " .. flierOffset.z)
                return nextState('die rolled')
            else
                allErrorMessage("It is currently not allowed to roll the flier die. You are only allowed to roll the die after you've placed a follower on the flier feature. Current state: " .. turnState, params.sPlayer)
            end
        else
            playerErrorMessage("ERROR: It is not currently your turn OR you rolled the die without picking it up.", params.sPlayer)
        end
    end
end

function skipTurnButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        endTurn()
    end
end

function endTurn()
    if not gameover then
        if lastPlacedTileX == nil or not (controlPanelSettings['PnDDragon'] and tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid == expansionBags['RiverII'].contents['EndTiles'].contents['Volcano Lake'].guid) then
            currentPlayer = currentPlayer + 1
            if currentPlayer > #activePlayers then
                currentPlayer = 1
            end
            allGameMessage("-----------It is now " .. activePlayers[currentPlayer] .. "'s turn-----------", stringColorToRGB(activePlayers[currentPlayer]), activePlayers[currentPlayer])
            if controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat'] ~= nil then
                allGameMessage("-------" .. activePlayers[currentPlayer] .. " is controlled by " .. stringToBracketedHex(controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat']) .. controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat'] .. stringToBracketedHex(activePlayers[currentPlayer]) .. "------", stringColorToRGB(activePlayers[currentPlayer]), nil)
            end
        else
            allGameMessage(activePlayers[currentPlayer] .. " gets another turn for laying down the volcano lake tile.", stringColorToRGB(activePlayers[currentPlayer]), activePlayers[currentPlayer])
        end
        turnState = 'begin turn' --in case skip turn was pressed, go to the beginning from every state
        return stateHandler()
    end
end

--if the current player is a hotseat player, return the owner
function getCurrentPlayerOwner()
    if currentPlayer == nil then return nil end
    local player
    if currentMiniTurn ~= nil and controlPanelSettings[activePlayers[currentMiniTurn] .. 'Hotseat'] ~= nil then
        player = controlPanelSettings[activePlayers[currentMiniTurn] .. 'Hotseat']
    end
    if currentMiniTurn == nil and controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat'] ~= nil then
        player = controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat']
    end
    return player
end

-- Activates when button is pressed
function showMarkersToggleButton(object, sPlayer)
    if checkAdminPrivileges(sPlayer) then
        -- Toggles between different showMarker modes
        if showMarkers == 'Scoring' then showMarkers = 'Tiles'
        elseif showMarkers == 'Tiles' then showMarkers = 'Both'
        elseif showMarkers == 'Both' then showMarkers = 'None'
        elseif showMarkers == 'None' then showMarkers = 'Scoring'
        end
        showMarkersButtonParam.label = 'Show\nMarkers:\n' .. showMarkers
        buttonBoard.editButton(showMarkersButtonParam)
    end
end

function gameToggleButton(object, sPlayer)
    if checkAdminPrivileges(sPlayer) then
        if gameover then
            endGameButtonParam.label = 'End game\n(score\npoints)'
            startGame()
        else
        endGameButtonParam.label = 'Score\nSummary'
            endGameButtonParam.click_function = 'printScoreSummary'
            endGame()
        end
        buttonBoard.editButton(endGameButtonParam)
    end
end

function startGame()
    if #getSeatedPlayers() == 0 then return end
    for _, player in ipairs(PLAYER_COLORS) do
        if Player[player].seated or controlPanelSettings[player .. 'Hotseat'] ~= nil then
            table.insert(activePlayers, player)
            if Player[player].seated and vipFigureSettings[Player[player].steam_id] ~= nil and vipFigureSettings[Player[player].steam_id]['Intro'] ~= nil then
                allGameMessage(string.format(vipFigureSettings[Player[player].steam_id]['Intro'], Player[player].steam_name), NEUTRAL_COLOR)
            end
        end
    end
    currentPlayer = math.random(#activePlayers)
    preparePlayerPossessionAreaFinished = false
    prepareNeutralItemsFinished = false
    prepareStartingTilesFinished = false
    initializeScoreSummary()
    startLuaCoroutine(self, 'prepareTileStack')
    startLuaCoroutine(self, 'prepareStartingTiles')
    startLuaCoroutine(self, 'preparePlayerPossessionArea')
    startLuaCoroutine(self, 'prepareNeutralItems')
end

function initializeScoreSummary()
    for _, player in pairs(activePlayers) do
        scoreSummary[player] = {}
        scoreSummary[player]['City'] = 0
        scoreSummary[player]['Road'] = 0
        scoreSummary[player]['Field'] = 0
        scoreSummary[player]['Cloister'] = 0
        if controlPanelSettings['TnBTradeGoods'] then
            scoreSummary[player]['Trade Goods'] = 0
        end
        if controlPanelSettings['HnSShepherd'] then
            scoreSummary[player]['Shepherd'] = 0
        end
        if controlPanelSettings['PnDFairy'] then
            scoreSummary[player]['Fairy'] = 0
        end
        if controlPanelSettings['KnRBKing'] or controlPanelSettings['KnRBRobber'] then
            scoreSummary[player]['King/Robber Tokens'] = 0
        end
        if controlPanelSettings['GoldminesGold'] then
            scoreSummary[player]['Gold'] = 0
        end
    end
end

function scorePoints(player, feature, points)
    if feature == 'Abbey' or feature == 'Shrine' or feature == 'Garden' or feature == "Baba Yaga's Hut" then feature = 'Cloister' end --these don't really need a seperate category
    scoreSummary[player][feature] = scoreSummary[player][feature] + points
    local scoreCounter = getObjectFromGUID(SCORE_COUNTER_GUIDS[player])
    if scoreCounter ~= nil then
        scoreCounter.Counter.setValue(scoreCounter.Counter.getValue() + points)
    else
        allErrorMessage("Error adding score to " .. figure.getDescription() .. "'s counter")
    end
end

function printScoreSummary(object, sPlayer)
    printedPlayers = {}
    local playerNum = 1
    local rank = 1
    local lastHighscore = 0
    while true do
        local highscore = 0
        local color = nil
        for _, player in pairs(activePlayers) do
            local scoreCounter = getObjectFromGUID(SCORE_COUNTER_GUIDS[player])
            if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                if scoreCounter.Counter.getValue() > highscore then
                    highscore = scoreCounter.Counter.getValue()
                    color = player
                end
            end
        end
        if highscore > 0 then
            if highscore < lastHighscore then rank = playerNum end
            local steam_name = ""
            if controlPanelSettings[color .. 'Hotseat'] ~= nil then
                if Player[controlPanelSettings[color .. 'Hotseat']].steam_name ~= nil then steam_name = Player[controlPanelSettings[color .. 'Hotseat']].steam_name .. " (Hotseat)" end
            else
                if Player[color].steam_name ~= nil then steam_name = Player[color].steam_name end
            end
            printToColor("#" ..rank .. " - " .. highscore .. " points - ".. color .. " - " .. steam_name, sPlayer, stringColorToRGB(color))
            local accountedPoints = 0
            for key, score in pairs(scoreSummary[color]) do
                local featureName = key
                if key == 'Field' then featureName = 'Farms'
                elseif key == 'Road' then featureName = 'Roads'
                elseif key == 'City' then featureName = 'Cities'
                elseif key == 'Cloister' then featureName = 'Cloisters'
                end
                printToColor("  " .. featureName .. ": " .. score, sPlayer, stringColorToRGB(color))
                accountedPoints = accountedPoints + score
            end
            if accountedPoints ~= highscore then
                printToColor("  unaccounted points: " .. highscore - accountedPoints, sPlayer, stringColorToRGB(color))
            end
        else
            break
        end
        table.insert(printedPlayers, color)
        playerNum = playerNum + 1
        lastHighscore = highscore
    end
end

function prepareTileStack()
    local tileStack = getObjectFromGUID(TILE_STACK_GUID)
    if tileStack ~= nil then
        local tileStackPosition = tileStack.getPosition()
        local tileStackAddPosition = tileStackPosition
        local stackY = tileStackPosition.y
        for rule_id, rule in pairs(tileSettings) do
            if controlPanelSettings[rule_id] then
                for expansion_id, expansion in pairs(rule) do
                    for item_id, item_settings in pairs(expansion) do
                        tileStackAddPosition.y = stackY + 1 + tileStack.getQuantity() * TILE_THICKNESS
                        prepareTileLock = true
                        if takeObjectSafe(getObjectFromGUID(expansionBags[expansion_id].guid), {guid = expansionBags[expansion_id].contents[item_id].guid, position = tileStackAddPosition, rotation = {0,180,180}, callback_owner = Global, callback = "prepareTileUnlock"}) == nil then
                            prepareTileLock = false
                        end
                        while prepareTileLock do
                            coroutine.yield(0)
                        end
                        wait(1.0)
                    end
                end
            end
        end
        while not preparePlayerPossessionAreaFinished or not prepareNeutralItemsFinished or not prepareStartingTilesFinished do
            coroutine.yield(0)
        end
        wait(1)
        --shuffle and lock starting tiles
        for rule_id, rule in pairs(startingTileSettings) do
            if controlPanelSettings[rule_id] then
                for expansion_id, expansion in pairs(rule) do
                    for item_id, item_settings in pairs(expansion) do
                        local stackObject = getObjectFromGUID(expansionBags[expansion_id].contents[item_id].guid)
                        if stackObject ~= nil then
                            if item_settings.shuffle then stackObject.shuffle() end
                            if item_settings.lock then stackObject.lock() end
                        end
                        if item_settings.contents ~= nil then
                            for sub_item_id, sub_item_settings in pairs(item_settings.contents) do
                                local sub_tile = getObjectFromGUID(expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid)
                                if sub_tile ~= nil then
                                    if sub_item_settings.lock then sub_tile.lock() end
                                    if sub_item_settings.addToGrid then
                                        local xIndex = math.floor((sub_item_settings.position.x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                        local zIndex = math.floor((sub_item_settings.position.z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                        if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
                                        tileGrid[xIndex][zIndex] = {}
                                        tileGrid[xIndex][zIndex].tile_guid = expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid
                                        local tileRotation = math.floor(sub_item_settings.rotation.y / 90 + 0.5)
                                        if tileRotation == 0 then tileRotation = 4 end
                                        tileGrid[xIndex][zIndex].rotation = tileRotation
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        tileStack.shuffle()
        if controlPanelSettings['StartingTileRiverII'] then
            allGameMessage("You are currently playing with the river. Please place a river tile, then you may add more to it. According to the rules, the fork should be the first tile placed, followed by the facedown tiles until they are gone, and then the spring and lake piece.", NEUTRAL_COLOR)
        elseif controlPanelSettings['StartingTileRiver'] or controlPanelSettings['StartingTileRiverBB5'] then
            allGameMessage("You are currently playing with the river. Please place a river tile, then you may add more to it. According to the rules, the spring should be the first tile placed, followed by the facedown tiles until they are gone, and then the lake.", NEUTRAL_COLOR)
        end
        allGameMessage("Game started. Good luck!", NEUTRAL_COLOR)
        if controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat'] ~= nil then
            allGameMessage(activePlayers[currentPlayer] .. " was randomly chosen as the first player. " .. activePlayers[currentPlayer] .. " is controlled by " .. stringToBracketedHex(controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat']) .. controlPanelSettings[activePlayers[currentPlayer] .. 'Hotseat'] .. ".", stringColorToRGB(activePlayers[currentPlayer]), activePlayers[currentPlayer])
        else
            allGameMessage(activePlayers[currentPlayer] .. " was randomly chosen as the first player.", stringColorToRGB(activePlayers[currentPlayer]))
        end
    else
        allErrorMessage("Error: Tile stack not found. Scripting will be partially broken unless the game is reloaded.")
    end
    gameover = false
    turnState = 'begin turn'
    stateHandler()
    return 1
end

function prepareTileUnlock()
    prepareTileLock = false
end

function prepareStartingTiles()
    if not controlPanelSettings['StartingTileBase'] then
        local baseStartingTile = getObjectFromGUID(STARTING_TILE_GUID)
        if baseStartingTile ~= nil then
            baseStartingTile.destruct()
            STARTING_TILE_GUID = nil
            tileGrid[25][25] = nil
        end
    end
    local hasRiverEndTiles = false
    for rule_id, rule in pairs(startingTileSettings) do
        if controlPanelSettings[rule_id] then
            for expansion_id, expansion in pairs(rule) do
                for item_id, item_settings in pairs(expansion) do
                    if item_id ~= "EndTiles" or not hasRiverEndTiles then
                        prepareStartingTileLock = true
                        if takeObjectSafe(getObjectFromGUID(expansionBags[expansion_id].guid), {guid = expansionBags[expansion_id].contents[item_id].guid, position = item_settings.position, rotation = item_settings.rotation, callback_owner = Global, callback = "prepareStartingTileUnlock"}) == nil then
                            prepareStartingTileLock = false
                        end
                        while prepareStartingTileLock do
                            coroutine.yield(0)
                        end
                        if item_id == "EndTiles" then hasRiverEndTiles = true end
                        wait(0.4)
                    end
                    if item_settings.contents ~= nil then
                        for sub_item_id, sub_item_settings in pairs(item_settings.contents) do
                            prepareStartingTileLock = true
                            if getObjectFromGUID(expansionBags[expansion_id].contents[item_id].guid) ~= nil then
                                getObjectFromGUID(expansionBags[expansion_id].contents[item_id].guid).takeObject({guid = expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid, position = sub_item_settings.position, rotation = sub_item_settings.rotation, callback_owner = Global, callback = "prepareStartingTileUnlock"})
                            else
                                getObjectFromGUID(expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid).setPositionSmooth(sub_item_settings.position)
                                getObjectFromGUID(expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid).setRotationSmooth(sub_item_settings.rotation)
                                prepareStartingTileLock = false
                                wait(2)
                            end
                            while prepareStartingTileLock do
                                coroutine.yield(0)
                            end
                        end
                    end
                end
            end
        end
    end
    prepareStartingTilesFinished = true
    return 1
end

function prepareStartingTileUnlock()
    prepareStartingTileLock = false
end

function preparePlayerPossessionArea()
    if controlPanelSettings['AnMAbbey'] then
        gSpawnLock = true
        if takeObjectSafe(getObjectFromGUID(expansionBags['AnM'].guid), {guid = expansionBags['AnM'].contents['AnMAbbey'].guid, position = {x = 0.0, y = 0.0, z = 0.0}, rotation = {0,180,0}, callback_owner = Global, callback = "cbSpawnUnlock"}) == nil then
            gSpawnLock = false
        end
        while gSpawnLock do
            coroutine.yield(0)
        end
    end
    for _, player in ipairs(activePlayers) do
        local x, z
        local playerPossessionArea = PLAYER_POSSESSION_AREAS[player]
        local params = {}
        params.rotation = {0.1,180,0.1}
        params.callback = "cbSpawnUnlock"  -- all the callback does is set gSpawnLock to false
        params.callback_owner = Global
        params.type = "ScriptingTrigger"
        x, z = rotateCoordinates(8.9, 1.75, playerPossessionArea.rotation)
        params.position = {playerPossessionArea.x + x, 1 + PLAYER_POSSESSION_ZONE_HEIGHT / 2, playerPossessionArea.z + z}
        gSpawnLock = true
        local zoneObj = spawnObject(params)
        while gSpawnLock do
            coroutine.yield(0)
        end
        zoneObj.setName(player .. " possession zone")
        local x_scale, z_scale
        if playerPossessionArea.rotation % 2 == 0 then
            x_scale = PLAYER_POSSESSION_ZONE_WIDTH
            z_scale = PLAYER_POSSESSION_ZONE_DEPTH
        else
            x_scale = PLAYER_POSSESSION_ZONE_DEPTH
            z_scale = PLAYER_POSSESSION_ZONE_WIDTH
        end
        zoneObj.setScale({x_scale, PLAYER_POSSESSION_ZONE_HEIGHT, z_scale})
        playerPossessionScriptingZones[player] = zoneObj.getGUID()

        if controlPanelSettings['AnMAbbey'] then
            x, z = rotateCoordinates(-7.15, 0.0, playerPossessionArea.rotation)
            params.position = {playerPossessionArea.x + x, 2, playerPossessionArea.z + z}
            params.rotation = {0, playerPossessionArea.rotation * -90, 0}
            params.callback_owner = Global
            params.callback = "cbSpawnUnlock"
            getObjectFromGUID(expansionBags['AnM'].contents['AnMAbbey'].guid).takeObject(params)
        end

        local figurePad = getObjectFromGUID(FIGUREPAD_GUIDs[player])
        figurePositions[player] = {}

        for figureSetting, figure in pairs(figureSettings) do
            figurePositions[player][figure.name] = {}
            if controlPanelSettings[figureSetting] then
                if Player[player].seated and vipFigureSettings[Player[player].steam_id] ~= nil and vipFigureSettings[Player[player].steam_id][figureSetting] ~= nil then
                    figure = vipFigureSettings[Player[player].steam_id][figureSetting]
                end
                local num
                if figure.num ~= nil then num = controlPanelSettings[figure.num] else num = 1 end
                for i=1, num do
                    x, z = rotateCoordinatesDegrees(figure.offset.x + (((i - 1) % 4) * -1.45), figure.offset.z + (math.floor((i - 1) / 4) * 1.0), -figurePad.getRotation().y)
                    local params = {}
                    params.type = 'Custom_Model'

                    params.position = {figurePad.getPosition().x + x, 2, figurePad.getPosition().z + z}
                    params.rotation = {0, figurePad.getRotation().y, 0}
                    params.scale = figure.scale
                    params.callback_owner = Global
                    params.callback = "cbSpawnUnlock"
                    gSpawnLock = true
                    local obj = spawnObject(params)

                    local custom_params = {}
                    custom_params.mesh = figure.mesh
                    custom_params.diffuse = figure.diffuse
                    custom_params.type = 1
                    custom_params.material = 1
                    custom_params.specular_intensity = 0.05
                    obj.setCustomObject(custom_params)
                    obj.setName(figure.name)
                    obj.setDescription(player)
                    obj.setColorTint(stringColorToRGB(player))
                    obj.use_grid = false
                    obj.use_snap_points = figure.use_snap_points
                    while gSpawnLock do
                        coroutine.yield(0)
                    end
                    figurePositions[player][figure.name][i] = obj.getGUID()
                end
            end
        end
    end
    if controlPanelSettings['AnMAbbey'] then
        getObjectFromGUID(expansionBags['AnM'].contents['AnMAbbey'].guid).setPosition({x = getObjectFromGUID(expansionBags['AnM'].guid).getPosition().x, y = getObjectFromGUID(expansionBags['AnM'].guid).getPosition().y + 2, z = getObjectFromGUID(expansionBags['AnM'].guid).getPosition().z})
    end
    wait(2)
    preparePlayerPossessionAreaFinished = true
    return 1
end

function prepareNeutralItems()
    local offset = 0
    for rule_id, rule in pairs(neutralFigureSettings) do
        if controlPanelSettings[rule_id] then
            for expansion_id, expansion in pairs(rule) do
                for item_id, item_settings in pairs(expansion) do
                    neutralItemsLock = true
                    offset = offset + item_settings.width / 2
                    if takeObjectSafe(getObjectFromGUID(expansionBags[expansion_id].guid), {guid = expansionBags[expansion_id].contents[item_id].guid, position = {x = NEUTRAL_ITEMS_LOCATION.x + offset, y = NEUTRAL_ITEMS_LOCATION.y, z = NEUTRAL_ITEMS_LOCATION.z}, rotation = {0,180,0}, callback_owner = Global, callback = "neutralItemsUnlock"}) == nil then
                        neutralItemsLock = false
                    end
                    offset = offset + item_settings.width / 2
                    while neutralItemsLock do
                        coroutine.yield(0)
                    end
                end
            end
        end
    end
    prepareNeutralItemsFinished = true
    return 1
end

function neutralItemsUnlock()
    neutralItemsLock = false
end

function endGame()
    gameover = true
    if scoring ~= true then
        turnState = 'game over'
        stateHandler()
    end
end

-- Activates when button is pressed
function switchDebugLevel()
    -- switches between debug mode levels. Updates button's label to match
    debugMode = debugMode + 1
    if debugMode > 3 then debugMode = 0 end
    debugButtonParam.label = 'Debug mode:\n' .. debugMode
    buttonBoard.editButton(debugButtonParam)
end

-- sets the scores to 0
function clearCounters()
    --Clear all victory point counters
    for _, scoreCounter_GUID in pairs(SCORE_COUNTER_GUIDS) do
        local scoreCounter = getObjectFromGUID(scoreCounter_GUID)
        if scoreCounter ~= nil then
            scoreCounter.Counter.clear()
        end
    end
end

-- Activates whenever any object is dropped
function onObjectDropped(player, droppedObject)
    if droppedObject.getName() == "Position Marker" then
        print("x: " .. droppedObject.getPosition().x .. " y: " .. droppedObject.getPosition().y .. " z: " .. droppedObject.getPosition().z)
    end
    if not gameover then
        if (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
            (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            if not dropLock then
                dropLock = true
                lastDroppedObject_GUID = droppedObject.getGUID() --global used for the coroutines
                lastDroppedTime = os.clock()
                -- Checks if the dropped object was a single 'card' (tile)
                if tostring(droppedObject) == 'Card(Clone) (LuaGameObjectScript)' then
                    if turnState == 'awaiting tile placement' then
                        for _, featureMarker in ipairs(featureMarkers) do
                            featureMarker.destruct()
                        end
                        featureMarkers = {}
                        Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='checkTile', function_owner=nil, parameters={time=lastDroppedTime}, delay=1})
                    else
                        dropLock = false
                        if not spamLock then
                            allErrorMessage("It is currently not allowed to place a tile. You are only allowed to place a tile at the beginning of your turn. Current state: " .. turnState, player)
                            spamLock = true
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
                        end
                    end
                elseif table.contains(FOLLOWER_TYPES, droppedObject.getName()) or table.contains(SPECIAL_FIGURE_TYPES, droppedObject.getName()) or droppedObject.getName() == "Fairy" then
                    if (currentMiniTurn ~= nil and (droppedObject.getDescription() == activePlayers[currentMiniTurn])) or
                        (currentMiniTurn == nil and (droppedObject.getDescription() == activePlayers[currentPlayer])) or droppedObject.getName() == "Fairy" then
                        if turnState == 'awaiting figure decision' then
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='checkFigure', function_owner=nil, parameters={time=lastDroppedTime}, delay=2})
                        elseif turnState == 'replace finished wagons' then
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='checkWagon', function_owner=nil, parameters={time=lastDroppedTime}, delay=2})
                        elseif turnState == 'awaiting flier decision' then
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='checkFlier', function_owner=nil, parameters={time=lastDroppedTime}, delay=2})
                        else
                            dropLock = false
                            if not spamLock then
                                allErrorMessage("It is currently not allowed to place a figure. You are only allowed to place a figure after a tile. Current state: " .. turnState, player)
                                spamLock = true
                                Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters={time=lastDroppedTime}, delay=2})
                            end
                        end
                    else
                        dropLock = false
                        if not spamLock then
                            playerErrorMessage("Incorrect colored figure was dropped. Are you sure it is yours?", player)
                            spamLock = true
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
                        end
                    end
                else
                    dropLock = false
                end
            else
                if not spamLock then
                    allErrorMessage("Multiple pieces dropped too fast, please wait.", player)
                    spamLock = true
                    Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
                end
            end
        else
            if not spamLock then
                playerErrorMessage("It is currently not your turn. Dropped pieces will not count.", player)
                spamLock = true
                Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
            end
        end
    elseif tostring(droppedObject) == 'Card(Clone) (LuaGameObjectScript)' then
        if not spamLock then
            allErrorMessage("Game over or not yet started. Press the start game button and re-lay tile", player)
            spamLock = true
            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
        end
    end
end

function spamUnlock()
    spamLock = false
end

function onObjectPickedUp(player, pickedUpObject)
    if lastDroppedObject_GUID == pickedUpObject.getGUID() then
        dropLock = false
        lastDroppedTime = 0
    end
    if tostring(pickedUpObject) == 'Card(Clone) (LuaGameObjectScript)' then
        local xPosition = (pickedUpObject.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
        local zPosition = (pickedUpObject.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
        local xIndex = math.floor(xPosition + TILE_POSITION_MARGIN)
        local zIndex = math.floor(zPosition + TILE_POSITION_MARGIN)
        if tileGridOccupied(xIndex, zIndex) and tileGrid[xIndex][zIndex].tile_guid == pickedUpObject.getGUID() then
            if lastPlacedTileX ~= nil then
                getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
                if currentPlayerAbbot ~= nil then
                    getObjectFromGUID(currentPlayerAbbot).clearButtons()
                end
                for _, knight in ipairs(seducedKnights) do
                    getObjectFromGUID(knight).clearButtons()
                end
                seducedKnights = {}
            end
            tileGrid[xIndex][zIndex] = nil
            if pickedUpObject.getGUID() == STARTING_TILE_GUID then
                STARTING_TILE_GUID = nil
            end
            lastPlacedTileX = nil
            allGameMessage("Tile removed from grid", NEUTRAL_COLOR)
            if shepherdAwaitingAction ~= nil then
                getObjectFromGUID(shepherdAwaitingAction).clearButtons()
            end
            turnState = 'awaiting tile placement'
            stateHandler()
        end
        if (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
            (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            if turnState == 'awaiting tile placement' then
                showTileMarkers(pickedUpObject)
            end
        end
    elseif table.contains(FOLLOWER_TYPES, pickedUpObject.getName()) or table.contains(SPECIAL_FIGURE_TYPES, pickedUpObject.getName()) then
        -- if (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
        --     (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
        --     turnState = 'awaiting figure placement'
        -- end
        pickedUpObject.clearButtons()
    end
end

function showTileMarkers(newTile)
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    if showMarkers == 'Tiles' or showMarkers == 'Both' then
        tileMarkers = {}
        for x, tileColumn in pairs(tileGrid) do
            for z, tileLocation in pairs(tileColumn) do
                for side, sideDelta in pairs(SIDE_DELTA) do
                    if not tileGridOccupied(x + sideDelta.x, z + sideDelta.z) then
                        if tileMarkers[x + sideDelta.x] == nil then
                            tileMarkers[x + sideDelta.x] = {}
                        end
                        if tileMarkers[x + sideDelta.x][z + sideDelta.z] == nil then
                            tileMarkers[x + sideDelta.x][z + sideDelta.z] = false
                            if newTile.getTable("sides")[1] == 'Abbey' then
                                if tileGridOccupied(x + sideDelta.x + 1, z + sideDelta.z) and tileGridOccupied(x + sideDelta.x - 1, z + sideDelta.z) and tileGridOccupied(x + sideDelta.x, z + sideDelta.z + 1) and tileGridOccupied(x + sideDelta.x, z + sideDelta.z - 1) then
                                    tileMarkers[x + sideDelta.x][z + sideDelta.z] = true
                                end
                            else
                                for tileRotation=1, 4 do
                                    if ((not tileGridOccupied(x + sideDelta.x + 1, z + sideDelta.z) or tileConnectsToSide(newTile, tileRotation, 4, getObjectFromGUID(tileGrid[x + sideDelta.x + 1][z + sideDelta.z].tile_guid), tileGrid[x + sideDelta.x + 1][z + sideDelta.z].rotation)) and
                                    (not tileGridOccupied(x + sideDelta.x - 1, z + sideDelta.z) or tileConnectsToSide(newTile, tileRotation, 2, getObjectFromGUID(tileGrid[x + sideDelta.x - 1][z + sideDelta.z].tile_guid), tileGrid[x + sideDelta.x - 1][z + sideDelta.z].rotation)) and
                                    (not tileGridOccupied(x + sideDelta.x, z + sideDelta.z + 1) or tileConnectsToSide(newTile, tileRotation, 3, getObjectFromGUID(tileGrid[x + sideDelta.x][z + sideDelta.z + 1].tile_guid), tileGrid[x + sideDelta.x][z + sideDelta.z + 1].rotation)) and
                                    (not tileGridOccupied(x + sideDelta.x, z + sideDelta.z - 1) or tileConnectsToSide(newTile, tileRotation, 1, getObjectFromGUID(tileGrid[x + sideDelta.x][z + sideDelta.z - 1].tile_guid), tileGrid[x + sideDelta.x][z + sideDelta.z - 1].rotation))) then
                                        tileMarkers[x + sideDelta.x][z + sideDelta.z] = true
                                    end
                                end
                            end
                            local challengerTile = nil
                            local challengedTile = nil
                            local features = newTile.getTable("specialFeatures")
                            if features ~= nil then
                                for _, feature in ipairs(features) do
                                    if feature[1] == 'Cloister' or feature[1] == 'Shrine' then challengerTile = feature[1] end
                                    if feature[1] == 'Abbey' then challengerTile = 'Cloister' end
                                end
                            end
                            if tileMarkers[x + sideDelta.x][z + sideDelta.z] and challengerTile ~= nil then
                                if challengerTile == 'Cloister' then
                                    challengedTile = 'Shrine'
                                else
                                    challengedTile = 'Cloister'
                                end
                                local numChallenger = 1
                                local numChallenged = 0
                                for nested_x=-1, 1 do
                                    for nested_z=-1, 1 do
                                        if not (nested_x == 0 and nested_z == 0) and tileGridOccupied(x + sideDelta.x + nested_x, z + sideDelta.z + nested_z) then
                                            local features = getObjectFromGUID(tileGrid[x + sideDelta.x + nested_x][z + sideDelta.z + nested_z].tile_guid).getTable("specialFeatures")
                                            if features ~= nil then
                                                for _, feature in ipairs(features) do
                                                    local adjacentFeature = feature[1]
                                                    if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                    if adjacentFeature == challengedTile then
                                                        numChallenged = numChallenged + 1
                                                        for nested_nested_x=-1, 1 do
                                                            for nested_nested_z=-1, 1 do
                                                                if not (nested_nested_x == 0 and nested_nested_z == 0) and tileGridOccupied(x + sideDelta.x + nested_x + nested_nested_x, z + sideDelta.z + nested_z + nested_nested_z) then
                                                                    local features = getObjectFromGUID(tileGrid[x + sideDelta.x + nested_x + nested_nested_x][z + sideDelta.z + nested_z + nested_nested_z].tile_guid).getTable("specialFeatures")
                                                                    if features ~= nil then
                                                                        for _, nestedFeature in ipairs(features) do
                                                                            local nestedAdjacentFeature = nestedFeature[1]
                                                                            if nestedAdjacentFeature == 'Abbey' then nestedAdjacentFeature = 'Cloister' end
                                                                            if nestedAdjacentFeature == challengerTile then
                                                                                numChallenger = numChallenger + 1
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                                if numChallenged > 1 or numChallenger > 1 then
                                    tileMarkers[x + sideDelta.x][z + sideDelta.z] = false
                                end
                            end
                        end
                    end
                end
            end
        end
        local hasTileLocation = false
        for x, tileColumn in pairs(tileMarkers) do
            for z, tileLocation in pairs(tileColumn) do
                if tileLocation == true then
                    local params = {}
                    params.type = 'Custom_AssetBundle'

                    params.position = {(x * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.0, (z * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                    params.scale = {0.75, 1.2, 0.75}
                    params.callback_owner = Global
                    params.callback = "identifyFeature"
                    local newObject = spawnObject(params)
                    table.insert(featureMarkers, newObject)

                    local custom_params = {}
                    custom_params.assetbundle = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXZDBpTmotNmhRV00'
                    custom_params.type = 0
                    custom_params.material = 0
                    newObject.setCustomObject(custom_params)
                    hasTileLocation = true
                end
            end
        end
        if not hasTileLocation then
            allGameMessage("There is no valid location to put this tile. If the tile was drawn from the stack, put it back in and shuffle, then draw another.", NEUTRAL_COLOR)
        end
    end
end

--ensure this tile is valid for this location
function checkTile(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID ~= nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newTile = getObjectFromGUID(lastDroppedObject_GUID)
        if newTile ~= nil and newTile.held_by_color == nil then
            if newTile.getTable("sides") == nil then
                allErrorMessage("Error: This tile has no script data. Most likely this expansion hasn't yet been implemented.")
                return
            end
            local xPosition = (newTile.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
            local zPosition = (newTile.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
            local yRotation = newTile.getRotation().y / 90
            local zRotation = newTile.getRotation().z
            debugMessage(3, "piece rotation: " .. yRotation .. " piece position: x: " .. xPosition .. " z: " .. zPosition)
            if isWithinErrorMargin(xPosition, math.floor(xPosition + TILE_POSITION_MARGIN), TILE_POSITION_MARGIN) and
            isWithinErrorMargin(zPosition, math.floor(zPosition + TILE_POSITION_MARGIN), TILE_POSITION_MARGIN) and
            isWithinErrorMargin(yRotation, math.floor(yRotation + TILE_ROTATION_MARGIN), TILE_ROTATION_MARGIN) and
            --is tile flipped over?
            isWithinErrorMargin(0, math.floor(zRotation + TILE_ROTATION_MARGIN), TILE_ROTATION_MARGIN) then
                local xIndex = math.floor(xPosition + TILE_POSITION_MARGIN)
                local zIndex = math.floor(zPosition + TILE_POSITION_MARGIN)
                --by adding 0.5, getting the floor will round to the nearest whole number
                local tileRotation = math.floor(yRotation + 0.5)
                if tileRotation == 0 then tileRotation = 4 end
                debugMessage(2, "piece rotation: " .. tileRotation .. " piece indexes: x: " .. xIndex .. " z: " .. zIndex)
                local isStartingPiece = newTile.getVar("isStartingPiece")
                if (STARTING_TILE_GUID == nil and isStartingPiece) or
                tileGridOccupied(xIndex + 1, zIndex) or tileGridOccupied(xIndex - 1, zIndex) or
                tileGridOccupied(xIndex, zIndex + 1) or tileGridOccupied(xIndex, zIndex - 1) then
                    if not tileGridOccupied(xIndex, zIndex) then
                        if (STARTING_TILE_GUID == nil and isStartingPiece) or
                        ((not tileGridOccupied(xIndex + 1, zIndex) or tileConnectsToSide(newTile, tileRotation, 4, getObjectFromGUID(tileGrid[xIndex + 1][zIndex].tile_guid), tileGrid[xIndex + 1][zIndex].rotation)) and
                        (not tileGridOccupied(xIndex - 1, zIndex) or tileConnectsToSide(newTile, tileRotation, 2, getObjectFromGUID(tileGrid[xIndex - 1][zIndex].tile_guid), tileGrid[xIndex - 1][zIndex].rotation)) and
                        (not tileGridOccupied(xIndex, zIndex + 1) or tileConnectsToSide(newTile, tileRotation, 3, getObjectFromGUID(tileGrid[xIndex][zIndex + 1].tile_guid), tileGrid[xIndex][zIndex + 1].rotation)) and
                        (not tileGridOccupied(xIndex, zIndex - 1) or tileConnectsToSide(newTile, tileRotation, 1, getObjectFromGUID(tileGrid[xIndex][zIndex - 1].tile_guid), tileGrid[xIndex][zIndex - 1].rotation))) then
                            if newTile.getTable("sides")[1] == 'Abbey' and
                            ((not tileGridOccupied(xIndex + 1, zIndex)) or (not tileGridOccupied(xIndex - 1, zIndex)) or (not tileGridOccupied(xIndex, zIndex + 1)) or (not tileGridOccupied(xIndex, zIndex - 1))) then
                                allErrorMessage("Invalid Location: Abbey must be surrounded by tiles on all 4 sides", activePlayers[currentPlayer])
                                return
                            end
                            local challengerTile = nil
                            local challengedTile = nil
                            local features = newTile.getTable("specialFeatures")
                            if features ~= nil then
                                for _, feature in ipairs(features) do
                                    if feature[1] == 'Cloister' or feature[1] == 'Shrine' then challengerTile = feature[1] end
                                    if feature[1] == 'Abbey' then challengerTile = 'Cloister' end
                                end
                            end
                            if challengerTile ~= nil then
                                if challengerTile == 'Cloister' then
                                    challengedTile = 'Shrine'
                                else
                                    challengedTile = 'Cloister'
                                end
                                local numChallenger = 1
                                local numChallenged = 0
                                for x=-1, 1 do
                                    for z=-1, 1 do
                                        if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                            local features = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable("specialFeatures")
                                            if features ~= nil then
                                                for _, feature in ipairs(features) do
                                                    local adjacentFeature = feature[1]
                                                    if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                    if adjacentFeature == challengedTile then
                                                        numChallenged = numChallenged + 1
                                                        for nested_x=-1, 1 do
                                                            for nested_z=-1, 1 do
                                                                if not (nested_x == 0 and nested_z == 0) and tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
                                                                    local features = getObjectFromGUID(tileGrid[xIndex + x + nested_x][zIndex + z + nested_z].tile_guid).getTable("specialFeatures")
                                                                    if features ~= nil then
                                                                        for _, nestedFeature in ipairs(features) do
                                                                            local nestedAdjacentFeature = nestedFeature[1]
                                                                            if nestedAdjacentFeature == 'Abbey' then nestedAdjacentFeature = 'Cloister' end
                                                                            if nestedAdjacentFeature == challengerTile then
                                                                                numChallenger = numChallenger + 1
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                                if numChallenged > 1 or numChallenger > 1 then
                                    allErrorMessage("Invalid Location: Cannot place a tile such that more than one cloister is next to a shrine or vice versa.", activePlayers[currentPlayer])
                                    return
                                end
                            end
                            --validate river piece
                            if isStartingPiece then
                                local hasRiver = false
                                local riverHasConnection = false
                                for i=1, 4 do
                                    if newTile.getTable("sides")[(3 + i - tileRotation) % 4 + 1] == 'River' then
                                        hasRiver = true
                                        local diff = 0
                                        local x = xIndex
                                        local z = zIndex
                                        if i > 2 then diff = 1 else diff = -1 end
                                        if i % 2 == 0 then x = x + diff else z = z + diff end
                                        --if it has a river, then the following must be true for at least one of the sides
                                        if tileGridOccupied(x, z) and tileConnectsToSide(newTile, tileRotation, i, getObjectFromGUID(tileGrid[x][z].tile_guid), tileGrid[x][z].rotation) then
                                            riverHasConnection = true
                                            --the following checks to see if this tile would create a "U-turn" such that the river folds back on itself
                                            --this is illegal and can easily lead to issues
                                            --Though technically illegal, it is possible to still make a river that folds back on itself.
                                            --TODO: In the future, consider checking n number of tiles in the direction of the new rivers direction (with a width of 3 tiles) to see if there are any pieces in the way
                                            if ((newTile.getTable("sides")[(3 + i + 1 - tileRotation) % 4 + 1] == 'River' and getObjectFromGUID(tileGrid[x][z].tile_guid).getTable("sides")[(3 + i + 1 - tileGrid[x][z].rotation) % 4 + 1] == 'River') or
                                            (newTile.getTable("sides")[(3 + i + 3 - tileRotation) % 4 + 1] == 'River' and getObjectFromGUID(tileGrid[x][z].tile_guid).getTable("sides")[(3 + i + 3 - tileGrid[x][z].rotation) % 4 + 1] == 'River')) then
                                                allErrorMessage("Invalid Location: U-turns are not allowed on rivers", activePlayers[currentPlayer])
                                                return
                                            end
                                        end
                                    end
                                end
                                if STARTING_TILE_GUID ~= nil and hasRiver and not riverHasConnection then
                                    allErrorMessage("Invalid Location: Tile must continue the already placed river", activePlayers[currentPlayer])
                                    return
                                end
                            end
                            if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
                            tileGrid[xIndex][zIndex] = {}
                            tileGrid[xIndex][zIndex].tile_guid = newTile.getGUID()
                            tileGrid[xIndex][zIndex].rotation = tileRotation
                            lastPlacedTileX = xIndex
                            lastPlacedTileZ = zIndex

                            if AUTOLOCK then
                                newTile.lock()
                            end
                            if STARTING_TILE_GUID == nil and isStartingPiece then
                                STARTING_TILE_GUID = newTile.getGUID()
                            end
                            return nextState('tile placed')
                        else
                            allErrorMessage("Invalid Location: Adjacent tiles do not match", activePlayers[currentPlayer])
                        end
                    else
                        allErrorMessage("Invalid Location: Space already occupied by another tile", activePlayers[currentPlayer])
                    end
                else
                    allErrorMessage("Invalid Location: Must be adjacent to at least one tile", activePlayers[currentPlayer])
                end
            else
                allErrorMessage("Invalid Location: Tile not aligned with the grid", activePlayers[currentPlayer])
            end
        else
            allErrorMessage("Tile picked up before validation. Please replace tile", activePlayers[currentPlayer])
        end
    end
end

--tileConnectsToSide
-- params:
--  obj: tile 1
--  int: rotation 1 (rotation of the tile)
--  int: which side of the first tile is being checked
--  obj: tile 2
--  int: rotation 2
-- returns:
--  bool: true if they match
function tileConnectsToSide(t1, r1, n1, t2, r2)
    s1 = t1.getTable("sides")[(3 + n1 - r1) % 4 + 1]
    s2 = t2.getTable("sides")[(3 + n1 - r2 + TILE_180_ROTATION) % 4 + 1]
    debugMessage(2, "s1(" .. (3 + n1 - r1) % 4 + 1 .. "): " .. s1 .. " s2(" .. (3 + n1 - r2 + TILE_180_ROTATION) % 4 + 1 .. "): " .. s2)
    if s1 == 'Abbey' or s2 == 'Abbey' then return true end
    if s1 == s2 then return true else return false end
end

--tileGridOccupied
-- params:
--  int: x
--  int: z
-- returns:
--  bool: true if occupied
function tileGridOccupied(x, z)
    if tileGrid[x] == nil or tileGrid[x][z] == nil then return false else return true end
end

function checkTileForHill()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local features = newTile.getTable("specialFeatures")
    if features ~= nil then
        for _, specialFeature in ipairs(features) do
            if controlPanelSettings['HnSBuryHills'] and specialFeature[1] == "Hill" then
                local buriedTile_obj = nil
                if buriedTile == nil then
                    local drawPile = getObjectFromGUID(TILE_STACK_GUID)
                    if drawPile ~= nil then
                        local params = {}
                        params.position = {newTile.getPosition().x, newTile.getPosition().y + 1, newTile.getPosition().z}
                        buriedTile_obj = drawPile.takeObject(params)
                        buriedTile = buriedTile_obj.getGUID()
                    else
                        allErrorMessage("Warning: Hill drawn but draw pile not found.")
                        allErrorMessage("This could be because the draw pile has only 1 tile left or none.")
                        allErrorMessage("If there is 1 tile left, it must be manually placed underneath the hill")
                        return nextState('next')
                    end
                else
                    buriedTile_obj = getObjectFromGUID(buriedTile)
                end

                buriedTile_obj.interactable = false
                newTile.use_gravity = false
                newTile.interactable = false
                newTile.setPositionSmooth({newTile.getPosition().x, newTile.getPosition().y + 2, newTile.getPosition().z}, false, false)
                Timer.create({identifier=newTile.getGUID() .. os.clock(), function_name='freezeFloatingHillTile', function_owner=nil, parameters={tile=newTile, buriedTile=buriedTile_obj}, delay=0.8})
                return
            end
        end
    end
    return nextState('next')
end

--the next 3 functions use Timers to create a sequence to allow for a tile to be buried underneath

--locks the tile for a moment to wait for the tile to be buried
function freezeFloatingHillTile(param)
    local tile = param.tile
    local buriedTile = param.buriedTile
    tile.lock()
    Timer.create({identifier=tile.getGUID() .. os.clock(), function_name='unfreezeFloatingHillTile', function_owner=nil, parameters={tile=tile, buriedTile=buriedTile}, delay=0.5})
end

--unlock the tile and wait for it to fall back down
function unfreezeFloatingHillTile(param)
    local tile = param.tile
    local buriedTile = param.buriedTile
    tile.use_gravity = true
    tile.unlock()
    Timer.create({identifier=tile.getGUID() .. os.clock(), function_name='finishHillTile', function_owner=nil, parameters={tile=tile, buriedTile=buriedTile}, delay=0.8})
end

--lock the tile and other post tile actions
function finishHillTile(param)
    local tile = param.tile
    local buriedTile = param.buriedTile
    tile.interactable = true
    buriedTile.interactable = true
    if AUTOLOCK then
        buriedTile.lock()
        tile.lock()
    end
    if STARTING_TILE_GUID == nil and isStartingPiece then
        STARTING_TILE_GUID = tile.getGUID()
    end
    return nextState('next')
end

function checkTileForVolcano()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local features = newTile.getTable("specialFeatures")
    if features ~= nil then
        for _, specialFeature in ipairs(features) do
            if controlPanelSettings['PnDDragon'] and specialFeature[1] == "Volcano" then
                tileHasVolcano = true
                if not dragonHasAwaken then
                    dragonHasAwaken = true
                    gameNotification("The dragon has awaken!", NEUTRAL_COLOR, activePlayers[currentPlayer])
                end
                return moveDragonToTile(lastPlacedTileX, lastPlacedTileZ)
            end
        end
    end
    return nextState('next')
end

function checkTileForDragon()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local features = newTile.getTable("specialFeatures")
    if features ~= nil then
        for _, specialFeature in ipairs(features) do
            if controlPanelSettings['PnDDragon'] and specialFeature[1] == "Dragon" then
                if dragonHasAwaken then
                    dragonMoveNumber = 1
                    dragonIllegalTiles = {}
                    currentMiniTurn = currentPlayer
                    local fairy = getObjectFromGUID(expansionBags['PnD'].contents['PnDFairy'].guid)
                    local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
                    if controlPanelSettings['PnDFairy'] and fairy ~= nil then
                        local xIndex = math.floor((fairy.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                        local zIndex = math.floor((fairy.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                        if tileGridOccupied(xIndex, zIndex) then
                            table.insert(dragonIllegalTiles, {xIndex, zIndex})
                            getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).highlightOn({1,0,0})
                        end
                    end
                    if dragon ~= nil then
                        local xIndex = math.floor((dragon.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                        local zIndex = math.floor((dragon.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                        if tileGridOccupied(xIndex, zIndex) then
                            table.insert(dragonIllegalTiles, {xIndex, zIndex})
                            getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).highlightOn({1,0,0})
                        end
                    end
                    allGameMessage("The dragon is on the move!", NEUTRAL_COLOR)
                    return nextState('has dragon')
                else
                    allGameMessage("Dragon tile played, but the dragon has not yet awaken.", NEUTRAL_COLOR)
                end
            end
        end
    end
    return nextState('no dragon')
end

function createDragonButtons()
    local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
    local xIndex = math.floor((dragon.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local zIndex = math.floor((dragon.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local hasValidMove = false
    for i=1, 4 do
        local newX = xIndex + SIDE_DELTA[i].x
        local newZ = zIndex + SIDE_DELTA[i].z
        if tileGridOccupied(newX, newZ) and not table.contains(dragonIllegalTiles, {newX, newZ}) then
            hasValidMove = true
            local label
            if i == 1 then label = 'V'
            elseif i == 2 then label = '<'
            elseif i == 3 then label = '^'
            elseif i == 4 then label = '>'
            end
            local moveDragonButtonParam = {
               index = i, label = label, click_function = 'moveDragonButton',
               position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=0}, width = 1700, height=600, font_size = 200, function_owner = nil
            }
            createNormalizedButton(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), moveDragonButtonParam, false)
        end
    end

    if hasValidMove then
        allGameMessage("Dragon move # " .. dragonMoveNumber .. ". " .. activePlayers[currentMiniTurn] .. "'s turn to move.", stringColorToRGB(activePlayers[currentMiniTurn]), activePlayers[currentMiniTurn])
    else
        allGameMessage("Dragon has no valid places to move to. Ending dragon movement.", stringColorToRGB(activePlayers[currentMiniTurn]), activePlayers[currentMiniTurn])
        return nextState('next')
    end
end

function moveDragonButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
        local dragonXIndex = math.floor((dragon.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local dragonZIndex = math.floor((dragon.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        for i=1, 4 do
            local newX = dragonXIndex + SIDE_DELTA[i].x
            local newZ = dragonZIndex + SIDE_DELTA[i].z
            if tileGridOccupied(newX, newZ) then
                getObjectFromGUID(tileGrid[newX][newZ].tile_guid).clearButtons()
            end
        end

        local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        dragonMoveNumber = dragonMoveNumber + 1
        table.insert(dragonIllegalTiles, {xIndex, zIndex})
        getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).highlightOn({1,0,0})
        currentMiniTurn = currentMiniTurn + 1
        moveDragonToTile(xIndex, zIndex, rotation)
    end
end

function moveDragonToTile(xIndex, zIndex, rotation)
    local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
    local xDestination = (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x
    local zDestination = (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z

    local dragonTravelAngle = math.deg(math.atan2(dragon.getPosition().x - xDestination, dragon.getPosition().z - zDestination)) + 90
    if dragonTravelAngle > 360 then dragonTravelAngle = dragonTravelAngle - 360 end
    dragon.unlock()
    dragon.setRotationSmooth({0, dragonTravelAngle, 0})
    dragon.setPositionSmooth({xDestination, 1.5, zDestination})
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for _, object in ipairs(objs) do
        if object.getName() ~= 'Barn' and (table.contains(FOLLOWER_TYPES, object.getName()) or table.contains(SPECIAL_FIGURE_TYPES, object.getName()) or table.contains(SHEEP_TOKEN_TYPES, object.getName())) then
            if xIndex == math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
               zIndex == math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
               if table.contains(SHEEP_TOKEN_TYPES, object.getName()) then
                   local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
                   if sheepTileBag ~= nil then
                       allGameMessage(object.getDescription() .. " " .. object.getName() .. " eaten by the dragon! Om nom nom!", NEUTRAL_COLOR)
                       object.setPositionSmooth({sheepTileBag.getPosition().x, sheepTileBag.getPosition().y + 1.5, sheepTileBag.getPosition().z})
                       --coroutine.yield(0)
                   else
                       allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to return sheep tokens")
                   end
               else
                    --an assumption is made here that there won't be more than 1 figure on the same tile that the figures are dependent on.
                    --It is possible for more than 1 figure from the same player to be on the same tile through use of the magic portal, but not on the same feature.
                    --Therefore, I think the assumption is safe unless there is interference from the players
                    table.insert(removedFigures, {guid=object.getGUID(), winner=false})
                    allGameMessage(object.getDescription() .. " " .. object.getName() .. " has been eaten by the dragon! Om nom nom!", stringColorToRGB(object.getDescription()))
                    removeDependentFigures(object)
                end
            end
        end
    end
    if #removedFigures > 0 then
        returnFigures()
    else
        nextState('dragon moved')
    end
end

function checkTileForMagicPortal()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local features = newTile.getTable("specialFeatures")
    if controlPanelSettings['PnDMagicPortal'] and features ~= nil then
        for _, specialFeature in ipairs(features) do
            if specialFeature[1] == "Magic Portal" then
                tileHasMagicPortal = true
            end
        end
    end
    return nextState('next')
end

function checkTileForGold()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local features = newTile.getTable("specialFeatures")
    if controlPanelSettings['GoldminesGold'] and features ~= nil then
        for _, specialFeature in ipairs(features) do
            if specialFeature[1] == "Gold" then
                return nextState('has gold')
            end
        end
    end
    return nextState('next')
end

function addGoldToTile(xIndex, zIndex)
    local goldbag = getObjectFromGUID(expansionBags['Goldmines'].contents['GoldminesGold'].guid)
    if goldbag ~= nil then
        local xDestination = (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x
        local zDestination = (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z

        local params = {}
        params.position = {xDestination, 1.5, zDestination}
        goldbag.takeObject(params)
    else

    end
    nextState('next')
end

function displayGoldButtons()
    for x=-1, 1 do
        for z=-1, 1 do
            if not (x == 0 and z == 0) then
                local newX = lastPlacedTileX + x
                local newZ = lastPlacedTileZ + z
                if tileGridOccupied(newX, newZ) then
                    local placeGoldButtonParam = {
                       index = i, label = "Place\nGold", click_function = 'placeGoldButton',
                       position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=0}, width = 800, height=600, font_size = 200, function_owner = nil
                    }
                    createNormalizedButton(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), placeGoldButtonParam, false)
                end
            end
        end
    end
end

function placeGoldButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        for x=-1, 1 do
            for z=-1, 1 do
                if not (x == 0 and z == 0) then
                    local newX = lastPlacedTileX + x
                    local newZ = lastPlacedTileZ + z
                    if tileGridOccupied(newX, newZ) then
                        getObjectFromGUID(tileGrid[newX][newZ].tile_guid).clearButtons()
                    end
                end
            end
        end

        local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        addGoldToTile(xIndex, zIndex)
    end
end

--check for special actions to take when the latest tile has added to or finished a feature
function checkAddedTileFeatureExtensions()
    --check if the new tile has completed the biggest city/longest road and award token
    --Note: you might think that this transversal could be combined with the below transversal, but it didn't work out
    --due to the way that i coded transversedTileCoords. It's a long story, but basically I would have to loop through the entire
    --table for each position on every tile. Had I coded it as an indexable table, I wouldn't be able to use the # operator
    --in order to see how many elements it transversed. Perhaps there is a better solution, but I'm hoping this won't cause any huge performance hits
    local longestNewRoad = 0
    local largestNewCity = 0
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    if newTile.getTable("sides")[1] ~= 'Abbey' then
        local features = newTile.getTable("specialFeatures")
        for i=1, 12 do --roads and cities
            local hasPrincess = false
            if features ~= nil and i >= 5 and controlPanelSettings['PnDPrincess'] then
                for featureNum, specialFeature in ipairs(features) do
                    if controlPanelSettings['PnDPrincess'] and specialFeature[1] == "Princess" then
                        if table.contains(specialFeature[2], i) then
                            hasPrincess = true
                            table.remove(features, featureNum) --remove it so we only add it once
                        end
                    end
                end
            end
            if (i < 5 and controlPanelSettings['KnRBRobber'] and newTile.getTable("sides")[i] == 'Road') or (i >= 5 and (controlPanelSettings['KnRBKing'] or hasPrincess) and newTile.getTable("sides")[math.floor((i - 3) / 2)] == 'City') then
                if getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, true) then
                    --since there is a chance of the player breaking the new city or road record twice, wait until afterwards to award the token
                    if newTile.getTable("sides")[i] == 'Road' and #transversedTileCoords > longestNewRoad then
                        longestNewRoad = #transversedTileCoords
                    elseif newTile.getTable("sides")[math.floor((i - 3) / 2)] == 'City' and #transversedTileCoords > largestNewCity then
                        largestNewCity = #transversedTileCoords
                    end
                end
                if hasPrincess then
                    for _, follower in ipairs(transversedFollowers) do
                        table.insert(seducedKnights, follower.getGUID())
                    end
                end
            end
        end
    else --if an abbey was used, then we cannot simply transverse it's features like above in order to find completed features. instead, we transverse the surrounding features
        for i=1, 12 do --roads and cities
            local tile = newTile
            local rotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation
            if i < 5 and controlPanelSettings['KnRBRobber'] then
                local direction = (3 + i + rotation) % 4 + 1
                local newX = lastPlacedTileX + SIDE_DELTA[direction].x
                local newZ = lastPlacedTileZ + SIDE_DELTA[direction].z
                if tileGrid[newX] ~= nil then
                    if tileGrid[newX][newZ] ~= nil then
                        local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                        local newTileRotation = tileGrid[newX][newZ].rotation
                        local newTilePosition = (3 + i + rotation - newTileRotation + TILE_180_ROTATION) % 4 + 1
                        if getObjectFromGUID(tileGrid[newX][newZ].tile_guid).getTable("sides")[newTilePosition] == 'Road' then
                            if getFeatureComponents(newX, newZ, newTilePosition, 1, true) then
                                --since there is a chance of the player breaking the new city or road record twice, wait until afterwards to award the token
                                if #transversedTileCoords > longestNewRoad then
                                    longestNewRoad = #transversedTileCoords
                                end
                            end
                        end
                    end
                end
            elseif i >= 5 and controlPanelSettings['KnRBKing'] then
                local direction = (3 + i + (rotation * 2)) % 8 + 5
                local newX = lastPlacedTileX + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                local newZ = lastPlacedTileZ + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                if tileGrid[newX] ~= nil then
                    if tileGrid[newX][newZ] ~= nil then
                        local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                        local newTileRotation = tileGrid[newX][newZ].rotation
                        local newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (newTileRotation * 2) - 4) % 8 + 5
                        if getObjectFromGUID(tileGrid[newX][newZ].tile_guid).getTable("sides")[math.floor((newTilePosition - 3) / 2)] == 'City' then
                            if getFeatureComponents(newX, newZ, newTilePosition, 1, true) then
                                --since there is a chance of the player breaking the new city record twice, wait until afterwards to award the token
                                if #transversedTileCoords > largestNewCity then
                                    largestNewCity = #transversedTileCoords
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if controlPanelSettings['KnRBRobber'] and longestNewRoad > longestRoad then
        longestRoad = longestNewRoad
        local awardToken = getObjectFromGUID(expansionBags['KnRB'].contents['KnRBRobber'].guid)
        local x, z = rotateCoordinates(9.4, 0.0, PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].rotation)
        if awardToken ~= nil then
            awardToken.setPositionSmooth({PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].x + x, 2, PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].z + z})
            awardToken.setRotationSmooth({0,  PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].rotation * -90, 0})
            allGameMessage(activePlayers[currentPlayer] .. " has been awarded the Robber Baron token for completing the longest road (" .. longestRoad .. " tiles)", stringColorToRGB(activePlayers[currentPlayer]))
        else
            allErrorMessage("Error: Robber Baron token missing! The token needs to remain out in order to awarded")
        end
    end
    if controlPanelSettings['KnRBKing'] and largestNewCity > largestCity then
        largestCity = largestNewCity
        local awardToken = getObjectFromGUID(expansionBags['KnRB'].contents['KnRBKing'].guid)
        local x, z = rotateCoordinates(11.4, 0.0, PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].rotation)
        if awardToken ~= nil then
            awardToken.setPositionSmooth({PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].x + x, 2, PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].z + z})
            awardToken.setRotationSmooth({0,  PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].rotation * -90, 0})
            allGameMessage(activePlayers[currentPlayer] .. " has been awarded the King token for completing the biggest city (" .. largestCity .. " tiles)", stringColorToRGB(activePlayers[currentPlayer]))
        else
            allErrorMessage("Error: King token missing! The token needs to remain out in order to awarded")
        end
    end

    resetTransversal()
    local specialFeatures = {}

    --check for various completed features, as well as features that have been added to, including:
    --shepherds on fields, builders in cities or on roads, trade tokens in cities that were just completed
    --i can't think of any reason that special features (13+) would need to be checked (yet)

    --need to do cities first, otherwise fields will mark them as visited
    --the above is no longer true after I added transversal levels to getFeatureComponents. I'll leave the code as it is since it doesn't hurt
    for i=1, 12 do --roads and cities
        if newTile.getTable("sides")[1] ~= 'Abbey' then
            if (i < 5 and newTile.getTable("sides")[i] == 'Road') or (i >= 5 and newTile.getTable("sides")[math.floor((i - 3) / 2)] == 'City') then
                if getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, false) then
                    for _, transversedSpecialFeature in ipairs(transversedSpecialFeatures) do
                        table.insert(specialFeatures, transversedSpecialFeature)
                    end
                end
                transversedSpecialFeatures = {}
            end
        else
            for i=1, 12 do --roads and cities
                local tile = newTile
                local rotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation
                if i < 5 then
                    local direction = (3 + i + rotation) % 4 + 1
                    local newX = lastPlacedTileX + SIDE_DELTA[direction].x
                    local newZ = lastPlacedTileZ + SIDE_DELTA[direction].z
                    if tileGrid[newX] ~= nil then
                        if tileGrid[newX][newZ] ~= nil then
                            local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                            local newTileRotation = tileGrid[newX][newZ].rotation
                            local newTilePosition = (3 + i + rotation - newTileRotation + TILE_180_ROTATION) % 4 + 1

                            if getObjectFromGUID(tileGrid[newX][newZ].tile_guid).getTable("sides")[newTilePosition] == 'Road' then
                                if getFeatureComponents(newX, newZ, newTilePosition, 1, false) then
                                    for _, transversedSpecialFeature in ipairs(transversedSpecialFeatures) do
                                        table.insert(specialFeatures, transversedSpecialFeature)
                                    end
                                end
                                transversedSpecialFeatures = {}
                            end
                        end
                    end
                else
                    local direction = (3 + i + (rotation * 2)) % 8 + 5
                    local newX = lastPlacedTileX + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                    local newZ = lastPlacedTileZ + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                    if tileGrid[newX] ~= nil then
                        if tileGrid[newX][newZ] ~= nil then
                            local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                            local newTileRotation = tileGrid[newX][newZ].rotation
                            local newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (newTileRotation * 2) - 4) % 8 + 5
                            if getObjectFromGUID(tileGrid[newX][newZ].tile_guid).getTable("sides")[math.floor((newTilePosition - 3) / 2)] == 'City' then
                                if getFeatureComponents(newX, newZ, newTilePosition, 1, false) then
                                    for _, transversedSpecialFeature in ipairs(transversedSpecialFeatures) do
                                        table.insert(specialFeatures, transversedSpecialFeature)
                                    end
                                end
                                transversedSpecialFeatures = {}
                            end
                        end
                    end
                end
            end
        end
    end

    for i=5, 12 do --fields
        if newTile.getTable("sides")[math.floor((i - 3) / 2)] ~= 'City' then
            getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, false)
        end
    end

    transversedSpecialFeatures = {}  --just in case I try to use it

    getFigureComponents()
    if controlPanelSettings['TnBTradeGoods'] then
        for _, specialFeature in ipairs(specialFeatures) do
            local tradeGoodPile
            local x, z

            if specialFeature == 'Cloth Token' then
                tradeGoodPile = getObjectFromGUID(expansionBags['TnB'].contents['TnBClothTokenStack'].guid)
                x, z = rotateCoordinates(6.9, 0.5, PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].rotation)
            elseif specialFeature == 'Wine Token' then
                tradeGoodPile = getObjectFromGUID(expansionBags['TnB'].contents['TnBWineTokenStack'].guid)
                x, z = rotateCoordinates(6.9, -0.5, PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].rotation)
            elseif specialFeature == 'Wheat Token' then
                tradeGoodPile = getObjectFromGUID(expansionBags['TnB'].contents['TnBWheatTokenStack'].guid)
                x, z = rotateCoordinates(7.9, 0.5, PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].rotation)
            end

            if table.contains(TRADE_TOKEN_TYPES, specialFeature) then
                if tradeGoodPile ~= nil then
                    local params = {}
                    params.position = {PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].x + x, 2, PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].z + z}
                    params.rotation = {0,  PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].rotation * -90, 0}
                    tradeGoodPile.takeObject(params)
                    allGameMessage(activePlayers[currentPlayer] .. " has been awarded a " .. specialFeature .. " for completing the city", stringColorToRGB(activePlayers[currentPlayer]))
                else
                    allErrorMessage("Error: " .. specialFeature .. " pile missing! The pile needs to remain out in order to draw trade goods")
                end
            end
        end
    end
    for _, figure in ipairs(transversedSpecialFigures) do
        if activePlayers[currentPlayer] ~= nil and figure.getDescription() == activePlayers[currentPlayer] and
           newTile.getTable("sides")[1] ~= 'Abbey' then --do not give give sheep/extra builder tile (CAR 149)
            if figure.getName() == 'Shepherd' then
                shepherdAwaitingAction = figure.getGUID()
            elseif figure.getName() == 'Builder' and not hasAlreadyTakenBuilderTile then
                hasBuilderAwaitingAction = true
            end
        end
    end
    return nextState('next')
end

--events that should occur after placing a valid tile
function displayFigureButtons()
    local labelButtonParam = {
       index = 1, label = 'Place a figure\nOR', click_function = 'doNothing',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=3.5}, width = 0, height=0, font_size = 200, function_owner = nil
    }
    createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), labelButtonParam, true)
    local skipFigureButtonParam = {
       index = 2, label = 'Skip placing\nfigure', click_function = 'skipFigureButton',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=5.0}, width = 1700, height=600, font_size = 200, function_owner = nil
    }
    createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), skipFigureButtonParam, true)
    for _, knight in ipairs(seducedKnights) do
        local seduceKnightButtonParam = {
           index = 1, label = 'Seduce\nknight', click_function = 'seduceKnightButton',
           position = {x=0, y=3.0, z=2.0}, width = 1700, height=600, font_size = 200, function_owner = nil
        }
        createNormalizedButton(getObjectFromGUID(knight), seduceKnightButtonParam, true)
    end
    for _, obj in ipairs(getAllObjects()) do
        if obj.getName() == 'Abbot' and obj.getDescription() == activePlayers[currentPlayer] then
            local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            if tileGridOccupied(xIndex, zIndex) then
                local retrieveAbbotButtonParam = {
                   index = 1, label = 'Retrieve\nabbot', click_function = 'retrieveAbbotButton',
                   position = {x=0, y=3.0, z=2.0}, width = 1700, height=600, font_size = 200, function_owner = nil
                }
                createNormalizedButton(obj, retrieveAbbotButtonParam, true)
                currentPlayerAbbot = obj.getGUID()
                return --there shouldn't be multiple abbots for each player, but stop just in case
            end
        end
    end
end

--creates a button, which is rotated according to the object's current rotation, so that the buttons always face the active player
function createNormalizedButton(obj, param, rotateToPlayer)
    local player = activePlayers[currentPlayer]
    if currentMiniTurn ~= nil then
        player = activePlayers[currentMiniTurn]
    end
    if controlPanelSettings[player .. 'Hotseat'] ~= nil then
        player = controlPanelSettings[player .. 'Hotseat']
    end
    --default rotation is 180 degrees
    local playerRotation = 2
    if rotateToPlayer then
        playerRotation = PLAYER_POSSESSION_AREAS[player].rotation
    end

    local objRotation = math.floor((obj.getRotation().y + (TILE_ROTATION_MARGIN * 90)) / 90)
    local x, z
    x, z = rotateCoordinates(param.position.x, param.position.z, ((-playerRotation - objRotation + 7) % 4) + 1)
    param.position = {x, param.position.y, z}

    local rotation = (obj.getRotation().y * -1) - (playerRotation * 90)
    --this method is currently bugged(?)
    --local rotation = (obj.getRotation().y * -1) + (Player[player].getPointerRotation())
    if rotation < 0 then rotation = rotation + 360 end
    param.rotation = {0,  rotation, 0}
    obj.createButton(param)
end

--dummy function for dummy button
function doNothing()

end

function skipFigureButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        return nextState('skip figure')
    end
end

function seduceKnightButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        --although we later remove these buttons, there is a slight delay during the figure removal, so we remove them now
        getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
        if currentPlayerAbbot ~= nil then
            getObjectFromGUID(currentPlayerAbbot).clearButtons()
        end
        for _, knight in ipairs(seducedKnights) do
            getObjectFromGUID(knight).clearButtons()
        end

        table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        if object.getName() ~= 'Wagon' then
            allGameMessage(object.getDescription() .. " " .. object.getName() .. " has been seduced by the princess! bow chicka wow wow~", stringColorToRGB(object.getDescription()))
        else
            allGameMessage(object.getDescription() .. " " .. object.getName() .. " has been seduced by the princess! Well not the wagon but the wagon crew... all of them... wow. Let's move on and forget this.", stringColorToRGB(object.getDescription()))
        end
        removeDependentFigures(object)
        return nextState('seduce knight')
    end
end

function retrieveAbbotButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
            local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
            local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
            xPosition = xPosition - xIndex
            zPosition = zPosition - zIndex
            local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
            local rotation = tileGrid[xIndex][zIndex].rotation
            local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
            local nameOfFeature = getFeatureName(tile, closestFeature)
            getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)
            if nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbot' then
                score = #transversedTileCoords
                allGameMessage(object.getDescription() .. " retrieves their abbot back for " .. score .. " points on " .. nameOfFeature, stringColorToRGB(object.getDescription())) -- .. " with a strength of " .. value .. " followers", stringColorToRGB(player))
                scorePoints(object.getDescription(), nameOfFeature, score)
                table.insert(removedFigures, {guid=object.getGUID(), winner=true})
                object.unlock()
                object.use_gravity = false
                object.interactable = false
                --raise the follower in the air
                object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)
                Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
                if currentPlayerAbbot ~= nil then
                    getObjectFromGUID(currentPlayerAbbot).clearButtons()
                end
                for _, knight in ipairs(seducedKnights) do
                    getObjectFromGUID(knight).clearButtons()
                end
                return nextState('retrieve abbot')
            end
        end
    end
    allErrorMessage("Error: The abbot is currently on an invalid feature. Abbots can only be placed on gardens and cloisters.", activePlayers[currentPlayer])
end

--adds any special figures that were dependent on this figure to the removed figure list
function removeDependentFigures(object)
    local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
    local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
    xPosition = xPosition - xIndex
    zPosition = zPosition - zIndex
    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
    local rotation = tileGrid[xIndex][zIndex].rotation
    local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
    getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)
    local followersCount = 0
    for _, follower in ipairs(transversedFollowers) do
        if follower.getGUID() ~= object.getGUID() and follower.getDescription() == object.getDescription() then
            followersCount = followersCount + 1
        end
    end
    if followersCount == 0 then
        for _, figure in ipairs(transversedSpecialFigures) do
            if (figure.getName() == 'Pig' or figure.getName() == 'Builder') and figure.getDescription() == object.getDescription() then
                table.insert(removedFigures, {guid=figure.getGUID(), winner=false})
                allGameMessage(figure.getDescription() .. " no longer has a follower for their " .. figure.getName() .. " and must be removed.", stringColorToRGB(figure.getDescription()))
            end
        end
    end
end

function checkFigure(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID != nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
        if newFigure.held_by_color == nil then
            if not (lastPlacedTileX == nil or lastPlacedTileZ == nil) then
                local xIndex = math.floor((newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
                if controlPanelSettings['PnDDragon'] and dragon ~= nil and newFigure.getName() ~= 'Barn' and (table.contains(FOLLOWER_TYPES, newFigure.getName()) or table.contains(SPECIAL_FIGURE_TYPES, newFigure.getName())) then
                    if xIndex == math.floor((dragon.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
                       zIndex == math.floor((dragon.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
                        allErrorMessage("Invalid Location: Cannot place a figure on the tile containing the dragon.", activePlayers[currentPlayer])
                        return
                    end
                end
                if newFigure.getName() == 'Fairy' then
                    if tileGridOccupied(xIndex, zIndex) then
                        local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                        for _, follower in ipairs(objs) do
                            if follower.getDescription() == activePlayers[currentPlayer] and table.contains(FOLLOWER_TYPES, follower.getName()) then
                                if xIndex == math.floor((follower.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
                                 zIndex == math.floor((follower.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
                                    if AUTOLOCK then
                                       newFigure.lock()
                                    end
                                    return nextState('placed fairy')
                                end
                            end
                        end
                    end
                    allErrorMessage("Invalid Location: Fairy must be placed on a tile containing a follower owned by you.", activePlayers[currentPlayer])
                    return
                end
                local tile, rotation
                if tileGridOccupied(xIndex, zIndex) then
                    tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    rotation = tileGrid[xIndex][zIndex].rotation
                else
                    --allErrorMessage("Invalid Location: Figure was not placed on a tile", activePlayers[currentPlayer])
                    return
                end
                if (xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ) or (tileHasMagicPortal and table.contains(FOLLOWER_TYPES, newFigure.getName())) or newFigure.getName() == 'Barn' then
                    local xPosition = (newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local zPosition = (newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    debugMessage(3, "piece position: x: " .. xPosition .. " z: " .. zPosition)
                    local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
                    local nameOfFeature = getFeatureName(tile, closestFeature)
                    if nameOfFeature == 'River' then
                        allErrorMessage("Invalid Location: You can't occupy a river.", activePlayers[currentPlayer])
                        return
                    end
                    if nameOfFeature == 'Carcassonne' then
                        allErrorMessage("Invalid Location: The City of Carcassonne is not yet implemented.", activePlayers[currentPlayer])
                        return
                    end
                    if string.sub(nameOfFeature,1,6) == 'Flier-' then
                        if controlPanelSettings['FlierFlier'] then
                            if table.contains(FOLLOWER_TYPES, newFigure.getName()) then
                                flier = newFigure.getGUID()
                                if string.sub(nameOfFeature,7,7) == 'W' then flierDirection = 8 else flierDirection = 1 end --assumed to be Flier-NW if it is not Flier-W
                                flierDirection = flierDirection + ((rotation - TILE_STANDARD_ROTATION) * 2)
                                if flierDirection > 8 then flierDirection = flierDirection - 8 end
                                if flierDirection < 1 then flierDirection = flierDirection + 8 end
                                return nextState('placed flier')
                            else
                                allErrorMessage("Invalid Location: Only a follower can be placed on a flier.", activePlayers[currentPlayer])
                                return
                            end
                        else
                            allErrorMessage("The Flier was disabled in the control panel. You may not place anything on the flier.", activePlayers[currentPlayer])
                            return
                        end
                    end
                    if newFigure.getName() == 'Shepherd' and nameOfFeature ~= 'Field' then
                        allErrorMessage("Invalid Location: Shepherd can only be placed on fields.", activePlayers[currentPlayer])
                        return
                    end
                    if newFigure.getName() == 'Abbot' and not (nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey') then
                        allErrorMessage("Invalid Location: An abbot can only be placed on a garden or cloister.", activePlayers[currentPlayer])
                        return
                    end
                    if newFigure.getName() ~= 'Abbot' and nameOfFeature == 'Garden' then
                        allErrorMessage("Invalid Location: Only an abbot can be placed on a garden.", activePlayers[currentPlayer])
                        return
                    end
                    if newFigure.getName() == 'Builder' and nameOfFeature ~= 'Road' and nameOfFeature ~= 'City' then
                        allErrorMessage("Invalid Location: A builder can only be placed on roads and cities.", activePlayers[currentPlayer])
                        return
                    end
                    if newFigure.getName() == 'Pig' and nameOfFeature ~= 'Field' then
                        allErrorMessage("Invalid Location: A pig can only be placed on fields.", activePlayers[currentPlayer])
                        return
                    end
                    if newFigure.getName() == 'Mayor' and nameOfFeature ~= 'City' then
                        allErrorMessage("Invalid Location: A mayor can only occupy a city.", activePlayers[currentPlayer])
                        return
                    end
                    if newFigure.getName() == 'Wagon' and nameOfFeature == 'Field' then
                        allErrorMessage("Invalid Location: A wagon cannot occupy a field.", activePlayers[currentPlayer])
                        return
                    end
                    if newFigure.getName() == 'Barn' then
                        if nameOfFeature ~= 'Field' or not checkBarn(closestFeature, xIndex, zIndex) then
                            allErrorMessage("Invalid Location: A barn can only be placed on a corner of fields.", activePlayers[currentPlayer])
                            return
                        end
                    end
                    local finished
                    if closestFeature < 5 then
                        if nameOfFeature == 'Road' then
                            --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                            finished = getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
                        else
                            --check to make sure both octants in this quadrant are linked, then choose one arbitrary octant and check
                            local links = tile.getTable("linkedOctants")
                            local hasLink = false
                            for _, link in ipairs(links) do
                                if not hasLink and table.contains(link, (closestFeature * 2) + 3) and table.contains(link, (closestFeature * 2) + 4) then
                                    --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                                    finished = getFeatureComponents(xIndex, zIndex, (closestFeature * 2) + 3, 1, true)
                                    hasLink = true
                                end
                            end
                            if not hasLink then
                                allErrorMessage("Invalid Location: You must put the figure on one side of the feature or the other.", activePlayers[currentPlayer])
                                return
                            end
                        end
                    else
                        --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                        finished = getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
                    end
                    if finished and not (xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ) and newFigure.getName() ~= 'Barn' then
                        allErrorMessage("Invalid Location: You may not use the magic portal to place a follower on a completed feature.", activePlayers[currentPlayer])
                        return
                    end
                    local numFollowers = 0
                    local numCurrentPlayerFollowers = 0
                    local numShepherds = 0
                    local numBarns = 0
                    for _, follower in ipairs(transversedFollowers) do
                        if table.contains(FOLLOWER_TYPES, follower.getName()) then
                            numFollowers = numFollowers + 1
                            if follower.getDescription() == activePlayers[currentPlayer] then
                                numCurrentPlayerFollowers = numCurrentPlayerFollowers + 1
                            end
                        end
                    end
                    for _, figure in ipairs(transversedSpecialFigures) do
                        if figure.getName() == 'Shepherd' then
                            numShepherds = numShepherds + 1
                        end
                        if figure.getName() == 'Barn' then
                            numBarns = numBarns + 1
                        end
                    end
                    if newFigure.getName() == 'Builder' and numCurrentPlayerFollowers == 0 then
                        allErrorMessage("Invalid Location: A builder can only be placed on a road/city containing at least one of your followers.", activePlayers[currentPlayer])
                        return
                    end
                    if newFigure.getName() == 'Pig' and numCurrentPlayerFollowers == 0 then
                        allErrorMessage("Invalid Location: A pig can only be placed on a field containing at least one of your followers.", activePlayers[currentPlayer])
                        return
                    end
                    if (table.contains(FOLLOWER_TYPES, newFigure.getName()) and numFollowers == 1 and numBarns == 0) or
                        (newFigure.getName() == 'Shepherd' and numShepherds == 1) or
                        (newFigure.getName() == 'Barn' and numBarns == 1) or
                         newFigure.getName() == 'Builder' or newFigure.getName() == 'Pig' then
                        if AUTOLOCK then
                            newFigure.lock()
                        end
                        allGameMessage(newFigure.getDescription() .. " " .. newFigure.getName() .. " placed on " .. nameOfFeature, stringColorToRGB(newFigure.getDescription()))
                        if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' or nameOfFeature == 'Shrine' then
                            local challengerTile, challengedTile
                            if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                                challengerTile = 'Cloister'
                                challengedTile = 'Shrine'
                            else
                                challengerTile = 'Shrine'
                                challengedTile = 'Cloister'
                            end
                            for x=-1, 1 do
                                for z=-1, 1 do
                                    if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                        local features = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable("specialFeatures")
                                        if features ~= nil then
                                            for i, feature in ipairs(features) do
                                                local adjacentFeature = feature[1]
                                                if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                if adjacentFeature == challengedTile then
                                                    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                    for _, object in ipairs(objs) do
                                                        if table.contains(FOLLOWER_TYPES, object.getName()) then
                                                            local objectXIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                                            local objectZIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                                            if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                                local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                                                                local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                                                                xPosition = xPosition - objectXIndex
                                                                zPosition = zPosition - objectZIndex
                                                                local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), rotation)
                                                                if closestFeature == i + 12 then
                                                                    allGameMessage(object.getDescription() .. " " .. object.getName() .. " on " .. feature[1] .. " has been challenged!", stringColorToRGB(object.getDescription()))
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        local pieceRotation = 0
                        if closestFeature < 5 then pieceRotation = (closestFeature - 1) * 90
                        elseif closestFeature < 13 then pieceRotation = math.floor((closestFeature - 5) / 2) * 90 end
                        if (newFigure.getName() == 'Follower' or newFigure.getName() == 'Big Follower') and nameOfFeature == 'Field' then
                            --lay the Follower down
                            newFigure.setRotation({tile.getRotation().x + 90, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        else
                            --align with the tile
                            newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        end
                        if newFigure.getName() == 'Barn' then
                            newBarn = newFigure.getGUID()
                        end
                        if newFigure.getName() == 'Shepherd' then
                            shepherdAwaitingAction = newFigure.getGUID()
                            return nextState('placed shepherd')
                        else
                            return nextState('placed figure')
                        end
                    elseif (table.contains(FOLLOWER_TYPES, newFigure.getName()) and numFollowers == 0) or
                        (newFigure.getName() == 'Shepherd' and numShepherds == 0) or
                        (newFigure.getName() == 'Barn' and numBarns == 0) then
                        allErrorMessage("ERROR: Placed a " .. newFigure.getName() .. ", but no " .. newFigure.getName() .. " found. This should never happen. Tell the dev.")
                    else
                        allErrorMessage("Invalid Location: Feature already occupied.", activePlayers[currentPlayer])
                    end
                else
                    allErrorMessage("Invalid Location: You must place the figure on the tile you had just placed.", activePlayers[currentPlayer])
                end
            else
                allErrorMessage("You must place a tile before placing a figure.", activePlayers[currentPlayer])
            end
        else
            allErrorMessage("Follower picked up before validation. Please replace tile.", activePlayers[currentPlayer])
        end
    end
end

--checks if this position is on a corner or 4 tiles containing nothing but fields
--assumes that the given feature has already been checked and is a field
--returns true if it is, false otherwise
function checkBarn(closestFeature, xIndex, zIndex)
    tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
    rotation = tileGrid[xIndex][zIndex].rotation
    --NOTE: the following equation gives the other feature location on the same corner: ((closestFeature % 2) * -2) + 1 - 5) % 8 + 5
    if closestFeature > 12 or closestFeature < 5 then return false end
    local valid = false
    local includesLastTile = false
    if xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ then includesLastTile = true end
    local links = tile.getTable("linkedOctants")
    if links == nil then return false end
    for _, link in ipairs(links) do
        --check if both sides of the corner are linked together
        if table.contains(link, closestFeature) and table.contains(link, (closestFeature + ((closestFeature % 2) * -2) + 1 - 5) % 8 + 5) then
            -- go over both neighboring tiles
            for i, position in ipairs({closestFeature, (closestFeature + ((closestFeature % 2) * -2) + 1 - 5) % 8 + 5}) do
                local newTileDirection = (3 + position + (rotation * 2)) % 8 + 5
                local newX = xIndex + SIDE_DELTA[math.floor((newTileDirection - 3) / 2)].x
                local newZ = zIndex + SIDE_DELTA[math.floor((newTileDirection - 3) / 2)].z
                if newX == lastPlacedTileX and newZ == lastPlacedTileZ then includesLastTile = true end
                if tileGrid[newX] == nil or tileGrid[newX][newZ] == nil then return false end
                local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                local newTileRotation = tileGrid[newX][newZ].rotation
                local newTilePosition = (((newTileDirection % 2) * 2) + TILE_180_ROTATION + newTileDirection - (newTileRotation * 2) - 4) % 8 + 5
                if getFeatureName(newTile, newTilePosition) ~= 'Field' then return false end
                links = newTile.getTable("linkedOctants")
                if links == nil then return false end
                for _, link in ipairs(links) do
                    if table.contains(link, newTilePosition) and table.contains(link, (newTilePosition + ((newTilePosition % 2) * -2) + 1 - 5) % 8 + 5) then
                        local lastTileDirection = (3 + ((newTilePosition + ((newTilePosition % 2) * -2) + 1 - 5) % 8 + 5) + (newTileRotation * 2)) % 8 + 5
                        local lastX = newX + SIDE_DELTA[math.floor((lastTileDirection - 3) / 2)].x
                        local lastZ = newZ + SIDE_DELTA[math.floor((lastTileDirection - 3) / 2)].z
                        if lastX == lastPlacedTileX and lastZ == lastPlacedTileZ then includesLastTile = true end
                        if tileGrid[lastX] == nil or tileGrid[lastX][lastZ] == nil then return false end
                        local lastTile = getObjectFromGUID(tileGrid[lastX][lastZ].tile_guid)
                        local lastTileRotation = tileGrid[lastX][lastZ].rotation
                        local lastTilePosition = (((lastTileDirection % 2) * 2) + TILE_180_ROTATION + lastTileDirection - (lastTileRotation * 2) - 4) % 8 + 5
                        if getFeatureName(lastTile, lastTilePosition) ~= 'Field' then return false end
                        --only need to check the links once
                        if i == 2 then
                            --check if both sides of the corner are linked together
                            links = lastTile.getTable("linkedOctants")
                            if links == nil then return false end
                            for _, link in ipairs(links) do
                                if table.contains(link, lastTilePosition) and table.contains(link, (lastTilePosition + ((lastTilePosition % 2) * -2) + 1 - 5) % 8 + 5) then
                                    --if it managed to get to this point, then all conditions have been met
                                    valid = true
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if not includesLastTile then
        valid = false
    end
    return valid
end

function checkWagon(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID != nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
        if newFigure.getName() ~= 'Wagon' then
            allErrorMessage("Error: You are only allowed to place the wagon at this time.", activePlayers[currentPlayer])
            return
        end
        if newFigure.held_by_color == nil then
            if currentMiniTurn ~= nil then
                local xIndex = math.floor((newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                local xPosition = (newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local rotation = tileGrid[xIndex][zIndex].rotation
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    debugMessage(1, "wagon position: x: " .. xPosition .. " z: " .. zPosition)
                    local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
                    local nameOfFeature = getFeatureName(tile, closestFeature)
                    if nameOfFeature == 'River' then
                        allErrorMessage("Invalid Location: You can't occupy a river.", activePlayers[currentPlayer])
                        return
                    end
                    if nameOfFeature == 'Carcassonne' then
                        allErrorMessage("Invalid Location: The City of Carcassonne is not yet implemented.", activePlayers[currentPlayer])
                        return
                    end
                    if nameOfFeature == 'Field' then
                        allErrorMessage("Invalid Location: A wagon cannot occupy a field.", activePlayers[currentPlayer])
                        return
                    end
                    local finished
                    if closestFeature < 5 then
                        if nameOfFeature == 'Road' then
                            --need a transversal level of 2 in order to transverse road intersections
                            finished = getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)
                        else
                            --check to make sure both octants in this quadrant are linked, then choose one arbitrary octant and check
                            local links = tile.getTable("linkedOctants")
                            local hasLink = false
                            for _, link in ipairs(links) do
                                if not hasLink and table.contains(link, (closestFeature * 2) + 3) and table.contains(link, (closestFeature * 2) + 4) then
                                    --need a transversal level of 2 in order to transverse road intersections
                                    finished = getFeatureComponents(xIndex, zIndex, (closestFeature * 2) + 3, 2, true)
                                    hasLink = true
                                end
                            end
                            if not hasLink then
                                allErrorMessage("Invalid Location: You must put the wagon on one side of the feature or the other.", activePlayers[currentPlayer])
                                return
                            end
                        end
                    else
                        --need a transversal level of 2 in order to transverse road intersections
                        finished = getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)
                    end
                    if not finished then
                        local oldXIndex = math.floor((wagonLocations[activePlayers[currentMiniTurn]].x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                        local oldZIndex = math.floor((wagonLocations[activePlayers[currentMiniTurn]].z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                        local oldXPosition = (wagonLocations[activePlayers[currentMiniTurn]].x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                        local oldZPosition = (wagonLocations[activePlayers[currentMiniTurn]].z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                        oldXPosition = oldXPosition - oldXIndex
                        oldZPosition = oldZPosition - oldZIndex

                        if tileGrid[oldXIndex] == nil or tileGrid[oldXIndex][oldZIndex] == nil then
                            allErrorMessage("Error: previous tile is missing. It may have been removed.")
                            return
                        end
                        local oldTile = getObjectFromGUID(tileGrid[oldXIndex][oldZIndex].tile_guid)
                        local oldTileRotation = tileGrid[oldXIndex][oldZIndex].rotation
                        local oldPosition = findClosestFeature(oldXPosition, oldZPosition, oldTile, oldTileRotation)
                        debugMessage(2, "wagon old xIndex: " .. oldXIndex .. " zIndex: " .. oldZIndex .. " position: " .. oldPosition)
                        if transversedGrid[oldXIndex] ~= nil and transversedGrid[oldXIndex][oldZIndex] ~= nil and transversedGrid[oldXIndex][oldZIndex][oldPosition] ~= nil then
                            if #transversedFollowers == 1 then
                                if AUTOLOCK then
                                    newFigure.lock()
                                end
                                getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
                                allGameMessage(newFigure.getDescription() .. " " .. newFigure.getName() .. " placed on " .. nameOfFeature, stringColorToRGB(newFigure.getDescription()))
                                local pieceRotation = 0
                                if closestFeature < 5 then pieceRotation = (closestFeature - 1) * 90
                                elseif closestFeature < 13 then pieceRotation = math.floor((closestFeature - 5) / 2) * 90 end
                                newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                                wagonLocations[activePlayers[currentMiniTurn]] = nil
                                return replaceFinishedWagons()
                            elseif #transversedFollowers == 0 then
                                allErrorMessage("ERROR: Placed a " .. newFigure.getName() .. ", but no " .. newFigure.getName() .. " found. This should never happen. Tell the dev.")
                            else
                                allErrorMessage("Invalid Location: Feature already occupied.", activePlayers[currentPlayer])
                            end
                        else
                            allErrorMessage("Invalid Location: Not connected to the previous feature by road.", activePlayers[currentPlayer])
                        end
                    else
                        allErrorMessage("Invalid Location: Feature already finished. You must place the wagon in an incomplete feature", activePlayers[currentPlayer])
                    end
                else
                    allErrorMessage("Invalid Location: No tile found.", activePlayers[currentPlayer])
                end
            end
        else
            allErrorMessage("Follower picked up before validation. Please replace tile", activePlayers[currentPlayer])
        end
    end
end

function checkFlier(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID != nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        if flier == lastDroppedObject_GUID then
            local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
            if newFigure.held_by_color == nil then
                local xIndex = math.floor((newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)

                local tile, rotation
                if tileGridOccupied(xIndex, zIndex) then
                    tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    rotation = tileGrid[xIndex][zIndex].rotation
                else
                    --allErrorMessage("Invalid Location: Figure was not placed on a tile", activePlayers[currentPlayer])
                    return
                end

                if (xIndex == lastPlacedTileX + flierOffset.x and zIndex == lastPlacedTileZ + flierOffset.z) then
                    local xPosition = (newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local zPosition = (newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    debugMessage(3, "piece position: x: " .. xPosition .. " z: " .. zPosition)
                    local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
                    local nameOfFeature = getFeatureName(tile, closestFeature)

                    if newFigure.getName() == 'Abbot' and nameOfFeature ~= 'Garden' and nameOfFeature ~= 'Cloister' and nameOfFeature ~= 'Abbey' then
                        allErrorMessage("Invalid Location: An abbot can only be placed on a garden or cloister.", activePlayers[currentPlayer])
                        return
                    end
                    if newFigure.getName() == 'Mayor' and nameOfFeature ~= 'City' then
                        allErrorMessage("Invalid Location: A mayor can only occupy a city.", activePlayers[currentPlayer])
                        return
                    end
                    if nameOfFeature ~= 'City' and nameOfFeature ~= 'Road' and nameOfFeature ~= 'Cloister' then
                        allErrorMessage("Invalid Location: A flier can only be placed on a city, road, or cloister.", activePlayers[currentPlayer])
                        return
                    end
                    --local finished
                    if closestFeature < 5 then
                        if nameOfFeature == 'Road' then
                            --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                            finished = getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
                        else
                            --check to make sure both octants in this quadrant are linked, then choose one arbitrary octant and check
                            local links = tile.getTable("linkedOctants")
                            local hasLink = false
                            for _, link in ipairs(links) do
                                if not hasLink and table.contains(link, (closestFeature * 2) + 3) and table.contains(link, (closestFeature * 2) + 4) then
                                    --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                                    finished = getFeatureComponents(xIndex, zIndex, (closestFeature * 2) + 3, 1, true)
                                    hasLink = true
                                end
                            end
                            if not hasLink then
                                allErrorMessage("Invalid Location: You must put the flier on one side of the feature or the other.", activePlayers[currentPlayer])
                                return
                            end
                        end
                    else
                        --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                        finished = getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
                    end
                    if finished then
                        allErrorMessage("Invalid Location: You may only place the flier on an incomplete feature.", activePlayers[currentPlayer])
                        return
                    end
                    if AUTOLOCK then
                        newFigure.lock()
                    end
                    allGameMessage(newFigure.getDescription() .. " " .. newFigure.getName() .. " placed on " .. nameOfFeature, stringColorToRGB(newFigure.getDescription()))
                    if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' or nameOfFeature == 'Shrine' then
                        local challengerTile, challengedTile
                        if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                            challengerTile = 'Cloister'
                            challengedTile = 'Shrine'
                        else
                            challengerTile = 'Shrine'
                            challengedTile = 'Cloister'
                        end
                        for x=-1, 1 do
                            for z=-1, 1 do
                                if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                    local features = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable("specialFeatures")
                                    if features ~= nil then
                                        for i, feature in ipairs(features) do
                                            local adjacentFeature = feature[1]
                                            if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                            if adjacentFeature == challengedTile then
                                                local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                for _, object in ipairs(objs) do
                                                    if table.contains(FOLLOWER_TYPES, object.getName()) then
                                                        local objectXIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                                        local objectZIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                                        if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                            local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                                                            local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                                                            xPosition = xPosition - objectXIndex
                                                            zPosition = zPosition - objectZIndex
                                                            local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), rotation)
                                                            if closestFeature == i + 12 then
                                                                allGameMessage(object.getDescription() .. " " .. object.getName() .. " on " .. feature[1] .. " has been challenged!", stringColorToRGB(object.getDescription()))
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    local pieceRotation = 0
                    if closestFeature < 5 then pieceRotation = (closestFeature - 1) * 90
                    elseif closestFeature < 13 then pieceRotation = math.floor((closestFeature - 5) / 2) * 90 end
                    --align with the tile
                    newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                    return nextState('placed flier')
                else
                    allErrorMessage("Invalid Location: You must place the figure on the tile corresponding to the flier dice roll.", activePlayers[currentPlayer])
                end
            else
                allErrorMessage("Follower picked up before validation. Please replace tile.", activePlayers[currentPlayer])
            end
        else
            allErrorMessage("Can only place the follower that was used on the flier.", activePlayers[currentPlayer])
        end
    end
end

--will go through all possible locations on the field and find an empty spot where the sheep tile can be put
--Note: according to this forum post, this behavior actually violates the rules: https://boardgamegeek.com/thread/1434965/question-about-location-sheep-tokens
-- At first, I thought I could get around this by making the dragon not eat the sheep, but in the event that multiple fields are joined together, there needs to be a way to separate the different sheep groups
function addSheepToField(shepherd)
    --no error checking for the shepherd. Assume that it is still in a legal position
    local shepherdTileXIndex = math.floor((shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local shepherdTileZIndex = math.floor((shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local shepherdxPosition = (shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
    local shepherdzPosition = (shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
    shepherdxPosition = shepherdxPosition - shepherdTileXIndex
    shepherdzPosition = shepherdzPosition - shepherdTileZIndex
    local shepherdClosestFeature = findClosestFeature(shepherdxPosition, shepherdzPosition, getObjectFromGUID(tileGrid[shepherdTileXIndex][shepherdTileZIndex].tile_guid), tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation)
    getFeatureComponents(shepherdTileXIndex, shepherdTileZIndex, shepherdClosestFeature, 1, true)
    --now that we've transversed for this shepherd, check all positions in the field for an open spot
    for _, transversedTileCoord in ipairs(transversedTileCoords) do
        if transversedTileCoord ~= nil then
            if transversedFeaturePositions[transversedTileCoord.x] ~= nil and transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z] ~= nil then
                for location, transversedFeaturePosition in pairs(transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z]) do
                    if location > 4 and location < 13 and transversedFeaturePosition == 1 then
                        local occupied = false
                        debugMessage(1, "checking x: " .. transversedTileCoord.x .. " z: " .. transversedTileCoord.z .. " location: " .. location .. " for empty sheep location")
                        for _, figureSet in ipairs({transversedFollowers, transversedSheepTokens, transversedSpecialFigures}) do
                            for _, figure in ipairs(figureSet) do
                                local xIndex = math.floor((figure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                local zIndex = math.floor((figure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                if xIndex == transversedTileCoord.x and zIndex == transversedTileCoord.z then
                                    local xPosition = (figure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                                    local zPosition = (figure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                                    xPosition = xPosition - xIndex
                                    zPosition = zPosition - zIndex
                                    local x, z
                                    x, z = getFeatureLocation(location, getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid), tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation)
                                    if ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) < 0.1 then
                                        debugMessage(2, "Too close to sheep location (" .. ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) .. ")")
                                        occupied = true
                                        break
                                    end
                                end
                            end
                        end
                        if not occupied then
                            local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
                            if sheepTileBag ~= nil then
                                local params = {}
                                local x, z
                                x, z = getFeatureLocation(location, getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid), tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation)
                                params.position = {x=(x * TILE_SPACING) + (transversedTileCoord.x * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, y=1.5, z=(z * TILE_SPACING) + (transversedTileCoord.z * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}

                                local direction = (3 + location + (tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation * 2)) % 8 + 5
                                params.position.x = params.position.x - (SIDE_DELTA[math.floor((direction - 3) / 2)].x * 0.1 * TILE_SPACING)
                                params.position.z = params.position.z - (SIDE_DELTA[math.floor((direction - 3) / 2)].z * 0.1 * TILE_SPACING)

                                sheepTileBag.shuffle()
                                local newTile = sheepTileBag.takeObject(params)
                                if newTile.getName() == "Wolf" then
                                    Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='scoreFlock', function_owner=nil, parameters={shepherd=shepherd}, delay=2.5})
                                else
                                    Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=2.5})
                                end
                                return
                            else
                                allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to draw sheep tokens")
                                return
                            end
                        end
                    end
                end
            end
        end
    end
    gameNotification("No more room on field! Placing sheep on shepherd", NEUTRAL_COLOR, activePlayers[currentPlayer])
    addSheepToShepherd(shepherd)
end

--adds a sheep to the tile that the shepherd is on, if there is room
function addSheepToTile(shepherd)
    --no error checking for the shepherd. Assume that it is still in a legal position
    local shepherdTileXIndex = math.floor((shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local shepherdTileZIndex = math.floor((shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local tile = getObjectFromGUID(tileGrid[shepherdTileXIndex][shepherdTileZIndex].tile_guid)
    local rotation = tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation
    local shepherdxPosition = (shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
    local shepherdzPosition = (shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
    shepherdxPosition = shepherdxPosition - shepherdTileXIndex
    shepherdzPosition = shepherdzPosition - shepherdTileZIndex
    local shepherdClosestFeature = findClosestFeature(shepherdxPosition, shepherdzPosition, getObjectFromGUID(tileGrid[shepherdTileXIndex][shepherdTileZIndex].tile_guid), tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation)
    for _, linkedOctants in pairs(tile.getTable("linkedOctants")) do
        if table.contains(linkedOctants, shepherdClosestFeature) then
            for _, location in pairs(linkedOctants) do
                local x, z
                x, z = getFeatureLocation(location, tile, rotation)
                local occupied = false
                local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                for _, object in ipairs(objs) do
                    if table.contains(FOLLOWER_TYPES, object.getName()) or table.contains(SPECIAL_FIGURE_TYPES, object.getName()) or
                    table.contains(NEUTRAL_FIGURE_TYPES, object.getName()) or table.contains(SHEEP_TOKEN_TYPES, object.getName()) then
                        local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                        local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                        if xIndex == shepherdTileXIndex and zIndex == shepherdTileZIndex then
                            local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                            local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                            xPosition = xPosition - xIndex
                            zPosition = zPosition - zIndex
                            if ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) < 0.1 then
                                debugMessage(2, "Too close to sheep location (" .. ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) .. ")")
                                occupied = true
                                break
                            end
                        end
                    end
                end
                if not occupied then
                    local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
                    if sheepTileBag ~= nil then
                        local params = {}
                        params.position = {x=(x * TILE_SPACING) + (shepherdTileXIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, y=1.5, z=(z * TILE_SPACING) + (shepherdTileZIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}

                        local direction = (3 + location + (tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation * 2)) % 8 + 5
                        params.position.x = params.position.x - (SIDE_DELTA[math.floor((direction - 3) / 2)].x * 0.1 * TILE_SPACING)
                        params.position.z = params.position.z - (SIDE_DELTA[math.floor((direction - 3) / 2)].z * 0.1 * TILE_SPACING)

                        sheepTileBag.shuffle()
                        local newTile = sheepTileBag.takeObject(params)
                        if newTile.getName() == "Wolf" then
                            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='scoreFlock', function_owner=nil, parameters={shepherd=shepherd}, delay=2.5})
                        else
                            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=2.5})
                        end
                        return
                    else
                        allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to draw sheep tokens")
                        return
                    end
                end
            end
        end
    end
    gameNotification("No more room on field! Placing sheep on shepherd", NEUTRAL_COLOR, activePlayers[currentPlayer])
    addSheepToShepherd(shepherd)
end



--findClosestFeature
-- params:
--  int: x
--  int: z
--  obj: tile to check
--  int: rotation (1-4)
-- returns:
--  int: 1-4 for quadrants, 5-12 for octants, 13.. for additional features
function findClosestFeature(xPosition, zPosition, tile, rotation)
    xPosition, zPosition = rotateCoordinates(xPosition, zPosition, ((rotation + TILE_STANDARD_ROTATION - 1) % 4) + 1)

    local position = 1
    local closestFeature = 1
    local closestDistance = 999 --presumably every position should be closer than this

    for a = 0, 1 do -- a==0 is for quadrants, a==1 is for octants
        for side = 1, 4 do
            for j = 0, a do -- should do 1 loop for quadrants, 2 loops for octants
                x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, 5 - side)
                local distance = (xPosition - x) * (xPosition - x) + (zPosition - z) * (zPosition - z)
                debugMessage(3, "compare to position " .. position .. ": x: " .. x .. " z: " .. z .. " distance: " .. distance)
                if distance < closestDistance then
                    closestFeature = position
                    closestDistance = distance
                end
                position = position + 1
            end
        end
    end
    local features = tile.getTable("specialFeatures")
    if features ~= nil then
        --check for features with a position
        for _, feature in ipairs(features) do
            if feature[3] ~= nil then
                local distance = (xPosition - feature[3][1]) * (xPosition - feature[3][1]) + (zPosition - feature[3][2]) * (zPosition - feature[3][2])
                if distance < closestDistance then
                    closestFeature = position
                    closestDistance = distance
                end
            end
            position = position + 1
        end
    end
    return closestFeature
end

function promptShepherd()
    if shepherdAwaitingAction ~= nil then
        local shepherdExpandButtonParam = {
           index = 1, label = 'Expand the flock', click_function = 'addSheepToFlockButton',
           position = {x=0, y=3.0, z=3.5}, width = 1700, height=700, font_size = 200, function_owner = nil
        }
        local shepherdHerdButtonParam = {
           index = 2, label = 'Herd the flock\ninto the stable', click_function = 'scoreFlockButton',
           position = {x=0, y=3.0, z=5.0}, width = 1700, height=700, font_size = 200, function_owner = nil
        }
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        createNormalizedButton(shepherd, shepherdExpandButtonParam, true)
        createNormalizedButton(shepherd, shepherdHerdButtonParam, true)
        allGameMessage(activePlayers[currentPlayer] .. " added to their Shepherd's field and has an opportunity to expand their flock", stringColorToRGB(activePlayers[currentPlayer]), activePlayers[currentPlayer])
        return
    else
        return nextState('next')
    end
end

function addSheepToFlockButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        shepherd.clearButtons()
        if controlPanelSettings['PnDDragon'] then
            addSheepToTile(shepherd)
        else
            addSheepToField(shepherd)
        end
    end
end

function addSheepToShepherd(shepherd)
    local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
    if sheepTileBag ~= nil then
        local params = {}
        params.position = {shepherd.getPosition().x, shepherd.getPosition().y + 2, shepherd.getPosition().z}
        sheepTileBag.shuffle()
        local newTile = sheepTileBag.takeObject(params)
        if newTile.getName() == "Wolf" then
            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='scoreFlock', function_owner=nil, parameters={shepherd=shepherd}, delay=2.5})
        else
            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=2.5})
        end
    else
        allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to draw sheep tokens")
    end
end

function scoreFlockButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        shepherd.clearButtons()
        local params = {}
        params.shepherd = shepherd
        scoreFlock(params)
    end
end

function scoreFlock(params)
    shepherd = params.shepherd
    --startLuaCoroutine(self, 'scoreFlockCoroutine')

    local CoNew = coroutine.create(scoreFlockCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

function scoreFlockCoroutine()
    local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
    if sheepTileBag ~= nil then
        local xIndex = math.floor((shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        local xPosition = (shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
        local zPosition = (shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
        xPosition = xPosition - xIndex
        zPosition = zPosition - zIndex
        local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation)
        --only need a transversal level of 1, since we don't care about completed cities on the field
        getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
        local score = 0
        local hasWolf = false

        for _, token in ipairs(transversedSheepTokens) do
            if token.getName() == 'Sheep' then
                score = score + token.getDescription()
            elseif token.getName() == 'Wolf' then
                hasWolf = true
            end
            token.setPositionSmooth({sheepTileBag.getPosition().x, sheepTileBag.getPosition().y + 1.5, sheepTileBag.getPosition().z})
            coroutine.yield(0)
        end
        for _, feature in ipairs(transversedSpecialFeatures) do
            if feature == 'Sheep' then
                score = score + 1
                break
            end
        end
        if hasWolf then score = 0 end
        for _, figure in ipairs(transversedSpecialFigures) do
            if figure.getName() == 'Shepherd' then
                local winner
                if score > 0 then winner = true else winner = false end
                table.insert(removedFigures, {guid=figure.getGUID(), winner=winner})
                if not hasWolf then
                    allGameMessage(figure.getDescription() .. "'s Shepherd scores " .. score .. " points for " .. score .. " sheep.", stringColorToRGB(figure.getDescription()))
                else
                    allGameMessage(figure.getDescription() .. "'s Shepherd loses all of its sheep to a wolf. No points scored.", stringColorToRGB(figure.getDescription()))
                end
                scorePoints(figure.getDescription(), 'Shepherd', score)
                figure.unlock()
                figure.use_gravity = false
                figure.interactable = false
                --raise the figure in the air
                figure.setPositionSmooth({figure.getPosition().x, figure.getPosition().y + 2.5, figure.getPosition().z}, false, false)
            end
        end
        Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='praiseShepherd', function_owner=nil, parameters=nil, delay=0.9})
    else
        allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to return sheep tokens")
        nextState('next')
    end
    return 1
end

function praiseShepherd()
    --startLuaCoroutine(self, 'praiseFiguresCoroutine')

    local CoNew = coroutine.create(praiseShepherdCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--makes the winning shepherds spin and marks the features that were scored
function praiseShepherdCoroutine()
    for _, figure in ipairs(removedFigures) do
        if figure.winner then
            getObjectFromGUID(figure.guid).addTorque({0,25,0}, 4)
        end
    end
    if showMarkers == 'Scoring' or showMarkers == 'Both' then
        for _, transversedTileCoord in ipairs(transversedTileCoords) do
            if transversedTileCoord ~= nil then
                if transversedFeaturePositions[transversedTileCoord.x] ~= nil and transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z] ~= nil then
                    for position, transversedFeaturePosition in pairs(transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z]) do
                        if position < 13 or getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid).getTable("specialFeatures")[position - 12][3] ~= nil then
                            local x = nil
                            local z = nil
                            local tile = getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid)
                            local rotation = tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation
                            x, z = getFeatureLocation(position, tile, rotation)
                            if x ~= nil and z ~= nil then
                                local params = {}
                                if transversedFeaturePosition == 1 then
                                    params.type = "BlockSquare"
                                end
                                params.position = {(x * TILE_SPACING) + (transversedTileCoord.x * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (transversedTileCoord.z * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                                params.scale = {0.25, 0.25, 0.25}
                                params.callback = "identifyFeature"
                                local newObject = spawnObject(params)
                                table.insert(featureMarkers, newObject)
                            end
                        end
                    end
                    coroutine.yield(0)
                end
            end
        end
    end
    Timer.create({identifier=os.clock(), function_name='returnShepherds', function_owner=nil, parameters=nil, delay=FIGURE_PRAISE_DELAY})
    return 1
end

function returnShepherds()
    --startLuaCoroutine(self, 'returnShepherdsCoroutine')

    local CoNew = coroutine.create(returnShepherdsCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--send figures back to the player supply area (assuming that's where they were when the game started)
function returnShepherdsCoroutine()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        figure_obj.use_gravity = true
        figure_obj.interactable = true
        local found_home = false
        if figurePositions[figure_obj.getDescription()] ~= nil and figurePositions[figure_obj.getDescription()][figure_obj.getName()] then
            for i, figure_GUID in ipairs(figurePositions[figure_obj.getDescription()][figure_obj.getName()]) do
                if figure_GUID == figure_obj.getGUID() then
                    local figurePad = getObjectFromGUID(FIGUREPAD_GUIDs[figure_obj.getDescription()])
                    local figureSetting = nil
                    for _, temp_figureSetting in pairs(figureSettings) do
                        if figure_obj.getName() == temp_figureSetting.name then
                            figureSetting = temp_figureSetting
                            break
                        end
                    end
                    if figureSetting ~= nil then
                        local x, z = rotateCoordinatesDegrees(figureSetting.offset.x + (((i - 1) % 4) * -1.45), figureSetting.offset.z + (math.floor((i - 1) / 4) * 1.0), -figurePad.getRotation().y)
                        figure_obj.unlock()
                        figure_obj.setPositionSmooth({x = figurePad.getPosition().x + x, y = figurePad.getPosition().y + 1, z = figurePad.getPosition().z + z}, false, false)
                        figure_obj.setRotationSmooth({x=0, y=figurePad.getRotation().y, z=0})
                        found_home = true
                    else
                        allErrorMessage("Warning: " .. figure_obj.getName() .. " missing from figure settings", activePlayers[currentPlayer])
                    end
                end
            end
        end
        if found_home == false then
            allErrorMessage("Warning: " .. figure_obj.getName() .. " doesn't have a home and must be returned manually", activePlayers[currentPlayer])
        end
        coroutine.yield(0)
    end
    removedFigures = {}

    nextState('next')
    return 1
end

function checkFlierDestination()
    if tileGridOccupied(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z) then
        resetTransversal()
        local destinationTile = getObjectFromGUID(tileGrid[lastPlacedTileX + flierOffset.x][lastPlacedTileZ + flierOffset.z].tile_guid)
        local hasIncompleteFeature = false
        for i=1, 12 do
            if getFeatureName(destinationTile, i) == 'City' or getFeatureName(destinationTile, i) == 'Road' then --fields are not valid destinations
                if getObjectFromGUID(flier).getName() ~= 'Mayor' or getFeatureName(destinationTile, i) == 'City' then
                    if not getFeatureComponents(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z, i, 1, false) then
                        hasIncompleteFeature = true
                    end
                end
            end
        end
        local features = destinationTile.getTable("specialFeatures")
        for j, feature in pairs(features) do
            if (feature[1] == 'Cloister' or feature[1] == 'Abbey') and getObjectFromGUID(flier).getName() ~= 'Mayor' then
                if not getFeatureComponents(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z, j + 12, 1, false) then
                    hasIncompleteFeature = true
                end
            end
            if feature[1] == 'Garden' and getObjectFromGUID(flier).getName() == 'Abbot' then
                if not getFeatureComponents(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z, j + 12, 1, false) then
                    hasIncompleteFeature = true
                end
            end
        end
        if hasIncompleteFeature then
            return nextState('feature available')
        else
            allGameMessage("The destination tile has no incomplete features. Returning follower.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        end
    else
        allGameMessage("No tile exists at flier destination. Returning follower.", NEUTRAL_COLOR, activePlayers[currentPlayer])
    end

    table.insert(removedFigures, {guid=flier, winner=false})
    return nextState('feature unavailable')
end

function scoreFeatures()
    scoring = true
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for i, figureTypes in ipairs({FOLLOWER_TYPES, SPECIAL_FIGURE_TYPES}) do
        for _, obj in ipairs(objs) do
            if table.contains(figureTypes, obj.getName()) and not (i == 2 and (not gameover or obj.getName() ~= 'Barn')) then
                if not table.contains(followersScored, obj) then
                    local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                    local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                    debugMessage(1, "Checking " .. obj.getDescription() .. " " .. obj.getName() .. " for finished features at index: x: " .. xIndex .. " z: " .. zIndex)
                    if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                        local xPosition = (obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                        local zPosition = (obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                        xPosition = xPosition - xIndex
                        zPosition = zPosition - zIndex
                        local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                        local rotation = tileGrid[xIndex][zIndex].rotation
                        local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
                        local nameOfFeature = getFeatureName(tile, closestFeature)
                        --this hack will tell if there is a place to put the wagon if the feature had been completed
                        hasIncompleteSecondaryFeature = false
                        debugMessage(2, "figure closest feature: index: x: " .. xIndex .. " z: " .. zIndex .. " position: " .. closestFeature .. " name: " .. nameOfFeature)
                        local featureComplete = getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)

                        local followerCounts = {}
                        local hasPig = {}
                        local hasHill = {}
                        local hasMayor = {}
                        local hasBarn = false
                        local hasNewBarn = false
                        local topWeight = -1
                        --find the relative weights for the followers on this feature
                        for _, follower in ipairs(transversedFollowers) do
                            local weight = 0
                            if follower.getName() == 'Follower' or follower.getName() == 'Wagon' or follower.getName() == 'Abbot' then weight = 1
                            elseif follower.getName() == 'Big Follower' then weight = 2
                            elseif follower.getName() == 'Mayor' then
                                for _, specialFeature in ipairs(transversedSpecialFeatures) do
                                    if specialFeature == 'Coat of Arms' then weight = weight + 1 end
                                end
                                hasMayor[follower.getDescription()] = true
                            end
                            if weight > 0 then
                                local followerXIndex = math.floor((follower.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                local followerZIndex = math.floor((follower.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                local specialFeatures = getObjectFromGUID(tileGrid[followerXIndex][followerZIndex].tile_guid).getTable("specialFeatures")
                                if controlPanelSettings['HnSHills'] and specialFeatures ~= nil then
                                    for _, specialFeature in ipairs(specialFeatures) do
                                        if specialFeature[1] == "Hill" then
                                            --although it would have been easier to just add 0.001 to the weight here, it would have technically violated the rules, since multiple hills are not supposed to give extra weight.
                                            hasHill[follower.getDescription()] = true
                                        end
                                    end
                                end
                            end
                            if followerCounts[follower.getDescription()] == nil then
                                followerCounts[follower.getDescription()] = weight
                            else
                                followerCounts[follower.getDescription()] = followerCounts[follower.getDescription()] + weight
                            end
                        end
                        --add hill weight if there is a hill, find top weight for the feature
                        for player, value in pairs(followerCounts) do
                            if hasHill[player] then
                                --if the follower is on a hill, add a small value to it to break any ties
                                followerCounts[player] = followerCounts[player] + 0.001
                            end
                            if followerCounts[player] > topWeight then topWeight = followerCounts[player] end
                        end

                        for _, figure in ipairs(transversedSpecialFigures) do
                            if figure.getName() == 'Pig' then hasPig[figure.getDescription()] = true end
                            if figure.getName() == 'Barn' then
                                hasBarn = true
                                if newBarn ~= nil and figure.getGUID() == newBarn then
                                    hasNewBarn = true
                                    newBarn = nil
                                end
                                --recalculate "follower count" with only barns. Technically they aren't followers but it was easier in code.
                                if #transversedFollowers == 0 then
                                    if followerCounts[figure.getDescription()] == nil then
                                        followerCounts[figure.getDescription()] = 1
                                    else
                                        followerCounts[figure.getDescription()] = followerCounts[figure.getDescription()] + 1
                                    end
                                    if followerCounts[figure.getDescription()] > topWeight then topWeight = followerCounts[figure.getDescription()] end
                                end
                            end
                        end
                        if #transversedFollowers == 0 and not hasBarn then
                            allErrorMessage("ERROR: no followers found. This should never happen. Tell the dev.")
                            return
                        end
                        local score = 0
                        local containsPigHerd = false
                        if nameOfFeature == 'City' then
                            score = #transversedTileCoords
                            local containsCathedral = false
                            for _, feature in ipairs(transversedSpecialFeatures) do
                                if feature == 'Coat of Arms' then
                                    score = score + 1
                                end
                                if feature == 'Cathedral' then
                                    containsCathedral = true
                                end
                            end
                            if containsCathedral then
                                if featureComplete then
                                    score = score * 3
                                else
                                    score = 0
                                end
                            else
                                if featureComplete then
                                    score = score * 2
                                end
                            end
                            --do not nerf cities that were completed by an abbey, or incomplete cities
                            if lastPlacedTileX ~= nil and getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).getTable("sides")[1] ~= 'Abbey' and
                               featureComplete and controlPanelSettings['BaseNerfSmallCity'] and score == 4 then score = 2 end
                        elseif nameOfFeature == 'Field' then
                            for _, feature in ipairs(transversedSpecialFeatures) do
                                if feature == 'Completed City' then
                                    score = score + 1
                                end
                                if feature == 'Pig-herd' then
                                    containsPigHerd = true
                                end
                            end
                            featureComplete = false --so that this feature won't be scored before the end of the game
                        elseif nameOfFeature == 'Road' then
                            score = #transversedTileCoords
                            local containsInn = false
                            for _, feature in ipairs(transversedSpecialFeatures) do
                                if feature == 'Inn' then
                                    containsInn = true
                                end
                            end
                            if containsInn then
                                if featureComplete then
                                    score = score * 2
                                else
                                    score = 0
                                end
                            end
                        elseif nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' or nameOfFeature == 'Shrine' then
                            score = #transversedTileCoords
                            if featureComplete and controlPanelSettings['HnSVineyards'] then
                                for _, feature in ipairs(transversedSpecialFeatures) do
                                    if feature == 'Vineyard' then
                                        score = score + 3
                                    end
                                end
                            end
                            if featureComplete then
                                local challengerTile, challengedTile
                                if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                                    challengerTile = 'Cloister'
                                    challengedTile = 'Shrine'
                                else
                                    challengerTile = 'Shrine'
                                    challengedTile = 'Cloister'
                                end
                                for x=-1, 1 do
                                    for z=-1, 1 do
                                        if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                            local features = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable("specialFeatures")
                                            if features ~= nil then
                                                for i, feature in ipairs(features) do
                                                    local adjacentFeature = feature[1]
                                                    if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                    if adjacentFeature == challengedTile then
                                                        local numTiles = 0
                                                        for nested_x=-1, 1 do
                                                            for nested_z=-1, 1 do
                                                                if tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
                                                                    numTiles = numTiles + 1
                                                                end
                                                            end
                                                        end
                                                        if numTiles ~= 9 then
                                                            local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                            for _, object in ipairs(objs) do
                                                                if table.contains(FOLLOWER_TYPES, object.getName()) then
                                                                    local objectXIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                                                    local objectZIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                                                    if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                        				local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                                                        				local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                                                        				xPosition = xPosition - objectXIndex
                                                        				zPosition = zPosition - objectZIndex
                                                        				local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), rotation)
                                                                        if closestFeature == i + 12 then
                                                                            object.unlock()
                                                                            object.use_gravity = false
                                                                            object.interactable = false
                                                                            --raise the follower in the air
                                                                            object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)
                                                                            table.insert(removedFigures, {guid=object.getGUID(), winner=false})
                                                                            allGameMessage(object.getDescription() .. " " .. object.getName() .. " has lost the Cloister/Shrine challenge.", stringColorToRGB(object.getDescription()))
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        elseif nameOfFeature == "Baba Yaga's Hut" then
                            score = 10 - #transversedTileCoords
                            --unclear if vineyards should be counted. Leaving out for now
                        elseif nameOfFeature == "Garden" then
                            score = #transversedTileCoords
                        end
                        for player, value in pairs(followerCounts) do
                            if nameOfFeature ~= 'Carcassonne' then --FIXME: need a better permanent solution
                            if gameover or featureComplete or (nameOfFeature == 'Field' and hasBarn and #transversedFollowers > 0) or (gameover and hasBarn and #transversedFollowers == 0) then
                                if (topWeight > 0 and value >= topWeight) then
                                    playerScore = score
                                    if nameOfFeature == 'Field' then
                                        local scoreMultiplier = 3
                                        if hasBarn then
                                            if #transversedFollowers > 0 then
                                                if not hasNewBarn then
                                                    scoreMultiplier = 1
                                                end
                                            else
                                                scoreMultiplier = 4
                                            end
                                        end
                                        if hasPig[player] ~= nil then
                                            scoreMultiplier = scoreMultiplier + 1
                                        end
                                        if containsPigHerd and #transversedFollowers > 0 then -- CAR pg 67 ref 194
                                            scoreMultiplier = scoreMultiplier + 1
                                        end
                                        playerScore = score * scoreMultiplier
                                    end
                                    allGameMessage(player .. " scores " .. playerScore .. " points on " .. nameOfFeature, stringColorToRGB(player)) -- .. " with a strength of " .. value .. " followers", stringColorToRGB(player))
                                    scorePoints(player, nameOfFeature, playerScore)
                                elseif value > 0 then
                                    --allGameMessage(player .. " did not score any points with a strength of only " .. value .. " followers", stringColorToRGB(player))
                                elseif topWeight == 0 and hasMayor[player] then
                                    allGameMessage(player .. " scores 0 points on " .. nameOfFeature .. ". A mayor can only score points if the city contains a coat of arms!", stringColorToRGB(player))
                                end
                            end
                            end
                        end
                        for _, follower in ipairs(transversedFollowers) do
                            if not table.contains(followersScored, follower) then
                                table.insert(followersScored, follower)
                            end
                        end
                        if gameover and #transversedFollowers == 0 then
                            for _, figure in ipairs(transversedSpecialFigures) do
                                if not table.contains(followersScored, figure) and figure.getName() == 'Barn' then
                                    table.insert(followersScored, figure)
                                end
                            end
                        end
                        if nameOfFeature ~= 'Carcassonne' then --FIXME: need a better permanent solution
                        if gameover or featureComplete or (nameOfFeature == 'Field' and hasBarn) then
                            for _, follower in ipairs(transversedFollowers) do
                                local closestFollower = fairyClosestFollower()
                                if closestFollower == follower then
                                    allGameMessage(closestFollower.getDescription() .. " " .. closestFollower.getName() .. " scores 3 points for being next to the fairy when scoring a feature.", stringColorToRGB(closestFollower.getDescription()))
                                    scorePoints(closestFollower.getDescription(), 'Fairy', 3)
                                end
                                if follower.getName() == "Wagon" then
                                    wagonLocations[follower.getDescription()] = {}
                                    wagonLocations[follower.getDescription()].x = follower.getPosition().x
                                    wagonLocations[follower.getDescription()].z = follower.getPosition().z
                                    hasAvailableWagonFeature[follower.getDescription()] = hasIncompleteSecondaryFeature
                                end
                                local winner = false
                                if topWeight > 0 and followerCounts[follower.getDescription()] >= topWeight and score > 0 then winner = true end
                                if winner and nameOfFeature ~= 'Field' and #transversedGoldBars > 0 then
                                    if scoringRewards['Gold'] == nil then scoringRewards['Gold'] = {} end
                                    for _, gold in ipairs(transversedGoldBars) do
                                        if scoringRewards['Gold'][gold.getGUID()] == nil then scoringRewards['Gold'][gold.getGUID()] = {} end
                                        if not table.contains(scoringRewards['Gold'][gold.getGUID()], follower.getDescription()) then
                                            table.insert(scoringRewards['Gold'][gold.getGUID()], follower.getDescription())
                                        end
                                    end
                                end
                                table.insert(removedFigures, {guid=follower.getGUID(), winner=winner})
                                follower.unlock()
                                follower.use_gravity = false
                                follower.interactable = false
                                --raise the follower in the air
                                follower.setPositionSmooth({follower.getPosition().x, follower.getPosition().y + 2.5, follower.getPosition().z}, false, false)
                            end
                            for _, figure in ipairs(transversedSpecialFigures) do
                                --shepherds are never removed outside of a flock collection
                                --barns should only be scored at the end of the game, after all followers have been scored
                                if figure.getName() ~= 'Shepherd' and (figure.getName() ~= 'Barn' or (figure.getName() == 'Barn' and #transversedFollowers == 0 and gameover)) then
                                    local winner = false
                                    --builder not involved in scoring, so shouldn't be praised
                                    if figure.getName() ~= 'Builder' and topWeight > 0 and followerCounts[figure.getDescription()] >= topWeight and score > 0 then winner = true end
                                    table.insert(removedFigures, {guid=figure.getGUID(), winner=winner})
                                    figure.unlock()
                                    figure.use_gravity = false
                                    figure.interactable = false
                                    --raise the figure in the air
                                    figure.setPositionSmooth({figure.getPosition().x, figure.getPosition().y + 2.5, figure.getPosition().z}, false, false)
                                end
                            end
                            if gameover then
                                praiseFiguresCameraFocus(false)
                            end
                            Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                            return
                        end
                        end
                    end
                end
            end
        end
    end
    if gameover then --do possessions now
        if controlPanelSettings['TnBTradeGoods'] then
            for _, tokenType in ipairs(TRADE_TOKEN_TYPES) do --trade tokens
                local highestNumTokens = 0
                local tokenCounts = {}
                --find the highest count for this token
                for _, player in ipairs(activePlayers) do
                    local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                    local playerNumTokens = 0
                    for _, obj in ipairs(playerPossessions) do
                        if obj.getName() == tokenType then
                            local quantity = obj.getQuantity()
                            if quantity == -1 then quantity = 1 end
                            if tokenCounts[player] == nil then
                                tokenCounts[player] = quantity
                            else
                                tokenCounts[player] = tokenCounts[player] + quantity
                            end
                        end
                    end
                    if tokenCounts[player] ~= nil and tokenCounts[player] > highestNumTokens then
                        highestNumTokens = tokenCounts[player]
                    end
                end
                if highestNumTokens > 0 then
                    --give points to players with the most tokens
                    for _, player in ipairs(activePlayers) do
                        local winner
                        if tokenCounts[player] == highestNumTokens then
                            winner = true
                            allGameMessage(player .. " scores 10 points on " .. tokenType .. "s", stringColorToRGB(player))
                            scorePoints(player, 'Trade Goods', 10)
                        else
                            winner = false
                        end
                        local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                        for _, obj in ipairs(playerPossessions) do
                            if obj.getName() == tokenType then
                                table.insert(removedFigures, {guid=obj.getGUID(), winner=winner})
                                obj.unlock()
                                obj.use_gravity = false
                                obj.interactable = false
                                --raise the token in the air
                                obj.setPositionSmooth({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                            end
                        end
                    end
                    transversedFeaturePositions = {}
                    praiseFiguresCameraFocus(true)
                    Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                    return
                end
            end
        end
        if controlPanelSettings['GoldminesGold'] then
            --find the highest count for this token
            for _, player in ipairs(activePlayers) do
                local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                local playerNumGold = 0
                for _, obj in ipairs(playerPossessions) do
                    if obj.getName() == GOLD_BAR_NAME then
                        local quantity = obj.getQuantity()
                        if quantity == -1 then quantity = 1 end
                        playerNumGold = playerNumGold + quantity
                        table.insert(removedFigures, {guid=obj.getGUID(), winner=true})
                        obj.unlock()
                        obj.use_gravity = false
                        obj.interactable = false
                        --raise the token in the air
                        obj.setPositionSmooth({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                    end
                end
                if playerNumGold > 0 then
                    local goldPoints
                    local goldMultiplier
                    if playerNumGold > 9 then
                        goldMultiplier =  4
                    elseif playerNumGold > 6 then
                        goldMultiplier = 3
                    elseif playerNumGold > 3 then
                        goldMultiplier = 2
                    else
                        goldMultiplier = 1
                    end
                    allGameMessage(player .. " scores " .. playerNumGold * goldMultiplier .. " points on " .. playerNumGold .. " gold bars (" .. goldMultiplier .. " points each).", stringColorToRGB(player))
                    scorePoints(player, 'Gold', playerNumGold * goldMultiplier)
                    transversedFeaturePositions = {}
                    praiseFiguresCameraFocus(true)
                    Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                    return
                end
            end
        end
        --count total completed cities and roads for king and robber points
        local numCities = 0
        local numRoads = 0
        resetTransversal()
        if controlPanelSettings['KnRBKing'] or controlPanelSettings['KnRBRobber'] then
            for x, tileColumn in pairs(tileGrid) do
                for z, tileLocation in pairs(tileColumn) do
                    local tile = getObjectFromGUID(tileLocation.tile_guid)
                    for i=1, 12 do --roads and cities
                        if transversedGrid[x] == nil or transversedGrid[x][z] == nil or transversedGrid[x][z][i] == nil or transversedGrid[x][z][i] > 1 then
                            if controlPanelSettings['KnRBRobber'] and i < 5 and tile.getTable("sides")[i] == 'Road' then
                                if getFeatureComponents(x, z, i, 1, false) then
                                    numRoads = numRoads + 1
                                end
                            elseif controlPanelSettings['KnRBKing'] and i >= 5 and (tile.getTable("sides")[math.floor((i - 3) / 2)] == 'City' or tile.getTable("sides")[math.floor((i - 3) / 2)] == 'Carcassonne') then
                                if getFeatureComponents(x, z, i, 1, false) then
                                    numCities = numCities + 1
                                end
                            end
                        end
                    end
                end
            end
            --find king and robber tokens and give points
            for _, player in ipairs(activePlayers) do
                local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                for _, obj in ipairs(playerPossessions) do
                    local score
                    if obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid then
                        score = numCities
                    elseif obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid then
                        score = numRoads
                    end
                    if (obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid and controlPanelSettings['KnRBKing']) or (obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid and controlPanelSettings['KnRBRobber']) then
                        allGameMessage(player .. " scores " .. score .. " points on " .. obj.getName(), stringColorToRGB(player))
                        scorePoints(player, 'King/Robber Tokens', score)
                        table.insert(removedFigures, {guid=obj.getGUID(), winner=true})
                        obj.unlock()
                        obj.use_gravity = false
                        obj.interactable = false
                        --raise the token in the air
                        obj.setPositionSmooth({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                        transversedFeaturePositions = {}
                        praiseFiguresCameraFocus(false)
                        Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                        return
                    end
                end
            end
        end
    end
    scoring = false
    followersScored = {}
    if gameover then
        printedPlayers = {}
        local playerNum = 1
        local rank = 1
        local lastHighscore = 0
        while true do
            local highscore = 0
            local color = nil
            for _, player in pairs(activePlayers) do
                local scoreCounter = getObjectFromGUID(SCORE_COUNTER_GUIDS[player])
                if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                    if scoreCounter.Counter.getValue() > highscore then
                        highscore = scoreCounter.Counter.getValue()
                        color = player
                    end
                end
            end
            if highscore > 0 then
                if highscore < lastHighscore then rank = playerNum end
                local steam_name = ""
                if controlPanelSettings[color .. 'Hotseat'] ~= nil then
                    if Player[controlPanelSettings[color .. 'Hotseat']].steam_name ~= nil then steam_name = Player[controlPanelSettings[color .. 'Hotseat']].steam_name .. " (Hotseat)" end
                else
                    if Player[color].steam_name ~= nil then steam_name = Player[color].steam_name end
                end
                allGameMessage("#" .. rank .. " - " .. highscore .. " points - ".. color .. " - " .. steam_name, stringColorToRGB(color))
            else
                break
            end
            table.insert(printedPlayers, color)
            playerNum = playerNum + 1
            lastHighscore = highscore
        end
        allGameMessage("Game over.", NEUTRAL_COLOR)
        allGameMessage("If you enjoyed the mod, please give it a like on the workshop. If you encountered any bugs, please upload a save file and describe it in the workshop comments.", NEUTRAL_COLOR)
    else
        return nextState('next')
    end
end

function rewardFairy()
    local closestFollower = fairyClosestFollower()
    local pointGiven = false
    if closestFollower ~= nil and closestFollower.getDescription() == activePlayers[currentPlayer] then
        allGameMessage(closestFollower.getDescription() .. " scores 1 point for being next to the fairy on their turn.", stringColorToRGB(closestFollower.getDescription()))
        scorePoints(closestFollower.getDescription(), 'Fairy', 1)
    end
    local tileStack = getObjectFromGUID(TILE_STACK_GUID)
    if tileStack == nil and pointGiven == true then
        allErrorMessage("Warning: Tile stack not found. Once the last tile has been placed, the player should not be rewarded 1 point by the fairy. If you're seeing this message after the last tile has been placed, you will need to manually subtract the last point given by the fairy.", activePlayers[currentPlayer])
    end
    return nextState('next')
end

function fairyClosestFollower()
    local closestFollower = nil
    local fairy = getObjectFromGUID(expansionBags['PnD'].contents['PnDFairy'].guid)
    if fairy ~= nil then
        local xIndex = math.floor((fairy.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((fairy.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        if tileGridOccupied(xIndex, zIndex) then
            local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
            local eligibleFollowers = {}
            for _, follower in ipairs(objs) do
                if table.contains(FOLLOWER_TYPES, follower.getName()) then
                    if xIndex == math.floor((follower.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
                     zIndex == math.floor((follower.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
                        table.insert(eligibleFollowers, follower)
                    end
                end
            end
            if #eligibleFollowers == 1 then
                closestFollower = eligibleFollowers[1]
            elseif #eligibleFollowers > 1 then
                local closestDistanceToFairy = 999
                for i, follower in ipairs(eligibleFollowers) do
                    local distanceToFairy = (follower.getPosition().x - fairy.getPosition().x) * (follower.getPosition().x - fairy.getPosition().x) + (follower.getPosition().z - fairy.getPosition().z) * (follower.getPosition().z - fairy.getPosition().z)
                    if distanceToFairy < closestDistanceToFairy then
                        closestDistanceToFairy = distanceToFairy
                        closestFollower = follower
                    end
                end
            end
        end
    end
    return closestFollower
end

function rewardGold()
    if currentMiniTurn == nil then
        currentMiniTurn = currentPlayer
    else
        currentMiniTurn = currentMiniTurn + 1
    end
    local test = 0
    if scoringRewards['Gold'] ~= nil then
        while true do
            if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
            local eligiblePlayers = {}
            eligibleGold = {}
            for gold_guid, players in pairs(scoringRewards['Gold']) do
                --print("checking gold: " .. gold_guid)
                for _, player in ipairs(players) do
                    --print("eligible player for this gold: " .. player)
                    if not table.contains(eligiblePlayers, player) then
                        --print("adding player: " .. player)
                        table.insert(eligiblePlayers, player)
                    end
                end
                --print("current player: " .. activePlayers[currentMiniTurn])
                if table.contains(players, activePlayers[currentMiniTurn]) then
                    --print("current player is eligible for this gold")
                    table.insert(eligibleGold, gold_guid)
                end
            end
            if #eligibleGold == 1 or (#eligibleGold > 0 and #eligiblePlayers == 1) then
                allGameMessage(activePlayers[currentMiniTurn] .. " was awarded a gold bar for having control over a finished feature.", stringColorToRGB(activePlayers[currentMiniTurn]), activePlayers[currentMiniTurn])
                return giveGold(eligibleGold[1], activePlayers[currentMiniTurn])
            elseif #eligibleGold > 1 then
                allGameMessage(activePlayers[currentMiniTurn] .. " may choose a gold bar for having control over a finished feature.", stringColorToRGB(activePlayers[currentMiniTurn]), activePlayers[currentMiniTurn])
                return promptGoldChoice(eligibleGold)
            end
            local count = 0
            for _, gold in pairs(scoringRewards['Gold']) do
                if gold ~= nil then
                    count = count + 1
                end
            end
            currentMiniTurn = currentMiniTurn + 1
            if count == 0 then break end
        end
    end
    currentMiniTurn = nil
    scoringRewards['Gold'] = nil
    return nextState('next')
end

function promptGoldChoice()
    for _, gold in ipairs(eligibleGold) do
        local goldButtonParam = {
           index = 1, label = 'Take\ngold', click_function = 'takeGoldButton',
           position = {x=0, y=3.0, z=2.0}, width = 1700, height=600, font_size = 200, function_owner = nil
        }
        createNormalizedButton(getObjectFromGUID(gold), goldButtonParam, true)
    end
end

function takeGoldButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        for _, gold in pairs(eligibleGold) do
            getObjectFromGUID(gold).clearButtons()
        end
        return giveGold(object.getGUID(), sPlayer)
    end
end

function giveGold(gold, player)
    local tradeGoodPile
    local x, z = rotateCoordinates(6.9, 1.5, PLAYER_POSSESSION_AREAS[player].rotation)
    --params.rotation = {0,  PLAYER_POSSESSION_AREAS[activePlayers[currentPlayer]].rotation * -90, 0}
    getObjectFromGUID(gold).setPositionSmooth({PLAYER_POSSESSION_AREAS[player].x + x, 2, PLAYER_POSSESSION_AREAS[player].z + z})

    scoringRewards['Gold'][gold] = nil
    return rewardGold()
end

function replaceFinishedWagons()
    currentMiniTurn = currentPlayer
    while true do
        if wagonLocations[activePlayers[currentMiniTurn]] ~= nil then
            if hasAvailableWagonFeature[activePlayers[currentMiniTurn]] then
                allGameMessage(activePlayers[currentMiniTurn] .. "'s wagon has finished and may now be placed back on a connected feature.", stringColorToRGB(activePlayers[currentMiniTurn]), activePlayers[currentMiniTurn])
                promptWagon()
                return
            else
                wagonLocations[activePlayers[currentMiniTurn]] = nil
                allGameMessage(activePlayers[currentMiniTurn] .. "'s wagon has finished, but there were no available features connected.", stringColorToRGB(activePlayers[currentMiniTurn]), activePlayers[currentMiniTurn])
            end
        end
        currentMiniTurn = currentMiniTurn + 1
        if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
        if currentMiniTurn == currentPlayer then break end
    end
    currentMiniTurn = nil
    return nextState('next')
end

function promptWagon()
    local labelButtonParam = {
       index = 1, label = 'Replace your wagon\nOR', click_function = 'doNothing',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=3.5}, width = 0, height=0, font_size = 200, function_owner = nil
    }
    local skipFigureButtonParam = {
       index = 2, label = 'Skip placing\nwagon', click_function = 'skipWagonButton',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=5.0}, width = 1700, height=600, font_size = 200, function_owner = nil
    }
    createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), labelButtonParam, true)
    createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), skipFigureButtonParam, true)
end

function skipWagonButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
        wagonLocations[activePlayers[currentMiniTurn]] = nil
        return replaceFinishedWagons()
    end
end

--focus the camera on the currently praised figures
--params:
-- bool - only winning figures will be focused on
function praiseFiguresCameraFocus(onlyWinners)
    local camera_position = {x = 0.0, y = 0.0, z = 0.0}
    local num_winners = 0
    local max_separation = 0
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        if not onlyWinners or figure.winner then
            camera_position.x = camera_position.x + figure_obj.getPosition().x
            camera_position.y = camera_position.y + figure_obj.getPosition().y
            camera_position.z = camera_position.z + figure_obj.getPosition().z
            num_winners = num_winners + 1
            for _, other_figure in ipairs(removedFigures) do
                local other_figure_obj = getObjectFromGUID(other_figure.guid)
                local separation = math.sqrt((figure_obj.getPosition().x - other_figure_obj.getPosition().x) * (figure_obj.getPosition().x - other_figure_obj.getPosition().x) +
                          (figure_obj.getPosition().z - other_figure_obj.getPosition().z) * (figure_obj.getPosition().z - other_figure_obj.getPosition().z))
                if separation > max_separation then
                    max_separation = separation
                end
            end
        end
    end
    if num_winners > 0 then
        camera_position.x = camera_position.x / num_winners
        camera_position.y = camera_position.y / num_winners
        camera_position.z = camera_position.z / num_winners
    end
    for _, player in ipairs(activePlayers) do
        if Player[player].seated then
            --getPointerRotation gives the player's current yaw (though +180 degrees). Use this to keep the yaw steady.
            local camera_yaw = Player[player].getPointerRotation() + 180
            if camera_yaw > 360 then camera_yaw = camera_yaw - 360 end
            local camera_params = {
                position = camera_position,
                yaw = camera_yaw,
                pitch = 35.0,
                --in theory this formula should give the camera distance needed to fit both objects in the screen
                --local camera_distance = math.tan((180 - fov) / 2) * (max_separation / 2)
                -- if the FoV is 90 degrees, then the altitude of the triangle is half the hypotenuse (which is the distance between the objects)
                -- is it correct? probably not, but it sounds good enough to me
                distance = 15.0 + (max_separation * 0.5)
            }
            Player[player].lookAt(camera_params)
        end
    end
end

function praiseFigures()
    --startLuaCoroutine(self, 'praiseFiguresCoroutine')

    local CoNew = coroutine.create(praiseFiguresCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--makes the winning followers spin and marks the features that were scored
function praiseFiguresCoroutine()
    for _, figure in ipairs(removedFigures) do
        if figure.winner then
            getObjectFromGUID(figure.guid).addTorque({0,25,0}, 4)
        end
    end
    if showMarkers == 'Scoring' or showMarkers == 'Both' then
        for _, transversedTileCoord in ipairs(transversedTileCoords) do
            if transversedTileCoord ~= nil then
                if transversedFeaturePositions[transversedTileCoord.x] ~= nil and transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z] ~= nil then
                    for position, transversedFeaturePosition in pairs(transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z]) do
                        if position < 13 or getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid).getTable("specialFeatures")[position - 12][3] ~= nil then
                            local x = nil
                            local z = nil
                            local tile = getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid)
                            local rotation = tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation
                            x, z = getFeatureLocation(position, tile, rotation)
                            if x ~= nil and z ~= nil then
                                local params = {}
                                if transversedFeaturePosition == 1 then
                                    params.type = "BlockSquare"
                                elseif transversedFeaturePosition == 2 then
                                    params.type = "BlockTriangle"
                                end
                                params.position = {(x * TILE_SPACING) + (transversedTileCoord.x * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (transversedTileCoord.z * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                                params.scale = {0.25, 0.25, 0.25}
                                params.callback = "identifyFeature"
                                local newObject = spawnObject(params)
                                table.insert(featureMarkers, newObject)
                            end
                        end
                    end
                    coroutine.yield(0)
                end
            end
        end
    end
    Timer.create({identifier=os.clock(), function_name='returnFigures', function_owner=nil, parameters=nil, delay=FIGURE_PRAISE_DELAY})
    return 1
end

--when we spawn an object (to mark a feature), immediately lock it
function identifyFeature(obj)
    obj.lock()
end

function returnFigures()
    --startLuaCoroutine(self, 'returnFiguresCoroutine')

    local CoNew = coroutine.create(returnFiguresCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--send figures back to the player supply area (assuming that's where they were when the game started)
function returnFiguresCoroutine()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        figure_obj.unlock()
        figure_obj.use_gravity = true
        figure_obj.interactable = true

        if figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid or figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid or table.contains(TRADE_TOKEN_TYPES, figure_obj.getName()) or figure_obj.getName() == GOLD_BAR_NAME then
            -- move the tokens away from the player possession area. It doesn't really matter where, as long as we move them so they aren't counted twice.
            local targetPosition = {x = NEUTRAL_ITEMS_LOCATION.x, y = NEUTRAL_ITEMS_LOCATION.y, z = NEUTRAL_ITEMS_LOCATION.z}
            if figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid then
                targetPosition.x = targetPosition.x + 1 --arbitrary location
            elseif figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid then
                targetPosition.x = targetPosition.x + 3 --arbitrary location
            end

            local container = nil
            if figure_obj.getName() == 'Wheat Token' then
                container = getObjectFromGUID(expansionBags['TnB'].contents['TnBWheatTokenStack'].guid)
            elseif figure_obj.getName() == 'Wine Token' then
                container = getObjectFromGUID(expansionBags['TnB'].contents['TnBWineTokenStack'].guid)
            elseif figure_obj.getName() == 'Cloth Token' then
                container = getObjectFromGUID(expansionBags['TnB'].contents['TnBClothTokenStack'].guid)
            elseif figure_obj.getName() == GOLD_BAR_NAME then
                container = getObjectFromGUID(expansionBags['Goldmines'].contents['GoldminesGold'].guid)
            end
            if container ~= nil then
                targetPosition = {container.getPosition().x, container.getPosition().y + 1, container.getPosition().z}
            elseif table.contains(TRADE_TOKEN_TYPES, figure_obj.getName()) then
                allErrorMessage("Warning: " .. figure_obj.getName() .. " doesn't have a home and must be returned manually", activePlayers[currentPlayer])
            end
            figure_obj.setPositionSmooth(targetPosition, false, false)
        else
            local found_home = false
            if figurePositions[figure_obj.getDescription()] ~= nil and figurePositions[figure_obj.getDescription()][figure_obj.getName()] then
                for i, figure_GUID in ipairs(figurePositions[figure_obj.getDescription()][figure_obj.getName()]) do
                    if figure_GUID == figure_obj.getGUID() then
                        local figurePad = getObjectFromGUID(FIGUREPAD_GUIDs[figure_obj.getDescription()])
                        local figureSetting = nil
                        for _, temp_figureSetting in pairs(figureSettings) do
                            if figure_obj.getName() == temp_figureSetting.name then
                                figureSetting = temp_figureSetting
                                break
                            end
                        end
                        if figureSetting ~= nil then
                            local x, z = rotateCoordinatesDegrees(figureSetting.offset.x + (((i - 1) % 4) * -1.45), figureSetting.offset.z + (math.floor((i - 1) / 4) * 1.0), -figurePad.getRotation().y)
                            figure_obj.unlock()
                            figure_obj.setPositionSmooth({x = figurePad.getPosition().x + x, y = figurePad.getPosition().y + 1, z = figurePad.getPosition().z + z}, false, false)
                            figure_obj.setRotationSmooth({x=0, y=figurePad.getRotation().y, z=0})
                            found_home = true
                        else
                            allErrorMessage("Warning: " .. figure_obj.getName() .. " missing from figure settings", activePlayers[currentPlayer])
                        end
                    end
                end
                if figure_obj.getName() == 'Abbot' then --FIXME: this is a temporary solution until abbots can be added to the control panel
                    local i = 1
                    local figurePad = getObjectFromGUID(FIGUREPAD_GUIDs[figure_obj.getDescription()])
                    local figureSetting = nil
                    for _, temp_figureSetting in pairs(figureSettings) do
                        if figure_obj.getName() == temp_figureSetting.name then
                            figureSetting = temp_figureSetting
                            break
                        end
                    end
                    if figureSetting ~= nil then
                        local x, z = rotateCoordinatesDegrees(figureSetting.offset.x + (((i - 1) % 4) * -1.45), figureSetting.offset.z + (math.floor((i - 1) / 4) * 1.0), -figurePad.getRotation().y)
                        figure_obj.setPositionSmooth({x = figurePad.getPosition().x + x, y = figurePad.getPosition().y + 1, z = figurePad.getPosition().z + z}, false, false)
                        figure_obj.setRotationSmooth({x=0, y=figurePad.getRotation().y, z=0})
                        found_home = true
                    else
                        allErrorMessage("Warning: " .. figure_obj.getName() .. " missing from figure settings", activePlayers[currentPlayer])
                    end
                end
            end
            if found_home == false then
                allErrorMessage("Warning: " .. figure_obj.getName() .. " doesn't have a home and must be returned manually", activePlayers[currentPlayer])
            end
        end
        coroutine.yield(0)
    end
    removedFigures = {}

    --make sure to give enough time for pieces to travel back or they might be counted twice
    nextState('figures returned')
    return 1
end

function debugShowTransversal()
    for xIndex, temp in pairs(transversedFeaturePositions) do
        for zIndex, bla in pairs(temp) do
            for position, transversedFeaturePosition in pairs(bla) do
                if position < 13 or getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).getTable("specialFeatures")[position - 12][3] ~= nil then
                    local x = nil
                    local z = nil
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local rotation = tileGrid[xIndex][zIndex].rotation
                    x, z = getFeatureLocation(position, tile, rotation)
                    if x ~= nil and z ~= nil and transversedFeaturePosition ~= 2 then
                        local params = {}
                        if transversedFeaturePosition == 1 then
                            params.type = "BlockSquare"
                        elseif transversedFeaturePosition == 2 then
                            params.type = "BlockTriangle"
                        end
                        params.position = {(x * TILE_SPACING) + (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                        params.scale = {0.25, 0.25, 0.25}
                        params.callback = "identifyFeature"
                        local newObject = spawnObject(params)
                        table.insert(featureMarkers, newObject)
                    end
                end
            end
        end
    end
    for xIndex, temp in pairs(transversedGrid) do
        for zIndex, bla in pairs(temp) do
            for position, transversedPosition in pairs(bla) do
                if position < 13 or getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).getTable("specialFeatures")[position - 12][3] ~= nil then
                    local x = nil
                    local z = nil
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local rotation = tileGrid[xIndex][zIndex].rotation
                    x, z = getFeatureLocation(position, tile, rotation)
                    if x ~= nil and z ~= nil then
                        local params = {}
                        if transversedPosition ~= nil and (transversedFeaturePositions[xIndex] == nil or transversedFeaturePositions[xIndex][zIndex] == nil or transversedFeaturePositions[xIndex][zIndex][position] == nil or transversedFeaturePositions[xIndex][zIndex][position] == 2) then
                            params.type = "BlockRectangle"
                        end
                        params.position = {(x * TILE_SPACING) + (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                        params.scale = {0.25, 0.25, 0.25}
                        params.callback = "identifyFeature"
                        local newObject = spawnObject(params)
                        table.insert(featureMarkers, newObject)
                    end
                end
            end
        end
    end
    Timer.create({identifier=os.clock(), function_name='deleteMarkers', function_owner=nil, parameters=nil, delay=8})
end

function deleteMarkers()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
end

function getFeatureLocation(feature, tile, rotation)
    local x, z
    local position = 1
    if feature < 13 then
        local a, side, j
        if feature < 5 then
            side = feature
            a = 0
            j = 0
        else
            side = math.floor((feature - 3) / 2)
            a = 1
            j = (feature - 3) % 2
        end
        x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, ((8 + TILE_STANDARD_ROTATION - side - rotation) % 4) + 1)
    else
        local features = tile.getTable("specialFeatures")
        x, z = rotateCoordinates(features[feature - 12][3][1], features[feature - 12][3][2], (TILE_STANDARD_ROTATION - 1 - rotation) % 4 + 1)
    end
    return x, z
end

--getFeatureName
--
-- Gets the name of the feature on the tile at the specified position
--
-- params:
--  obj: tile
--  position: 1-12, 13-...
-- returns:
--  string: name
function getFeatureName(tile, position)
    local nameOfFeature
    if position < 5 then
        nameOfFeature = tile.getTable("sides")[position]
    elseif position < 13 then
        nameOfFeature = tile.getTable("sides")[math.floor((position - 3) / 2)]
        if nameOfFeature == 'Road' or nameOfFeature == 'River' then nameOfFeature = 'Field' end
    else
        local features = tile.getTable("specialFeatures")
        if features[position - 12] ~= nil then
            nameOfFeature = features[position - 12][1]
        else
            nameOfFeature = "ERROR: Feature at position " .. position .. " doesn't exist"
        end
    end
    return nameOfFeature
end

--getFeatureComponents
--
-- Transverses the tiles recursively, storing all associated tiles, features, and followers into their respective global variables
--
-- params:
--  int: xIndex
--  int: zIndex
--  int: position number to check
--  int: number of transversal levels do check
--  bool: false if multiple getFeatureComponents calls will be made. This prevents resetting the transversal and also does not check for followers each time. The goal is to save on performance.
-- returns:
--  bool: true if the feature is complete, false if not complete
function getFeatureComponents(xIndex, zIndex, position, tranversalLevels, reset)
    if reset then --for when we want to make multiple feature transversals without revisiting already visited positions
        resetTransversal()
    end

    local nameOfFeature = getFeatureName(getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), position)
    local finished = nil
    if position < 5 then
        if nameOfFeature == 'River' then return false
        elseif nameOfFeature == 'Road' then
            finished = getTileComponents(xIndex, zIndex, position, tranversalLevels, 1)
        else
            --in theory this shouldn't happen unless a player allows a figure to stay somewhere they're not supposed to
            --if it happens, just pick an arbitrary octant
            finished = getTileComponents(xIndex, zIndex, (position * 2) + 3, tranversalLevels, 1)
        end
    else
        finished = getTileComponents(xIndex, zIndex, position, tranversalLevels, 1)
    end

    if reset then -- don't run for each call of getFeatureComponents. Instead, getFigureComponents should be called from the calling method.
        getFigureComponents()
    end

    if finished then
        debugMessage(1, "Feature is complete")
    else
        debugMessage(1, "Feature is not complete")
    end

    return finished
end

--getFigureComponents
--
-- Transverses the all objects in the play area, storing followers and tokens that were in the transversed positions
function getFigureComponents()
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for _, obj in ipairs(objs) do
        if table.contains(FOLLOWER_TYPES, obj.getName()) or table.contains(SPECIAL_FIGURE_TYPES, obj.getName()) or table.contains(SHEEP_TOKEN_TYPES, obj.getName()) or obj.getName() == GOLD_BAR_NAME then
            local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            debugMessage(2, "Object on tile: x: " .. xIndex .. " z: " .. zIndex)
            if obj.getName() == GOLD_BAR_NAME and table.contains(transversedTileCoords, {x=xIndex, z=zIndex}) then
                debugMessage(2, obj.getName() .. " added to transversedGoldBars table")
                table.insert(transversedGoldBars, obj)
            elseif transversedFeaturePositions[xIndex] ~= nil and transversedFeaturePositions[xIndex][zIndex] ~= nil then
                local xPosition = (obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                xPosition = xPosition - xIndex
                zPosition = zPosition - zIndex
                local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation)
                debugMessage(2, "Object closest feature: index: x: " .. xIndex .. " z: " .. zIndex .. " feature: " .. closestFeature)
                if transversedFeaturePositions[xIndex][zIndex][closestFeature] == 1 then
                    if table.contains(FOLLOWER_TYPES, obj.getName()) then
                        debugMessage(2, obj.getDescription() .. " " .. obj.getName() .. " added to transversedFollowers table")
                        table.insert(transversedFollowers, obj)
                    elseif table.contains(SPECIAL_FIGURE_TYPES, obj.getName()) then
                        debugMessage(2, obj.getDescription() .. " " .. obj.getName() .. " added to transversedSpecialFigures table")
                        table.insert(transversedSpecialFigures, obj)
                    elseif table.contains(SHEEP_TOKEN_TYPES, obj.getName()) then
                        debugMessage(2, obj.getName() .. " added to transversedSheepTokens table")
                        table.insert(transversedSheepTokens, obj)
                    end
                end
            end
        end
    end
    debugMessage(1, "Transversed " .. #transversedTileCoords .. " tiles, " .. #transversedFollowers .. " followers, " .. #transversedSpecialFigures .. " special figures, " .. #transversedSpecialFeatures .. " special features, " .. #transversedSheepTokens .. " sheep tokens, and " .. #transversedGoldBars .. " gold bars")
end

--getSecondaryFigureComponents
--
-- Transverses the all followers in the play area, returns true if any of them are in the temporaryFeaturePositions
function hasSecondaryFigureComponents()
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for _, obj in ipairs(objs) do
        if table.contains(FOLLOWER_TYPES, obj.getName()) then
            --print("checking " .. obj.getDescription() .. " " .. obj.getName())
            local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            debugMessage(2, "Object on tile: x: " .. xIndex .. " z: " .. zIndex)
            if temporaryFeaturePositions[xIndex] ~= nil and temporaryFeaturePositions[xIndex][zIndex] ~= nil then
                local xPosition = (obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                xPosition = xPosition - xIndex
                zPosition = zPosition - zIndex
                local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation)
                debugMessage(2, "Object closest feature: index: x: " .. xIndex .. " z: " .. zIndex .. " feature: " .. closestFeature)
                if temporaryFeaturePositions[xIndex][zIndex][closestFeature] ~= nil then
                    return true
                end
            end
        end
    end
    --print("no followers in secondary feature")
    return false
end

--getTileComponents
--
-- Transverses the tiles recursively, storing all associated tiles, features, and followers into their respective global variables
--
-- params:
--  int: xIndex
--  int: zIndex
--  int: position number to check
--  int: how many transversal levels to check
--       2 levels would be used for checking secondary features such as completed cities and road intersections
--  int: current transversal level
--  bool: if this value is true, add feature positions to a temporary table. This is used to check secondary positions for followers for the wagon
-- returns:
--  bool: true if the feature is complete, false if not complete
function getTileComponents(xIndex, zIndex, position, tranversalLevels, transversalNum, addToTempPositions)
    if transversalNum > tranversalLevels then return true end
    debugMessage(1, "checking tile at x: " .. xIndex .. " z: " .. zIndex .. " position: " .. position .. " trans num: " .. transversalNum)
    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
    local rotation = tileGrid[xIndex][zIndex].rotation
    if transversedGrid[xIndex] == nil then
        transversedGrid[xIndex] = {}
    end
    if transversedGrid[xIndex][zIndex] == nil then
        transversedGrid[xIndex][zIndex] = {}
    end
    if transversedFeaturePositions[xIndex] == nil then
        transversedFeaturePositions[xIndex] = {}
    end
    if transversedFeaturePositions[xIndex][zIndex] == nil then
        transversedFeaturePositions[xIndex][zIndex] = {}
    end
    if transversalNum == 1 and not table.contains(transversedTileCoords, {x=xIndex, z=zIndex}) then
        table.insert(transversedTileCoords, {x=xIndex, z=zIndex})
        debugMessage(2, "adding tile to transversedTileCoords: x: " .. xIndex .. " z: " .. zIndex)
    end
    if addToTempPositions then
        if temporaryFeaturePositions[xIndex] == nil then
            temporaryFeaturePositions[xIndex] = {}
        end
        if temporaryFeaturePositions[xIndex][zIndex] == nil then
            temporaryFeaturePositions[xIndex][zIndex] = {}
        end
    end
    if transversedGrid[xIndex][zIndex][position] ~= nil and transversedGrid[xIndex][zIndex][position] <= transversalNum then return true end
    local finished = true
    local features = tile.getTable("specialFeatures")
    if position < 5 then
        local links = tile.getTable("linkedQuadrants")
        while transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum do
            if links ~= nil then
                for _, link in ipairs(links) do
                    if table.contains(link, position) then
                        for _, quadrant in ipairs(link) do
                            if transversedGrid[xIndex][zIndex][quadrant] == nil or transversedGrid[xIndex][zIndex][quadrant] > transversalNum then
                                transversedGrid[xIndex][zIndex][quadrant] = transversalNum
                                if transversalNum == 1 then
                                    transversedFeaturePositions[xIndex][zIndex][quadrant] = 1
                                elseif addToTempPositions then
                                    temporaryFeaturePositions[xIndex][zIndex][quadrant] = transversalNum
                                end
                                local direction = (3 + quadrant + rotation) % 4 + 1
                                local newX = xIndex + SIDE_DELTA[direction].x
                                local newZ = zIndex + SIDE_DELTA[direction].z
                                debugMessage(2, "checking x:" .. xIndex .. " z:" .. zIndex .. " quadrant:" .. quadrant .. " direction:" .. direction .. " newX:" .. newX .. " newZ:" .. newZ .. " trans num: " .. transversalNum)
                                if tileGrid[newX] ~= nil then
                                    if tileGrid[newX][newZ] ~= nil then
                                        local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                                        local newTileRotation = tileGrid[newX][newZ].rotation
                                        local newTilePosition = (3 + quadrant + rotation - newTileRotation + TILE_180_ROTATION) % 4 + 1
                                        debugMessage(2, "newTilePosition: " .. newTilePosition)
                                        if getFeatureName(newTile, newTilePosition) ~= 'Abbey' and getFeatureName(tile, position) ~= 'Abbey' then
                                            if not getTileComponents(newX, newZ, newTilePosition, tranversalLevels, transversalNum) then finished = false end
                                        elseif transversalNum == 1 then
                                            if getFeatureName(newTile, newTilePosition) == 'Abbey' then
                                                getTileComponents(newX, newZ, (newTilePosition * 2) + 3, tranversalLevels, transversalNum + 1)
                                            elseif getFeatureName(newTile, newTilePosition) ~= 'Field' then
                                                getTileComponents(newX, newZ, newTilePosition, tranversalLevels, transversalNum + 1)
                                            end
                                        end
                                    else
                                        debugMessage(2, "Next tile is empty. Feature is not finished")
                                        finished = false
                                    end
                                else
                                    debugMessage(2, "Next tile is empty. Feature is not finished")
                                    finished = false
                                end
                            end
                        end
                    end
                end
            end
             --workaround for when the target position has no links and is the first tile of the chain
             --in that case, the target position would never be checked, and, therefore, none of its neighbors
             --so we force it to be checked by running again with a links table containing the element
            if transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum then
                links = {{position}}
            end
        end
    elseif position < 13 then
        local links = tile.getTable("linkedOctants")
        while transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum do
            if links ~= nil then
                for _, link in ipairs(links) do
                    if table.contains(link, position) then
                        for _, octant in ipairs(link) do
                            if transversedGrid[xIndex][zIndex][octant] == nil or transversedGrid[xIndex][zIndex][octant] > transversalNum then
                                transversedGrid[xIndex][zIndex][octant] = transversalNum
                                if transversalNum == 1 then
                                    transversedFeaturePositions[xIndex][zIndex][octant] = 1
                                elseif addToTempPositions then
                                    temporaryFeaturePositions[xIndex][zIndex][octant] = transversalNum
                                end
                                local direction = (3 + octant + (rotation * 2)) % 8 + 5
                                local newX = xIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                                local newZ = zIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                                debugMessage(2, "checking x:" .. xIndex .. " z:" .. zIndex .. " octant:" .. octant .. " direction:" .. direction .. " newX:" .. newX .. " newZ:" .. newZ .. " trans num: " .. transversalNum)
                                if tileGrid[newX] ~= nil then
                                    if tileGrid[newX][newZ] ~= nil then
                                        local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                                        local newTileRotation = tileGrid[newX][newZ].rotation
                                        local newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (newTileRotation * 2) - 4) % 8 + 5
                                        debugMessage(2, "newTileRotation: " .. newTileRotation .. " newTilePosition: " .. newTilePosition)
                                        if getFeatureName(newTile, newTilePosition) ~= 'Abbey' and getFeatureName(tile, position) ~= 'Abbey' then
                                            if not getTileComponents(newX, newZ, newTilePosition, tranversalLevels, transversalNum) then finished = false end
                                        elseif transversalNum == 1 then -- all of this is for Abbeys and Wagons
                                            if getFeatureName(newTile, (newTilePosition - 3) / 2) == 'Road' then
                                                getTileComponents(newX, newZ, math.floor((newTilePosition - 3) / 2), tranversalLevels, transversalNum + 1)
                                            elseif getFeatureName(newTile, newTilePosition) ~= 'Field' then
                                                getTileComponents(newX, newZ, newTilePosition, tranversalLevels, transversalNum + 1)
                                            end
                                        end
                                    else
                                        debugMessage(2, "Next tile is empty. Feature is not finished")
                                        finished = false
                                    end
                                else
                                    debugMessage(2, "Next tile is empty. Feature is not finished")
                                    finished = false
                                end
                            end
                        end
                    end
                end
            end
             --workaround for when the target position has no links and is the first tile of the chain
             --in that case, the target position would never be checked, and, therefore, none of its neighbors
             --so we force it to be checked by running again with a links table containing the element
            if transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum then
                links = {{position}}
            end
        end
    else
        if transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum then
            transversedGrid[xIndex][zIndex][position] = transversalNum
            if transversalNum == 1 then
                transversedFeaturePositions[xIndex][zIndex][position] = 1
            elseif addToTempPositions then
                temporaryFeaturePositions[xIndex][zIndex][position] = transversalNum
            end
            local feature = features[position - 12]
            if (feature[1] == 'Cloister' or feature[1] == 'Abbey' or feature[1] == 'Shrine' or feature[1] == "Baba Yaga's Hut" or feature[1] == 'Garden') and transversalNum == 1 then
                table.insert(transversedSpecialFeatures, feature[1])
                debugMessage(1, feature[1] .. " added to transversedSpecialFeatures")
                local tileNum = 1
                for i = -1, 1 do
                    for j = -1, 1 do
                        if tileGridOccupied(xIndex + i, zIndex + j) then
                            if not (i == 0 and j == 0) then --we already added the tile
                                table.insert(transversedTileCoords, {x=xIndex + i, z=zIndex + j})
                                tileNum = tileNum + 1
                                specialFeatures = getObjectFromGUID(tileGrid[xIndex + i][zIndex + j].tile_guid).getTable("specialFeatures")
                                if specialFeatures ~= nil then
                                    for _, specialFeature in ipairs(specialFeatures) do
                                        if specialFeature[1] == "Vineyard" then
                                            table.insert(transversedSpecialFeatures, specialFeature[1])
                                            debugMessage(1, specialFeature[1] .. " added to transversedSpecialFeatures")
                                        end
                                    end
                                end
                            end
                            --this is purely for graphical effect of showing what tiles were used in scoring the cloister
                            if not (i == 0 and j == 0 and feature[1] == 'Abbey') then
                                if transversalNum == 1 then
                                    if transversedFeaturePositions[xIndex + i] == nil then
                                        transversedFeaturePositions[xIndex + i] = {}
                                    end
                                    if transversedFeaturePositions[xIndex + i][zIndex + j] == nil then
                                        transversedFeaturePositions[xIndex + i][zIndex + j] = {}
                                    end
                                    for k = 1, 12 do
                                        if transversedFeaturePositions[xIndex + i][zIndex + j][k] == nil then
                                            transversedFeaturePositions[xIndex + i][zIndex + j][k] = 2
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if tileNum < 9 then finished = false end
            end
            if feature[1] == 'City' or feature[1] == 'Road' or feature[1] == 'Field' or feature[1] == 'Abbey' then
                if feature[2] ~= nil then
                    for _, location in ipairs(feature[2]) do
                        if transversedGrid[xIndex][zIndex][location] == nil or transversedGrid[xIndex][zIndex][location] > transversalNum then
                            if transversalNum == 1 then
                                transversedFeaturePositions[xIndex][zIndex][location] = 1
                            elseif addToTempPositions then
                                temporaryFeaturePositions[xIndex][zIndex][location] = transversalNum
                            end
                            if not getTileComponents(xIndex, zIndex, location, tranversalLevels, transversalNum) then finished = false end
                        end
                    end
                end
            end
        end
    end
    if features ~= nil then
        for i, feature in ipairs(features) do
            if feature[2] ~= nil then
                if table.contains(feature[2], position) then
                    if (transversedGrid[xIndex][zIndex][i+12] == nil or transversedGrid[xIndex][zIndex][i+12] > transversalNum) and not (feature[1] == 'City-Field' and getFeatureName(tile, position) ~= 'Field') then
                        if feature[1] == 'Abbey' then
                            finished = getTileComponents(xIndex, zIndex, i+12, tranversalLevels, transversalNum)
                        else
                            transversedGrid[xIndex][zIndex][i+12] = transversalNum
                            if transversalNum == 1 then
                                transversedFeaturePositions[xIndex][zIndex][i+12] = 1
                                if feature[1] == 'City-Field' then
                                    if getFeatureName(tile, position) == 'Field' then
                                        for _, octant in ipairs(feature[2]) do
                                            if getFeatureName(tile, octant) == 'City' or getFeatureName(tile, octant) == 'Carcassonne' then
                                                if transversedGrid[xIndex][zIndex][octant] == nil or transversedGrid[xIndex][zIndex][octant] > transversalNum + 1 then
                                                    if getTileComponents(xIndex, zIndex, octant, tranversalLevels, transversalNum + 1) then
                                                        table.insert(transversedSpecialFeatures, "Completed City")
                                                        transversedFeaturePositions[xIndex][zIndex][octant] = 2
                                                        debugMessage(1, "Completed City added to transversedSpecialFeatures")
                                                    end
                                                end
                                            end
                                        end
                                    end
                                elseif feature[1] == 'Road Intersection' then
                                    for _, location in ipairs(feature[2]) do
                                        temporaryFeaturePositions = {}
                                        if not getTileComponents(xIndex, zIndex, location, tranversalLevels, transversalNum + 1, true) then
                                            if not hasSecondaryFigureComponents() then
                                                hasIncompleteSecondaryFeature = true
                                            end
                                        end
                                    end
                                elseif feature[1] == 'Coat of Arms' or feature[1] == 'Inn' or feature[1] == 'Cathedral' or
                                    feature[1] == 'Cloth Token' or feature[1] == 'Wine Token' or feature[1] == 'Wheat Token' or
                                    feature[1] == 'Pig-herd' or feature[1] == 'Sheep' then
                                    table.insert(transversedSpecialFeatures, feature[1])
                                    debugMessage(1, feature[1] .. " added to transversedSpecialFeatures")
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    for i=1, 4 do
        --this one is necessary for followers placed on center positions for quadrant features to be processed correctly
        if getFeatureName(tile, i) ~= 'Road' and getFeatureName(tile, i) ~= 'River' then
            if transversedFeaturePositions[xIndex][zIndex][i] ~= nil then
                if transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] == nil or transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] > transversedFeaturePositions[xIndex][zIndex][i] then
                    transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] = transversedFeaturePositions[xIndex][zIndex][i]
                end
                if transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] == nil or transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] > transversedFeaturePositions[xIndex][zIndex][i] then
                    transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] = transversedFeaturePositions[xIndex][zIndex][i]
                end
            end
            if addToTempPositions and temporaryFeaturePositions[xIndex][zIndex][i] ~= nil then
                if temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] == nil or temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] > temporaryFeaturePositions[xIndex][zIndex][i] then
                    temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] = temporaryFeaturePositions[xIndex][zIndex][i]
                end
                if temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] == nil or temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] > temporaryFeaturePositions[xIndex][zIndex][i] then
                    temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] = temporaryFeaturePositions[xIndex][zIndex][i]
                end
            end
            --this is just used for graphical effect
            if transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] ~= nil and transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] ~= nil and transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] == transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] then
                transversedFeaturePositions[xIndex][zIndex][i] = transversedFeaturePositions[xIndex][zIndex][i * 2 + 3]
            end
            if addToTempPositions and temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] ~= nil and temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] ~= nil and temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] == temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] then
                temporaryFeaturePositions[xIndex][zIndex][i] = temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3]
            end
        end
    end
    return finished
end

--resetTransversal
--Empties the transversal tables, so that they are ready for the next transversal
function resetTransversal()
    debugMessage(2, "Clearing transversal tables")
    transversedGrid = {}
    temporaryFeaturePositions = {}
    transversedFeaturePositions = {}
    transversedTileCoords = {}
    transversedSpecialFeatures = {}
    transversedFollowers = {}
    transversedSpecialFigures = {}
    transversedSheepTokens = {}
    transversedGoldBars = {}
    return
end

--will print a message to all plyaers, but not to the log
function gameNotification(msg, rgb, target_player)
    if target_player == nil then
        printToAll(msg, rgb)
    else
        if controlPanelSettings[target_player .. 'Hotseat'] ~= nil then
            target_player = controlPanelSettings[target_player .. 'Hotseat']
        end
        for _, player in ipairs(getSeatedPlayers()) do
            if player == target_player then
                broadcastToColor(msg, player, rgb)
            else
                printToColor(msg, player, rgb)
            end
        end
    end
end

--will print a message to all players, broadcasting to the target_player
--spectators will not receive this message if target_player is not nil
function allGameMessage(msg, rgb, target_player)
    if target_player == nil then
        printToAll(msg, rgb)
    else
        if controlPanelSettings[target_player .. 'Hotseat'] ~= nil then
            target_player = controlPanelSettings[target_player .. 'Hotseat']
        end
        for _, player in ipairs(getSeatedPlayers()) do
            if player == target_player then
                broadcastToColor(msg, player, rgb)
            else
                printToColor(msg, player, rgb)
            end
        end
    end
    -- local params = {}
    -- notes = getNotebookTabs()
    --
    -- params.index = gameLogTabIndex
    -- params.body = notes[gameLogTabIndex].body .. "\n" .. msg
    -- editNotebookTab(params)
end

--will print an error message to all players
function allErrorMessage(msg, target_player)
    if target_player == nil then
        broadcastToAll(msg, ERROR_COLOR)
    else
        if controlPanelSettings[target_player .. 'Hotseat'] ~= nil then
            target_player = controlPanelSettings[target_player .. 'Hotseat']
        end
        for _, player in ipairs(getSeatedPlayers()) do
            if player == target_player then
                broadcastToColor(msg, player, ERROR_COLOR)
            else
                printToColor(msg, player, ERROR_COLOR)
            end
        end
    end
end

--will print an error message to the target player
function playerErrorMessage(msg, target_player)
    local target_player_owner = nil
    if controlPanelSettings[target_player .. 'Hotseat'] ~= nil then
        target_player_owner = controlPanelSettings[target_player .. 'Hotseat']
    end
    if target_player_owner == nil then target_player_owner = target_player end
    if Player[target_player_owner].seated then
        broadcastToColor(msg, target_player_owner, ERROR_COLOR)
    else
        broadcastToColor("You are seated in another player's hotseat and cannot play.", target_player, ERROR_COLOR)
    end
end

--will print the message if the debug level is high enough
function debugMessage(level, msg)
    if debugMode >= level then
        -- local params = {}
        -- notes = getNotebookTabs()
        --
        -- params.index = debugLogTabIndex
        -- params.body = notes[debugLogTabIndex].body .. "\n" .. msg
        -- editNotebookTab(params)
        print(msg)
    end
end

--will return a string in the form of bracketed hex codes (ie. [ffffff] for white) when passed the string name of the color
function stringToBracketedHex(color)
    return RGBToBracketedHex(stringColorToRGB(color))
end

--returns the bracketed hex color code for a color, which can be used to add colors to strings (ie. [ffffff] for white). input table must include correct rgb tags to work
function RGBToBracketedHex(rgb)
    if rgb ~= nil then
        return "[" .. string.format("%02x%02x%02x", rgb.r*255,rgb.g*255,rgb.b*255) .. "]"
    else
        return ""
    end
end

--perform takeObject only if the object exists in the container
function takeObjectSafe(container, params)
    if params.guid ~= nil then
        for _, item in pairs(container.getObjects()) do
            if item.guid == params.guid then
                return container.takeObject(params)
            end
        end
    else
        return container.takeObject(params)
    end
    printToAll("Warning: Object " .. params.guid .. " not found in container. It may have already been removed.", ERROR_COLOR)
end

--true if element is one of the elements of the table, otherwise false
--if element is a table, then checks if an identical table is in the table
function table.contains(table, element)
    if type(element) == 'table' then
        for _, subtable in pairs(table) do
            local allMatch = true
            for key, value in pairs(subtable) do
                if value ~= element[key] then
                    allMatch = false
                end
            end
            if allMatch then return true end
        end
    else
        for _, value in pairs(table) do
            if value == element then
                return true
            end
        end
    end
    return false
end

--waits for the specified number of seconds. Can only be run from a coroutine
function wait(time)
  local start = os.time()
  repeat coroutine.yield(0) until os.time() > start + time
end

--isWithinErrorMargin
-- params:
--  float: number (to be compared)
--  float: targetNumber (to be compared to)
--  float: errorMargin
-- returns:
--  bool: true if number is within errorMargin of targetNumber
function isWithinErrorMargin(number, targetNumber, errorMargin)
    if number > targetNumber - errorMargin and number < targetNumber + errorMargin then return true
    else return false
    end
end