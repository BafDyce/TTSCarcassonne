-- Carcassonne and all expansions w/ automated scripting
-- Scripting by Sancho
-- The rules are based on the contents of Carcassonne Annotated Rules (CAR) v7.4.

--Tile Script Info
-- Each tile should have a script including variables needed to represent the information on the tile. The data format is as follows:
-- *In all examples, the "starting piece" is used*
-- *It should be noted that the "top" and "topleft" is from the perspective of the white player. All of the tiles are, in actuality, rotated ky 180 degrees, which is taken into account in code with TILE_STANDARD_ROTATION
-- Data Format:
--  sides - table of strings ( ie. {'City', 'Road', 'Field', 'Road'} ) Specifies the feature on each side of the tile, starting from the "top" clockwise (top is arbitrary, but must be consistent amoung pieces)
--             features: 'City', 'Road', 'Field', 'River', 'Abbey'
--  (optional) linkedQuadrants - table of tables of ints ( ie. {{2, 4}} ) Each table specifies which features are linked together, starting from the "top" at 1 and increasing clockwise.
--             This only applies for features that take the middle of the side (ie. roads, rivers)
--             In the example, the right side is linked to the left side (the road)
--  (optional) linkedOctants - table of tables of ints ( ie. {{5, 6}, {7, 12}, {8, 9, 10, 11}} ) Each table specifies which half of each quadrant is linked to others, starting from the "topleft" at 5 and increasing clockwise.
--             This is necessary for fields and cities, in particular, since both halves of a quadrant aren't always linked to each other.
--             Also, this specifies how the fields on each half of a road feature are linked to other fields. Therefore, each road quadrant may also have 2 corresponding octants specified for that same side.
--             In the example, the topleft and topright octants are linked
--                             the righttop and lefttop octants are linked (This is the field on the top half of the road)
--                             the rightbottom, bottomright, bottomleft, and leftbottom octants are linked (this is the field on the bottom half of the road)
--  (optional) specialFeatures - table of tables containing a string (which specifies the feature), (optional) table of ints, and (optional) table of exactly 2 floats ( ie. {{'City-Field', {5, 6, 7, 12}, nil}} )
--             The table of ints specifies what quadrants or octants this feature is linked to (if any).
--             The table of floats specifies the relative x and z coordinates of the feature on this piece (if a figure can be placed on the feature).
--             features:
--                  Base features ('City', 'Road', 'Field', 'Abbey') - this allows for additional locations for specifying the base features.
--                       this is useful for defining additional snap points, as well as allowing features which aren't connected to any quadrant or octant (there are a few fields like this).
--                  'Cloister' = cloister - specifies the location of a cloister. Links are not used for this feature.
--                  'City-Field' = city-field link - if the cities specified are completed, they score points to the specified fields. Multiple different cities and fields specified
--                             are NOT linked to each other, only fields are linked to cities (and vice versa, in the case of using old rules (TODO: implement later?). Coordinates are not used for this feature.
--                  'Road Intersection' = links roads to each other or other features. This is used for wagons.
--                  Linked Features with no coordinates: 'Coat of Arms', 'Inn', 'Cathedral', 'Princess'
--                  Unlinked Features of the tile: 'Volcano', 'Dragon', 'Hill'
--                  'Garden' - specifies the location of a garden. Links are not used for this feature.

DEBUG_BUTTONS = false
debugMode = 0
--debugLogTabIndex = -1

AUTOLOCK = true

TILE_POSITION_MARGIN = 0.02
TILE_ROTATION_MARGIN = 0.015
TILE_SPACING = 1.59 --how far apart tiles or spaced (should be the same as the tile grid setting)
TILE_THICKNESS = 0.005 --about how much thicker each tile makes a stack when added (keep in mind this is probably not as thick as the tile actually is on its own)
TILE_STANDARD_ROTATION = 2 --every tile is rotated this much so that the perceived rotation of the tiles matches the actual rotation in the code
TILE_180_ROTATION = 2

MIDDLE_LOCATION = {x = 0.795, z = -0.795}
--HACK: TTS cannot save table variables with negative indexes. Adding this arbitrary value to offset the middle ensures that all grid positions are positive (unless another table is used)
MIDDLE_OFFSET = {x = 25 * TILE_SPACING, z = 25 * TILE_SPACING}
TABLE_SURFACE_Y = 1.03171348571777

SIDE_DELTA = {{x=0,z=-1},{x=-1,z=0},{x=0,z=1},{x=1,z=0}}
FLIER_OFFSET = {{x=-1,z=1},{x=0,z=1},{x=1,z=1},{x=1,z=0},{x=1,z=-1},{x=0,z=-1},{x=-1,z=-1},{x=-1,z=0}}

NEUTRAL_ITEMS_LOCATION = {x = 15.5, y = 1.5, z = 28.0}

NEUTRAL_COLOR = {r=0.5, g=0.5, b=0.5}
ERROR_COLOR = {r=1, g=0, b=0}

PLAYER_COLORS = {'Green', 'Purple', 'White', 'Blue', 'Red', 'Pink'}
player_color_tints = {}

--The following figure definitions were specified in the CAR (Carcassonne Annoted Rules).
--Although not all figures have the same properties, their relative similarities may simpify code
FOLLOWER_TYPES = {'Follower', 'Big Follower', 'Phantom', 'Abbot', 'Mayor', 'Wagon'}
SPECIAL_FIGURE_TYPES = {'Shepherd', 'Builder', 'Pig', 'Barn'}
NEUTRAL_FIGURE_TYPES = {'Count', 'Dragon', 'Fairy', 'Tower Block'}

SHEEP_TOKEN_TYPES = {'Sheep', 'Wolf'}
TRADE_TOKEN_TYPES = {'Wine Token', 'Wheat Token', 'Cloth Token'}
TRADE_TOKEN_COUNTS = {
    ['Wine Token'] = 9,
    ['Wheat Token'] = 6,
    ['Cloth Token'] = 5
}
GOLD_BAR_NAME = 'Gold Bar'

score_counter_guids = {
    ['Green'] = '28bdff',
    ['Pink'] = '7ef326',
    ['Purple'] = 'f206e4',
    ['Blue'] = '9d1e70',
    ['Red'] = '4e3519',
    ['White'] = '1ecf3f'
}

arbitraryButtonAnchors = {}

FLOATING_BUTTON_HEIGHT = 2.0
FLOATING_BUTTON_HEIGHT_LOW = 1.0

FLOATING_BUTTON_Y_SCALE = 20
FLOATING_BUTTON_Z_SCALE = 2

FIGURE_DISTANCE_FROM_EDGE = 0.1 --percentage distance from the edge that each quadrant/octant exists

FIGURE_RETURN_DELAY = 0.5 --seconds to wait while returning a figure in order to prevent double-scoring
FIGURE_PRAISE_DELAY = 2.5 --seconds to wait while figure is spinning before it is returned

FRAME_TIME = 0.01667 --time that coroutine can run before it should yield to the main thread. Approx 60FPS

tileStack_GUID = '16d9db'
startingTile_GUID = 'c107f0'
startingRiverTile_GUID = nil
forkTile_GUID = nil
springTile_GUID = nil
lakeTile_GUID = nil
riverBodyTiles_GUID = nil
finalTile_GUID = nil

PLAY_AREA_SCRIPTING_ZONE_GUID = '799064'

figurepad_GUIDs = {
    ['Green'] = 'cee9ef',
    ['Purple'] = '7b6639',
    ['White'] = 'b013fc',
    ['Blue'] = '37df2f',
    ['Red'] = '4a5985',
    ['Pink'] = '7ed1bb'
}

handColor = {
    ['Green'] = 'Green',
    ['Purple'] = 'Purple',
    ['White'] = 'White',
    ['Blue'] = 'Blue',
    ['Red'] = 'Red',
    ['Pink'] = 'Pink'
}

figurePositions = {}

player_possession_areas = {
    ['Green'] = {x=25, z=12.04, rotation=3},
    ['Purple'] = {x=25, z=-12.1, rotation=3},
    ['White'] = {x=12.07, z=-25.0, rotation=2},
    ['Blue'] = {x=-12.1, z=-25.0, rotation=2},
    ['Red'] = {x=-24.96, z=-12.08, rotation=1},
    ['Pink'] = {x=-24.96, z=12.12, rotation=1}
}
playerPossessionScriptingZones = {}

PLAYER_POSSESSION_ZONE_HEIGHT = 2.5
PLAYER_POSSESSION_ZONE_DEPTH = 6.6
PLAYER_POSSESSION_ZONE_WIDTH = 18.4

-- Guid for object we will put button on
BUTTON_BOARD_GUID = '2b44bf'

showMarkers = 'Both'
showMarkersButtonParam = {
    index = 0, label = 'Show\nMarkers:\n' .. showMarkers, click_function = 'showMarkersToggleButton',
    position = {-0.8,0.1,0.0}, width = 750, height=600, font_size = 150, function_owner = nil
}

endGameButtonParam = {
    index = 1, label = 'Start\nGame', click_function = 'gameToggleButton',
    position = {1.0, 0.1, 0.0}, width = 750, height=600, font_size = 150, function_owner = nil
}

skipTurnButtonParam = {
   index = 2, label = 'Skip\nTurn', click_function = 'skipTurnButton',
   position = {2.8, 0.1, 0.0}, width = 750, height=600, font_size = 150, function_owner = nil
}

debugButtonParam = {
   index = 3, label = 'Debug mode:\n' .. debugMode, click_function = 'switchDebugLevel',
   position = {-0.8, 0.1, 1.6}, width = 1000, height=500, font_size = 150, function_owner = nil
}

showTransversalParam = {
   index = 4, label = 'Show\nTransversal', click_function = 'debugShowTransversal',
   position = {1.5, 0.1, 1.6}, width = 1000, height=500, font_size = 150, function_owner = nil
}

showFeatureMapParam = {
   index = 5, label = 'Show\nFeature\nMap', click_function = 'debugShowFeatureMap',
   position = {3.8, 0.1, 1.6}, width = 1000, height=500, font_size = 150, function_owner = nil
}

expansionBags = {
    ['InC'] = {guid = '95eb56', contents = {
        ['InCTiles'] = {guid = '122dff'}
        -- ['InCBigFollower'] = {guid = 'e5ec48', contents =
        --     {['Green'] = {guid = 'd9ab61'}, ['Purple'] = {guid = '62c526'}, ['White'] = {guid = '85ef73'}, ['Blue'] = {guid = 'f741b3'}, ['Red'] = {guid = 'ac3616'}, ['Yellow'] = {guid = '2456df'}}
        -- }
    }},
    ['TnB'] = {guid = '09fab1', contents = {
        ['TnBTiles'] = {guid = 'a88997'},
        -- ['TnBBuilder'] = {guid = 'a3aea6', contents =
        --     {['Green'] = {guid = '61cb95'}, ['Purple'] = {guid = '4ea21e'}, ['White'] = {guid = 'e11ef8'}, ['Blue'] = {guid = '128a06'}, ['Red'] = {guid = 'b12bcc'}, ['Yellow'] = {guid = '967ed5'}}
        -- },
        -- ['TnBPig'] = {guid = 'a3aea6', contents =
        --     {['Green'] = {guid = 'a180e1'}, ['Purple'] = {guid = '3f96a3'}, ['White'] = {guid = '2eb691'}, ['Blue'] = {guid = '8f7df7'}, ['Red'] = {guid = 'cc6164'}, ['Yellow'] = {guid = '26c485'}}
        -- },
        ['TnBClothTokenStack'] = {guid = 'ebd019'},
        ['TnBWineTokenStack'] = {guid = '55a94f'},
        ['TnBWheatTokenStack'] = {guid = '7a829b'}
    }},
    ['PnD'] = {guid = '564958', contents = {
        ['PnDTiles'] = {guid = '89bb59'},
        ['PnDDragon'] = {guid = 'e191ec'},
        ['PnDFairy'] = {guid = '46278a'}
    }},
    ['Tower'] = {guid = 'd59a8b', contents = {}},
    ['AnM'] = {guid = '9295b3', contents = {
        ['AnMTiles'] = {guid = '44e318'},
        ['AnMAbbey'] = {guid = '7e2126'},
        ['AnMMayor'] = {guid = '3cee76'},
        ['AnMWagon'] = {guid = 'e0467b'},
        ['AnMBarn'] = {guid = '306ca2'}
    }},
    ['CoC'] = {guid = 'd3189b', contents = {
        ['CoCCount'] = {guid = 'fba388'},
        ['CoCCarcassonneTiles'] = {guid = 'af8d39', contents = {
            [1] = {guid = '9c4fe7'},
            [2] = {guid = 'a6ff3c'},
            [3] = {guid = '9fd64f'},
            [4] = {guid = 'b0410c'},
            [5] = {guid = '78d5ee'},
            [6] = {guid = '8a1ed2'},
            [7] = {guid = 'a0ef6a'},
            [8] = {guid = '31cbd2'},
            [9] = {guid = '49a323'},
            [10] = {guid = '78a086'},
            [11] = {guid = '5cc6c2'},
            [12] = {guid = '233a1a'},
        }}
    }},
    ['KnRB'] = {guid = '927621', contents = {
        ['KnRBTiles'] = {guid = 'f5773a'},
        ['KnRBKing'] = {guid = 'c3021c'},
        ['KnRBRobber'] = {guid = '26c11d'}
    }},
    ['Cult'] = {guid = 'da553b', contents = {
        ['CultTiles'] = {guid = '96ff26'},
        ['CultBonusTile'] = {guid = '754953'}
    }},
    ['Flier'] = {guid = 'a50c26', contents = {
        ['FlierTiles'] = {guid = 'f006d5'},
        ['FlierDie'] = {guid = 'dc7bf3'}
    }},
    ['GamesQuarterly'] = {guid = 'c97cee', contents = {
        ['GamesQuarterlyTiles'] = {guid = '235648'},
        ['RiverSpringTile'] = {guid = '873113'},
        ['RiverBodyTiles'] = {guid = '2d5d36'}
    }},
    ['Goldmines'] = {guid = '080d67', contents = {
        ['GoldminesTiles'] = {guid = 'bc8fac'},
        ['GoldminesGold'] = {guid = 'd013b9'}
    }},
    ['HnS'] = {guid = 'a50c27', contents = {
        ['HnSTiles'] = {guid = '3fb950'},
        ['HnSSheepBag'] = {guid = '12bf5b'}
    }},
    ['River'] = {guid = '51fd29', contents = {
        ['RiverSpringTile'] = {guid = 'bec44f'},
        ['RiverLakeTile'] = {guid = 'f85830'},
        ['RiverBodyTiles'] = {guid = 'd5e587'},
    }},
    ['RiverII'] = {guid = '5a29f0', contents = {
        ['RiverForkTile'] = {guid = '5a8213'},
        ['RiverSpringTile'] = {guid = '0e6627'},
        ['RiverLakeTile'] = {guid = 'a423e8'},
        ['RiverBodyTiles'] = {guid = 'c6344e'},
    }},
    ['RiverBB5'] = {guid = '592f3a', contents = {
        ['RiverSpringTile'] = {guid = '553392'},
        ['RiverLakeTile'] = {guid = 'b9de5a'},
        ['RiverBodyTiles'] = {guid = 'e9d3b0'},
    }},
    ['SpielPromo'] = {guid = '1e48bf', contents = {
        ['SpielPromoTiles'] = {guid = '9129b0'}
    }},
    ['RussianPromo'] = {guid = 'bdeb95', contents = {
        ['RussianPromoTiles'] = {guid = 'd47ccc'}
    }}
}

controlPanelSettings = {
--Starting tiles
    ['StartingTileBase'] = true,
    ['StartingTileRiver'] = false,
    ['StartingTileRiverII'] = false,
    ['StartingTileRiverBB5'] = false,
    ['StartingTileCoC'] = false,
    ['StartingTileWoF'] = false,
    ['StartingTileSchool'] = false,
    ['StartingTileWindRoses'] = false,
--Base + Major expansions
    ['BaseTiles'] = true,
    ['BaseFollower'] = true,
    ['BaseNumFollowers'] = 7,
    ['BaseDisableRoads'] = false,
    ['BaseDisableCities'] = false,
    ['BaseDisableCloisters'] = false,
    ['BaseDisableFarms'] = false,
    ['BaseNerfSmallCity'] = false,
    ['InCTiles'] = false,
    ['InCBigFollower'] = false,
    ['InCInns'] = false,
    ['InCCathedrals'] = false,
    ['TnBTiles'] = false,
    ['TnBBuilder'] = false,
    ['TnBPig'] = false,
    ['TnBTradeGoods'] = false,
    ['PnDTiles'] = false,
    ['PnDDragon'] = false,
    ['PnDFairy'] = false,
    ['PnDMagicPortal'] = false,
    ['PnDPrincess'] = false,
    ['TowerTiles'] = false,
    ['TowerTowers'] = false,
    ['TowerNumTowers'] = 10,
    ['AnMTiles'] = false,
    ['AnMAbbey'] = false,
    ['AnMMayor'] = false,
    ['AnMWagon'] = false,
    ['AnMBarn'] = false,
    ['KnRBTiles'] = false,
    ['KnRBKing'] = false,
    ['KnRBRobber'] = false,
    ['CultTiles'] = false,
    ['RIIDisablePigherd'] = false,

    ['HnSTiles'] = false,
    ['HnSShepherd'] = false,
    ['HnSHills'] = false,
    ['HnSDoNotBuryHills'] = false,
    ['HnSVineyards'] = false,
--Mini expansions
    ['FlierTiles'] = false,
    ['FlierFlier'] = false,
    ['GoldminesTiles'] = false,
    ['GoldminesGold'] = false
}

--[<setting name>] = {[<expansion bag>] = {[<item name>] = {}}}
tileSettings = {
    ['InCTiles'] = {['InC'] = {['InCTiles'] = {}}},
    ['TnBTiles'] = {['TnB'] = {['TnBTiles'] = {}}},
    ['PnDTiles'] = {['PnD'] = {['PnDTiles'] = {}}},
    ['TowerTiles'] = {['Tower'] = {['TowerTiles'] = {}}},
    ['AnMTiles'] = {['AnM'] = {['AnMTiles'] = {}}},
    ['KnRBTiles'] = {['KnRB'] = {['KnRBTiles'] = {}}},
    ['CultTiles'] = {['Cult'] = {
            ['CultTiles'] = {},
            ['CultBonusTile'] = {}
        }
    },
    ['HnSTiles'] = {['HnS'] = {['HnSTiles'] = {}}},
    ['FlierTiles'] = {['Flier'] = {['FlierTiles'] = {}}},
    ['GamesQuarterlyTiles'] = {['GamesQuarterly'] = {['GamesQuarterlyTiles'] = {}}},
    ['GoldminesTiles'] = {['Goldmines'] = {['GoldminesTiles'] = {}}},
    ['SpielPromoTiles'] = {['SpielPromo'] = {['SpielPromoTiles'] = {}}},
    ['RussianPromoTiles'] = {['RussianPromo'] = {['RussianPromoTiles'] = {}}}
}

--[<setting name>] = {[<expansion bag>] = {[<item name>] = {position={<position on table>}, rotation={<rotation>}, shuffle=<should shuffle>, lock=<should lock>}}}
--will only use the first ForkTile, SpringTile, and LakeTile, prioritizing GamesQuarterly over RiverII over BB5 River over the original River (CAR ref 237)
startingTileSettings = {
    ['GamesQuarterlyTiles'] = {['GamesQuarterly'] = {
        ['RiverSpringTile'] = {position = {x=-2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['RiverBodyTiles'] = {position = {x=2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=180}, shuffle = true, lock = false},
    }},
    ['StartingTileRiverII'] = {['RiverII'] = {
        ['RiverForkTile'] = {position = {x=-3.975, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['RiverSpringTile'] = {position = {x=-2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['RiverLakeTile'] = {position = {x=-0.795, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['RiverBodyTiles'] = {position = {x=2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=180}, shuffle = true, lock = false},
    }},
    ['StartingTileRiverBB5'] = {['RiverBB5'] = {
        ['RiverSpringTile'] = {position = {x=-2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['RiverLakeTile'] = {position = {x=-0.795, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['RiverBodyTiles'] = {position = {x=2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=180}, shuffle = true, lock = false},
    }},
    ['StartingTileRiver'] = {['River'] = {
        ['RiverSpringTile'] = {position = {x=-2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['RiverLakeTile'] = {position = {x=-0.795, y=2.32, z=15.105}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = false},
        ['RiverBodyTiles'] = {position = {x=2.385, y=2.32, z=15.105}, rotation = {x=0,y=180,z=180}, shuffle = true, lock = false},
    }},
    ['StartingTileCoC'] = {
        ['CoC'] = {
            ['CoCCarcassonneTiles'] = {position = {x=-0.795, y=2.32, z=11.925}, rotation = {x=0,y=180,z=180}, shuffle = false, lock = false, contents = {
                [1] = {position = {x=-2.385, y=2.0, z=0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [2] = {position = {x=-0.795, y=2.0, z=0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [3] = {position = {x=0.795, y=2.0, z=0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [4] = {position = {x=2.385, y=2.0, z=0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [5] = {position = {x=-2.385, y=2.0, z=-0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [6] = {position = {x=-0.795, y=2.0, z=-0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [7] = {position = {x=0.795, y=2.0, z=-0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [8] = {position = {x=2.385, y=2.0, z=-0.795}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [9] = {position = {x=-2.385, y=2.0, z=-2.385}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [10] = {position = {x=-0.795, y=2.0, z=-2.385}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [11] = {position = {x=0.795, y=2.0, z=-2.385}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
                [12] = {position = {x=2.385, y=2.0, z=-2.385}, rotation = {x=0,y=180,z=0}, shuffle = false, lock = true, addToGrid = true},
            }}
        }
    }
}

--[<setting name>] = {name = <display name>, mesh = <model file>, diffuse = <diffuse file>, offset = {x=<x offset>, z=<z offset>}, scale = {<model scale>}, use_snap_points=<use snap points>, num=<setting with number to spawn>}
figureSettings = {
    ['BaseFollower'] = {name = 'Follower', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXS19OU3N4cDdCS2c', diffuse = 'http://i.imgur.com/s2rhBCd.jpg', offset = {x = 5.15, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true, num = 'BaseNumFollowers'},
    ['InCBigFollower'] = {name = 'Big Follower', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXS19OU3N4cDdCS2c', diffuse = 'http://i.imgur.com/s2rhBCd.jpg', offset = {x = -0.8, z = 0.5}, scale = {0.6, 0.6, 0.5}, use_snap_points = true},
    ['TnBBuilder'] = {name = 'Builder', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXcXJzc0NCaXVHaUk', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -0.8, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true}, --should probably be closer to {0.5, 0.42, 0.5}
    ['TnBPig'] = {name = 'Pig', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXRllCMGF3aDNQX00', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -2.25, z = 0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true}, --should probably be closer to {0.45, 0.5, 0.5}
    ['AnMMayor'] = {name = 'Mayor', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXQ09DaUZ5cThGS0E', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -2.25, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true},
    ['AnMWagon'] = {name = 'Wagon', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXOTNZT2NNVk02STQ', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -3.7, z = 0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true},
    ['AnMBarn'] = {name = 'Barn', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXZjNhXzZPUGo1RDg', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -3.7, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = false},
    ['HnSShepherd'] = {name = 'Shepherd', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXbjJHZXIwc1U2VTg', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -5.15, z = 0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true},
    ['CIIAbbot'] = {name = 'Abbot', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXQ2M4NkxxQ2JGRFE', diffuse = 'http://i.imgur.com/6xSYszt.jpg', offset = {x = -5.15, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true}
}

--[<steam_id>] = {['Intro'] = <intro string>, [<figure name>] = {<custom figure settings>}}
vipFigureSettings = {
    -- ['76561197962338210'] = {
    --     ['Intro'] = "You are being joined by %s, the creator of Scripted Carcassonne."
    -- },
    -- ['76561197972020303'] = {
    --     ['Intro'] = "You are being joined by %s, contributor to the Carcassonne mod."
    -- },
    ['9999999999999999999'] = {
        ['Intro'] = "You are being joined by %s, the TTS Carcassonne Tournament champion. All hail the king!",
        ['BaseFollower'] = {name = 'Follower', mesh = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXdmtGZ1lzZ085RFE', diffuse = 'http://i.imgur.com/s2rhBCd.jpg', offset = {x = 5.15, z = -0.5}, scale = {0.5, 0.5, 0.5}, use_snap_points = true, num = 'BaseNumFollowers'},
    }
}

--[<setting name>] = {[<expansion bag>] = {[<item name>] = {width = <width of object>}}}
neutralFigureSettings = {
    ['TnBTradeGoods'] = {['TnB'] = {
            ['TnBClothTokenStack'] = {width = 1.0},
            ['TnBWineTokenStack'] = {width = 1.0},
            ['TnBWheatTokenStack'] = {width = 1.0}
        }
    },
    ['KnRBKing'] = {['KnRB'] = {['KnRBKing'] = {width = 2.0}}},
    ['KnRBRobber'] = {['KnRB'] = {['KnRBRobber'] = {width = 2.0}}},
    ['HnSShepherd'] = {['HnS'] = {['HnSSheepBag'] = {width = 1.5}}},
    ['PnDFairy'] = {['PnD'] = {['PnDFairy'] = {width = 1.0}}},
    ['PnDDragon'] = {['PnD'] = {['PnDDragon'] = {width = 2.0}}},
    ['FlierFlier'] = {['Flier'] = {['FlierDie'] = {width = 1.0}}},
    ['GoldminesGold'] = {['Goldmines'] = {['GoldminesGold'] = {width = 1.5}}}
}

tileGrid = {[25]={[25]={tile_guid=startingTile_GUID, rotation=2}}}
lastPlacedTileX = nil
lastPlacedTileZ = nil

featureMap = {}
featureIndex = 1
featureList = {}

droplock = false
spamLock = false
scoring = false
gameover = true

wagonLocations = {}
hasAvailableWagonFeature = {}
--used when the player order must be transversed within someone's turn
currentMiniTurn = nil

transversedGrid = {}
transversedFeaturePositions = {}
transversedTileCoords = {}
transversedSpecialFeatures = {}
transversedFollowers = {}
transversedSpecialFigures = {}
transversedSheepTokens = {}
transversedGoldBars = {}

followersScored = {}
removedFigures = {}
featureMarkers = {}
scoringRewards = {}

largestCity = 0
longestRoad = 0
scoreSummary = {}
activePlayers = {}
currentPlayer = nil

shepherdAwaitingAction = nil
newBarn = nil
hasBuilderAwaitingAction = false
hasAlreadyTakenBuilderTile = false
buriedTile = nil
dragonHasAwaken = false
dragonMoveNumber = 1
dragonIllegalTiles = {}
tileHasVolcano = false
tileHasMagicPortal = false
flier = nil
flierOffset = nil
seducedKnights = {}

turnState = nil

stateMachine = {
    ['begin turn'] = {
        ['next'] = 'reward fairy'
    },
    ['reward fairy'] = {
        ['next'] = 'eliminate oldest flea'
    },
    ['eliminate oldest flea'] = {
        ['next'] = 'awaiting tile placement'
    },
    ['awaiting tile placement'] = {
        ['tile placed'] = 'check added tile features',
    },
    ['check added tile features'] = {
        ['next'] = 'check added tile feature - hill'
    },
    ['check added tile feature - hill'] = {
        ['next'] = 'check added tile feature - volcano'
    },
    ['check added tile feature - volcano'] = {
        ['next'] = 'check added tile feature - magic portal',
        ['dragon moved'] = 'check added tile feature - volcano - delay'
    },
    ['check added tile feature - volcano - delay'] = {
        ['next'] = 'check added tile feature - volcano - lock'
    },
    ['check added tile feature - volcano - lock'] = {
        ['next'] = 'check added tile feature - magic portal'
    },
    ['check added tile feature - magic portal'] = {
        ['next'] = 'check added tile feature - gold'
    },
    ['check added tile feature - gold'] = {
        ['next'] = 'check added tile feature extensions',
        ['has gold'] = 'place gold on tile'
    },
    ['place gold on tile'] = {
        ['next'] = 'awaiting gold placement'
    },
    ['awaiting gold placement'] = {
        ['next'] = 'check added tile feature extensions'
    },
    ['check added tile feature extensions'] = {
        ['next'] = 'awaiting figure decision'
    },
    ['awaiting figure decision'] = {
        ['skip figure'] = 'post figure events',
        ['retrieve abbot'] = 'retrieve abbot',
        ['placed figure'] = 'post figure events',
        ['placed shepherd'] = 'initialize shepherd',
        ['placed flier'] = 'wait for flier roll',
        ['placed fairy'] = 'post figure events',
        ['seduce knight'] = 'seduce knight'
    },
    ['retrieve abbot'] = {
        ['figures returned'] = 'retrieve abbot - delay'
    },
    ['retrieve abbot - delay'] = {
        ['next'] = 'post figure events'
    },
    ['wait for flier roll'] = {
        ['die rolled'] = 'check flier destination'
    },
    ['check flier destination'] = {
        ['feature available'] = 'awaiting flier decision',
        ['feature unavailable'] = 'return flier'
    },
    ['awaiting flier decision'] = {
        ['placed flier'] = 'post figure events'
    },
    ['return flier'] = {
        ['figures returned'] = 'return flier - delay'
    },
    ['return flier - delay'] = {
        ['next'] = 'post figure events'
    },
    ['seduce knight'] = {
        ['figures returned'] = 'seduce knight - delay'
    },
    ['seduce knight - delay'] = {
        ['next'] = 'post figure events'
    },
    ['post figure events'] = {
        ['next'] = 'post figure event - prompt shepherd'
    },
    ['post figure event - prompt shepherd'] = {
        ['next'] = 'check added tile feature - dragon'
    },
    ['initialize shepherd'] = {
        ['next'] = 'initialize shepherd - finish'
    },
    ['initialize shepherd - finish'] = {
        ['next'] = 'post figure events'
    },
    ['check added tile feature - dragon'] = {
        ['has dragon'] = 'post figure event - dragon movement',
        ['no dragon'] = 'score features'
    },
    ['post figure event - dragon movement'] = {
        ['next'] = 'score features',
        ['figures returned'] = 'post figure event - dragon movement - delay',
        ['dragon moved'] = 'post figure event - dragon movement - delay'
    },
    ['post figure event - dragon movement - delay'] = {
        ['next'] = 'post figure event - dragon movement - lock'
    },
    ['post figure event - dragon movement - lock'] = {
        ['next'] = 'post figure event - dragon movement'
    },
    ['score features'] = {
        ['next'] = 'post scoring events',
        ['figures returned'] = 'score features - delay'
    },
    ['score features - delay'] = {
        ['next'] = 'score features',
    },
    ['post scoring events'] = {
        ['next'] = 'reward gold'
    },
    ['reward gold'] = {
        ['next'] = 'replace finished wagons'
    },
    ['replace finished wagons'] = {
        ['next'] = 'check for extra builder turn',
    },
    ['check for extra builder turn'] = {
        ['has builder'] = 'awaiting tile placement',
        ['no builder'] = 'end turn'
    },
    ['end turn'] = {
        ['next'] = 'begin turn'
    },
    ['game over'] = {
        ['next'] = 'game over',
        ['figures returned'] = 'game over - delay'
    },
    ['game over - delay'] = {
        ['next'] = 'game over',
    }
}

function stateHandler()
    if turnState == nil then
        --game hasn't started yet. This should never happen.
        return
    end
    if controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] ~= nil and controlPanelSettings[activePlayers[currentPlayer] .. 'Control']:sub(1,2) == 'AI' then
        return AIStateHandler()
    end
    --debugMessage(1, "stateHandler - " .. turnState)
    if turnState == 'begin turn' then
        hasAlreadyTakenBuilderTile = false
        wagonLocations = {}
        hasAvailableWagonFeature = {}
        newBarn = nil
        lastPlacedTileX = nil
        return nextState('next')
    elseif turnState == 'reward fairy' then
        return rewardFairy()
    elseif turnState == 'eliminate oldest flea' then
        return nextState('next')
    elseif turnState == 'awaiting tile placement' then
        if controlPanelSettings['StartingTileRiverII'] or controlPanelSettings['StartingTileRiver'] or controlPanelSettings['StartingTileRiverBB5'] then
            if forkTile_GUID == nil and riverBodyTiles_GUID == nil and (getObjectFromGUID(tileStack_GUID) == nil or finalTile_GUID == nil) and springTile_GUID == nil and lakeTile_GUID == nil then
                local tileStack = getObjectFromGUID(tileStack_GUID)
                if tileStack ~= nil then
                    tileStack.setLock(false)
                    tileStack.interactable = true
                end
            end
        end
        return
    elseif turnState == 'check added tile features' then
        buriedTile = nil
        tileHasVolcano = false
        tileHasMagicPortal = false
        seducedKnights = {}
        currentPlayerAbbot = nil
        shepherdAwaitingAction = nil
        hasBuilderAwaitingAction = false
        return nextState('next')
    elseif turnState == 'check added tile feature - hill' then
        return checkTileForHill()
    elseif turnState == 'check added tile feature - volcano' then
        return checkTileForVolcano()
    elseif turnState == 'check added tile feature - volcano - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=2.00})
    elseif turnState == 'check added tile feature - volcano - lock' then
        getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid).setLock(true)
        return nextState('next')
    elseif turnState == 'check added tile feature - magic portal' then
        return checkTileForMagicPortal()
    elseif turnState == 'check added tile feature - gold' then
        return checkTileForGold()
    elseif turnState == 'place gold on tile' then
        return addGoldToTile(lastPlacedTileX, lastPlacedTileZ)
    elseif turnState == 'awaiting gold placement' then
        gameNotification("Choose a location to place the gold bar", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return displayGoldButtons()
    elseif turnState == 'check added tile feature extensions' then
        return checkAddedTileFeatureExtensions()
    elseif turnState == 'awaiting figure decision' then
        gameNotification("Place a figure if desired.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        local fairy = getObjectFromGUID(expansionBags['PnD'].contents['PnDFairy'].guid)
        if controlPanelSettings['PnDFairy'] and fairy ~= nil then
            fairy.setLock(false)
            fairy.highlightOn({1,1,1})
        end
        return displayFigureButtons()
    elseif turnState == 'retrieve abbot' then
        return
    elseif turnState == 'retrieve abbot - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'wait for flier roll' then
        clearFigureOptions()
        for i=1, 3 do
            local possibleOffset = {x=FLIER_OFFSET[flierDirection].x * i, z=FLIER_OFFSET[flierDirection].z * i}
            if tileGrid[lastPlacedTileX + possibleOffset.x] ~= nil and tileGrid[lastPlacedTileX + possibleOffset.x][lastPlacedTileZ + possibleOffset.z] ~= nil then
                local possibleTile = getObjectFromGUID(tileGrid[lastPlacedTileX + possibleOffset.x][lastPlacedTileZ + possibleOffset.z].tile_guid)
                if possibleTile ~= nil then
                    possibleTile.highlightOn({1,1,1})
                end
            end
        end
        clearArbitraryButtons()
        gameNotification("Roll the flier die to determine your flier's distance.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'check flier destination' then
        return checkFlierDestination()
    elseif turnState == 'awaiting flier decision' then
        for i=1, 3 do
            local possibleOffset = {x=FLIER_OFFSET[flierDirection].x * i, z=FLIER_OFFSET[flierDirection].z * i}
            if not (possibleOffset.x == flierOffset.x and possibleOffset.z == flierOffset.z) then
                if tileGrid[lastPlacedTileX + possibleOffset.x] ~= nil and tileGrid[lastPlacedTileX + possibleOffset.x][lastPlacedTileZ + possibleOffset.z] ~= nil then
                    local possibleTile = getObjectFromGUID(tileGrid[lastPlacedTileX + possibleOffset.x][lastPlacedTileZ + possibleOffset.z].tile_guid)
                    if possibleTile ~= nil then
                        possibleTile.highlightOff()
                    end
                end
            end
        end
        gameNotification("Place the flier on the destination tile.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'initialize shepherd' then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        if controlPanelSettings['PnDDragon'] then
            return addSheepToTile(shepherd)
        else
            return addSheepToField(shepherd)
        end
    elseif turnState == 'initialize shepherd - finish' then
        shepherdAwaitingAction = nil
        return nextState('next')
    elseif turnState == 'seduce knight' then
        return returnFigures()
    elseif turnState == 'seduce knight - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'return flier' then
        for i=1, 3 do
            local possibleOffset = {x=FLIER_OFFSET[flierDirection].x * i, z=FLIER_OFFSET[flierDirection].z * i}
            if tileGrid[lastPlacedTileX + possibleOffset.x] ~= nil and tileGrid[lastPlacedTileX + possibleOffset.x][lastPlacedTileZ + possibleOffset.z] ~= nil then
                local possibleTile = getObjectFromGUID(tileGrid[lastPlacedTileX + possibleOffset.x][lastPlacedTileZ + possibleOffset.z].tile_guid)
                if possibleTile ~= nil then
                    possibleTile.highlightOff()
                end
            end
        end
        return returnFigures()
    elseif turnState == 'return flier - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'post figure events' then
        clearFigureOptions()
        seducedKnights = {}
        currentPlayerAbbot = nil
        return nextState('next')
    elseif turnState == 'post figure event - prompt shepherd' then
        return promptShepherd()
    elseif turnState == 'check added tile feature - dragon' then
        shepherdAwaitingAction = nil
        return checkTileForDragon()
    elseif turnState == 'post figure event - dragon movement' then
        if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
        if dragonMoveNumber <= 6 then
            return createDragonButtons()
        else
            return nextState('next')
        end
    elseif turnState == 'post figure event - dragon movement - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=1.00})
    elseif turnState == 'post figure event - dragon movement - lock' then
        getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid).setLock(true)
        return nextState('next')
    elseif turnState == 'score features' then
        currentMiniTurn = nil
        for _, tileCoords in ipairs(dragonIllegalTiles) do
            getObjectFromGUID(tileGrid[tileCoords[1]][tileCoords[2]].tile_guid).highlightOff()
        end
        return scoreFeatures()
    elseif turnState == 'score features - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'post scoring events' then
        return nextState('next')
    elseif turnState == 'reward gold' then
        return rewardGold()
    elseif turnState == 'replace finished wagons' then
        return replaceFinishedWagons()
    elseif turnState == 'check for extra builder turn' then
        if hasBuilderAwaitingAction then
            hasAlreadyTakenBuilderTile = true
            allGameMessage(activePlayers[currentPlayer] .."'s builder has allowed them to draw another tile. Please do so, along with the usual actions, before ending your turn.", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
            return nextState('has builder')
        else
            return nextState('no builder')
        end
    elseif turnState == 'end turn' then
        return endTurn()
    elseif turnState == 'game over' then
        return scoreFeatures()
    elseif turnState == 'game over - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    end
end

function nextState(action)
    if stateMachine[turnState] ~= nil then
        if stateMachine[turnState][action] ~= nil then
            turnState = stateMachine[turnState][action]
            return stateHandler()
        else
            allErrorMessage("Error: action - " .. action .. " does not exist for current state - " .. turnState, activePlayers[currentPlayer])
        end
    else
        allErrorMessage("Error: current state does not exist - " .. turnState, activePlayers[currentPlayer])
    end
end

function progressState()
    return nextState('next')
end

function progressPartiallyCompleteStates()
    if turnState == 'score features' then
        allGameMessage("Loaded game was in the middle of scoring. Game pieces may need to be removed manually. Skipping to post scoring events. Some unscored pieces may remain.", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
        turnState = 'post scoring events'
    end
end

function onload(save_state)
    if save_state ~= nil then
        local saved_data = JSON.decode(save_state)
        if saved_data.showMarkers ~= nil then
            showMarkers = saved_data.showMarkers
            showMarkersButtonParam.label = 'Show\nMarkers:\n' .. showMarkers
        end
        if saved_data.tileGrid ~= nil then tileGrid = saved_data.tileGrid end
        if saved_data.startingTile_GUID ~= nil then startingTile_GUID = saved_data.startingTile_GUID end
        if saved_data.startingRiverTile_GUID ~= nil then startingRiverTile_GUID = saved_data.startingRiverTile_GUID end
        if saved_data.forkTile_GUID ~= nil then forkTile_GUID = saved_data.forkTile_GUID end
        if saved_data.springTile_GUID ~= nil then springTile_GUID = saved_data.springTile_GUID end
        if saved_data.lakeTile_GUID ~= nil then lakeTile_GUID = saved_data.lakeTile_GUID end
        if saved_data.riverBodyTiles_GUID ~= nil then riverBodyTiles_GUID = saved_data.riverBodyTiles_GUID end
        if saved_data.finalTile_GUID ~= nil then finalTile_GUID = saved_data.finalTile_GUID end
        if saved_data.lastPlacedTileX ~= nil then lastPlacedTileX = saved_data.lastPlacedTileX end
        if saved_data.lastPlacedTileZ ~= nil then lastPlacedTileZ = saved_data.lastPlacedTileZ end
        if saved_data.controlPanelSettings ~= nil then
            controlPanelSettings = saved_data.controlPanelSettings
        end
        if saved_data.scores ~= nil then
            for player, score in pairs(saved_data.scores) do
                local scoreCounter = getObjectFromGUID(score_counter_guids[player])
                if scoreCounter ~= nil then
                    scoreCounter.Counter.setValue(score)
                end
            end
        end
        if saved_data.figurePositions ~= nil then figurePositions = saved_data.figurePositions end
        if saved_data.gameover ~= nil then
            gameover = saved_data.gameover
            if not gameover then
                endGameButtonParam.label = 'End game\n(score\npoints)'
            end
        end
        if saved_data.activePlayers ~= nil then activePlayers = saved_data.activePlayers end
        if saved_data.currentPlayer ~= nil then currentPlayer = saved_data.currentPlayer end
        if saved_data.scoreSummary ~= nil then scoreSummary = saved_data.scoreSummary end
        if saved_data.largestCity ~= nil then largestCity = saved_data.largestCity end
        if saved_data.longestRoad ~= nil then longestRoad = saved_data.longestRoad end
        if saved_data.playerPossessionScriptingZones ~= nil then playerPossessionScriptingZones = saved_data.playerPossessionScriptingZones end
        if saved_data.player_color_tints ~= nil then player_color_tints = saved_data.player_color_tints end
        if saved_data.score_counter_guids ~= nil then score_counter_guids = saved_data.score_counter_guids end
        if saved_data.figurepad_GUIDs ~= nil then figurepad_GUIDs = saved_data.figurepad_GUIDs end
        if saved_data.handColor ~= nil then handColor = saved_data.handColor end
        if saved_data.player_possession_areas ~= nil then player_possession_areas = saved_data.player_possession_areas end
        if saved_data.turnState ~= nil then turnState = saved_data.turnState end
        if saved_data.wagonLocations ~= nil then wagonLocations = saved_data.wagonLocations end
        if saved_data.hasAvailableWagonFeature ~= nil then hasAvailableWagonFeature = saved_data.hasAvailableWagonFeature end
        if saved_data.currentMiniTurn ~= nil then currentMiniTurn = saved_data.currentMiniTurn end
        if saved_data.shepherdAwaitingAction ~= nil then shepherdAwaitingAction = saved_data.shepherdAwaitingAction end
        if saved_data.newBarn ~= nil then newBarn = saved_data.newBarn end
        if saved_data.hasBuilderAwaitingAction ~= nil then hasBuilderAwaitingAction = saved_data.hasBuilderAwaitingAction end
        if saved_data.hasAlreadyTakenBuilderTile ~= nil then hasAlreadyTakenBuilderTile = saved_data.hasAlreadyTakenBuilderTile end
        if saved_data.buriedTile ~= nil then buriedTile = saved_data.buriedTile end
        if saved_data.dragonHasAwaken ~= nil then dragonHasAwaken = saved_data.dragonHasAwaken end
        if saved_data.dragonMoveNumber ~= nil then dragonMoveNumber = saved_data.dragonMoveNumber end
        if saved_data.dragonIllegalTiles ~= nil then dragonIllegalTiles = saved_data.dragonIllegalTiles end
        if saved_data.tileHasVolcano ~= nil then tileHasVolcano = saved_data.tileHasVolcano end
        if saved_data.tileHasMagicPortal ~= nil then tileHasMagicPortal = saved_data.tileHasMagicPortal end
        if saved_data.removedFigures ~= nil then removedFigures = saved_data.removedFigures end
        if saved_data.featureMarker_GUIDs ~= nil then
            for _, featureMarker_GUID in ipairs(saved_data.featureMarker_GUIDs) do
                getObjectFromGUID(featureMarker_GUID).destruct()
            end
        end
        --featureMap data
        featureMap = saved_data.featureMap
        featureList = saved_data.featureList
        linkedFeatures = saved_data.linkedFeatures
        featureIndex = saved_data.featureIndex
    end

    local notes = getNotebookTabs()
    for _, note in ipairs(notes) do
        if note.title == "Debug Log" then
            debugLogTabIndex = note.index
            return
        end
    end
    -- params = {}
    -- params.title = "Debug Log"
    -- params.body = "LOG START"
    -- params.color = "Grey"
    -- debugLogTabIndex = addNotebookTab(params)
    buttonBoard = getObjectFromGUID(BUTTON_BOARD_GUID)
    buttonBoard.createButton(showMarkersButtonParam)
    buttonBoard.createButton(endGameButtonParam)
    buttonBoard.createButton(skipTurnButtonParam)
    if DEBUG_BUTTONS then
        buttonBoard.createButton(debugButtonParam)
        buttonBoard.createButton(showTransversalParam)
        buttonBoard.createButton(showFeatureMapParam)
    end

    if activePlayers ~= nil and currentPlayer ~= nil then
        if controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] == nil then
            allGameMessage("Game loaded. It is now " .. getPlayerOwnerName(activePlayers[currentPlayer]) .. "'s turn on state: " .. turnState .. ".", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
        else
            allGameMessage("Game loaded. It is now " .. activePlayers[currentPlayer] .. "'s turn on state: " .. turnState .. ".", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
            allGameMessage(activePlayers[currentPlayer] .. " is controlled by " .. stringToBracketedHex(controlPanelSettings[activePlayers[currentPlayer] .. 'Control']) .. getPlayerOwnerName(activePlayers[currentPlayer]), player_color_tints[activePlayers[currentPlayer]], nil)
        end
        allGameMessage("Please note that rewinds are not supported. You may need to clean some things up if the state was saved while the script was running.", NEUTRAL_COLOR)
    end
    progressPartiallyCompleteStates()
    return stateHandler()
end

function onSave()
    --retrieve scores
    local scores = {}
    for player, scoreCounter_GUID in pairs(score_counter_guids) do
        local scoreCounter = getObjectFromGUID(scoreCounter_GUID)
        if scoreCounter ~= nil then
            scores[player] = scoreCounter.Counter.getValue()
        end
    end
    local featureMarker_GUIDs = {}
    if featureMarkers ~= nil then
        for i, featureMarker in ipairs(featureMarkers) do
            featureMarker_GUIDs[i] = featureMarker.getGUID()
        end
    end
    local toSave = {
        showMarkers = showMarkers,
        tileGrid = tileGrid,
        startingTile_GUID = startingTile_GUID,
        startingRiverTile_GUID = startingRiverTile_GUID,
        forkTile_GUID = forkTile_GUID,
        springTile_GUID = springTile_GUID,
        lakeTile_GUID = lakeTile_GUID,
        riverBodyTiles_GUID = riverBodyTiles_GUID,
        finalTile_GUID = finalTile_GUID,
        lastPlacedTileX = lastPlacedTileX,
        lastPlacedTileZ = lastPlacedTileZ,
        controlPanelSettings = controlPanelSettings,
        scores = scores,
        figurePositions = figurePositions,
        gameover = gameover,
        activePlayers = activePlayers,
        currentPlayer = currentPlayer,
        scoreSummary = scoreSummary,
        largestCity = largestCity,
        longestRoad = longestRoad,
        playerPossessionScriptingZones = playerPossessionScriptingZones,
        --the following is only changed when using substitute colors
        player_color_tints = player_color_tints,
        score_counter_guids = score_counter_guids,
        figurepad_GUIDs = figurepad_GUIDs,
        handColor = handColor,
        player_possession_areas = player_possession_areas,
        --the following is partial turn data
        turnState = turnState,
        wagonLocations = wagonLocations,
        hasAvailableWagonFeature = hasAvailableWagonFeature,
        currentMiniTurn = currentMiniTurn,
        shepherdAwaitingAction = shepherdAwaitingAction,
        newBarn = newBarn,
        hasBuilderAwaitingAction = hasBuilderAwaitingAction,
        hasAlreadyTakenBuilderTile = hasAlreadyTakenBuilderTile,
        --the following is partial state data (for when a state doesn't completely finish)
        buriedTile = buriedTile,
        dragonHasAwaken = dragonHasAwaken,
        dragonIllegalTiles = dragonIllegalTiles,
        dragonMoveNumber = dragonMoveNumber,
        tileHasVolcano = tileHasVolcano,
        tileHasMagicPortal = tileHasMagicPortal,
        removedFigures = removedFigures,
        --if script was in the middle of making feature markers or deleting, delete them after loading
        featureMarker_GUIDs = featureMarker_GUIDs,
        --featureMap data
        featureMap = featureMap,
        featureList = featureList,
        linkedFeatures = linkedFeatures,
        featureIndex = featureIndex
    }
    return JSON.encode(toSave)
end

m_Routines = {}

--[[ The Update function. This is called once per frame. --]]
function update()
    --this replaces the built-in coroutine functions, since the built-in ones have the unfortunate side-effect that they continue to run after loading a game. These will not.
    local iNumRoutines = #m_Routines

    for i = iNumRoutines, 1, -1 do
        local sStatus = coroutine.status(m_Routines[i].Co)
        --resume all coroutines with yield 0
        if sStatus == 'suspended' and m_Routines[i].iYield == 0 then
            local bRes = false
            local iYield = 0

            bRes, iYield = coroutine.resume(m_Routines[i].Co) --resume the coroutine and save the value from yield (to allow to use e.g. yield(1) to not have it resumed automatically)

            iYield = iYield or 0 --default to 0 (-> both .yield() and .yield(0) works)
            m_Routines[i].iYield = iYield
        --clear finished routines
        elseif sStatus == 'dead' then
            table.remove(m_Routines, i)
        end
    end
end

function checkControlPanelPrivileges(player)
    if not gameover then
        broadcastToColor('Game has already started', player.sColor, NEUTRAL_COLOR)
        return false
    end
    local PPlayer = Player[player.sColor]
    if PPlayer ~= nil then
        if PPlayer.admin then
            return true
        else
            broadcastToColor('Only promoted players can use the control panel', player.sColor, ERROR_COLOR)
        end
    end
    return false
end

function checkAdminPrivileges(player)
    local PPlayer = Player[player]
    if PPlayer ~= nil then
        if PPlayer.admin then
            return true
        else
            broadcastToColor('Only promoted players can use this button', player, ERROR_COLOR)
        end
    end
    return false
end

function checkGameButtonPrivileges(player)
    local PPlayer = Player[player]
    if PPlayer ~= nil then
        if PPlayer.admin or
        (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
        (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            return true
        else
            broadcastToColor('Only the current player or promoted players can use this button', player, ERROR_COLOR)
        end
    end
    return false
end

function getControlPanelState(p)
    return controlPanelSettings[p.key]
end

function setControlPanelState(p)
    controlPanelSettings[p.key] = p.value
end

--rotates coordinates in steps of 90 degrees
function rotateCoordinates(x, z, rotation)
    if rotation == 1 then
        temp = x
        x = -z
        z = temp
    elseif rotation == 2 then
        x = -x
        z = -z
    elseif rotation == 3 then
        temp = x
        x = z
        z = -temp
    end
    return x, z
end

--rotates coordinates in degrees
function rotateCoordinatesDegrees(x, z, rotation)
    local rad_rotation = math.rad(rotation)
    local new_x = x * math.cos(rad_rotation) - z * math.sin(rad_rotation)
    local new_z = z * math.cos(rad_rotation) + x * math.sin(rad_rotation)
    return new_x, new_z
end

function cbSpawnUnlock()
    gSpawnLock = false
end

function onPlayerChangedColor(player)

end

function onPlayerTurnEnd(player_color_end, player_color_next )

end

function onObjectDestroyed(dying_object)
    --when the 2nd to last card in the deck is drawn, the deck is destroyed, even though one card remains
    --this causes an issue when a script needs to draw the last card and doesn't know where it is
    --this code is meant to work around that problem
    local rad = 0.01
    if dying_object.getGUID() == tileStack_GUID or dying_object.getGUID() == riverBodyTiles_GUID then
        if dying_object.getGUID() == riverBodyTiles_GUID then
            riverBodyTiles_GUID = nil
        end
        local allObjects = getAllObjects()
        for _, obj in ipairs(allObjects) do
            if tostring(obj) == 'Card(Clone) (LuaGameObjectScript)' then
                local dX = dying_object.getPosition().x - obj.getPosition().x
                local dZ = dying_object.getPosition().z - obj.getPosition().z
                if dX<rad and dX>-rad and dZ<rad and dZ>-rad then
                    if obj.held_by_color == nil and obj.getGUID() ~= lastDrawnTile_GUID then
                        finalTile_GUID = obj.getGUID()
                    end
                end
            end
        end
    end
end

function onFlierDiceRolled(params)
    if params.sPlayer ~= nil then
        player = params.sPlayer
        if (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
            (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            if turnState == 'wait for flier roll' then
                local dieValue = getObjectFromGUID(expansionBags['Flier'].contents['FlierDie'].guid).getValue()
                if dieValue > 3 then dieValue = 7 - dieValue end
                flierOffset = {x=FLIER_OFFSET[flierDirection].x * dieValue, z=FLIER_OFFSET[flierDirection].z * dieValue}
                --debugMessage(1, "Flier direction: " .. flierDirection .. " Flier destination offset: x: " .. flierOffset.x .. " z: " .. flierOffset.z)
                allGameMessage(activePlayers[currentPlayer] .. " rolled a " .. dieValue, player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
                return nextState('die rolled')
            else
                allErrorMessage("It is currently not allowed to roll the flier die. You are only allowed to roll the die after you've placed a follower on the flier feature. Current state: " .. turnState, params.sPlayer)
            end
        else
            playerErrorMessage("ERROR: It is not currently your turn OR you rolled the die without picking it up.", params.sPlayer)
        end
    end
end

function skipTurnButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        endTurn()
    end
end

function endTurn()
    if not gameover then
        --the following will detect that the game has finished and will not go to the next turn
        --local tileStack = getObjectFromGUID(tileStack_GUID)
        --if tileStack == nil and finalTile_GUID == nil then
        --    allGameMessage("The game is over. Calculate the final score by pressing the End Game button. (If this was unexpected, it could be because the tile stack was taken apart or manually stacked wrong)", NEUTRAL_COLOR)
        --else
            if lastPlacedTileX == nil or not (controlPanelSettings['PnDDragon'] and tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid == expansionBags['RiverII'].contents['RiverLakeTile'].guid) then
                currentPlayer = currentPlayer + 1
                if currentPlayer > #activePlayers then
                    currentPlayer = 1
                end
                if controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] == nil then
                    allGameMessage("-----------It is now " .. getPlayerOwnerName(activePlayers[currentPlayer]) .. "'s turn-----------", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
                else
                    allGameMessage("-----------It is now " .. activePlayers[currentPlayer] .. "'s turn-----------", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
                    allGameMessage("-------" .. activePlayers[currentPlayer] .. " is controlled by " .. stringToBracketedHex(controlPanelSettings[activePlayers[currentPlayer] .. 'Control']) .. getPlayerOwnerName(activePlayers[currentPlayer]) .. stringToBracketedHex(activePlayers[currentPlayer]) .. "------", player_color_tints[activePlayers[currentPlayer]], nil)
                end
            else
                allGameMessage(activePlayers[currentPlayer] .. " gets another turn for laying down the volcano lake tile.", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
            end
            turnState = 'begin turn' --in case skip turn was pressed, go to the beginning from every state
            return stateHandler()
        --end
    end
end

--if the current player is a hotseat player, return the owner
function getCurrentPlayerOwner()
    if currentPlayer == nil then return nil end
    local player
    if currentMiniTurn ~= nil and controlPanelSettings[activePlayers[currentMiniTurn] .. 'Control'] ~= nil then
        player = controlPanelSettings[activePlayers[currentMiniTurn] .. 'Control']
    end
    if currentMiniTurn == nil and controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] ~= nil then
        player = controlPanelSettings[activePlayers[currentPlayer] .. 'Control']
    end
    return player
end

function getPlayerOwner(player)
    if player == nil then return nil end
    local owner = player
    if currentMiniTurn ~= nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    if currentMiniTurn == nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    return owner
end

function getPlayerOwnerName(player)
    if player == nil then return nil end
    local owner = player
    if currentMiniTurn ~= nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    if currentMiniTurn == nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    if owner:sub(1,2) == 'AI' then
        return owner
    elseif Player[owner].steam_name == nil then
        return owner
    else
        return Player[owner].steam_name
    end
end

-- Activates when button is pressed
function showMarkersToggleButton(object, sPlayer)
    if checkAdminPrivileges(sPlayer) then
        -- Toggles between different showMarker modes
        if showMarkers == 'Scoring' then showMarkers = 'Hints'
        elseif showMarkers == 'Hints' then showMarkers = 'Both'
        elseif showMarkers == 'Both' then showMarkers = 'None'
        elseif showMarkers == 'None' then showMarkers = 'Scoring'
        end
        showMarkersButtonParam.label = 'Show\nMarkers:\n' .. showMarkers
        buttonBoard.editButton(showMarkersButtonParam)
    end
end

function gameToggleButton(object, sPlayer)
    if checkAdminPrivileges(sPlayer) then
        if gameover then
            local hasStartingTiles = false
            for controlPanelSetting, settingOn in pairs(controlPanelSettings) do
                if settingOn and table.contains({'StartingTileBase', 'StartingTileRiver', 'StartingTileRiverII', 'StartingTileRiverBB5', 'StartingTileCoC', 'StartingTileWoF', 'StartingTileSchool', 'StartingTileWindRoses'}, controlPanelSetting) then
                    hasStartingTiles = true
                end
            end
            if not hasStartingTiles then
                allErrorMessage("Cannot start a game without a starting tileset.", sPlayer)
                return
            end
            for _, player in ipairs(PLAYER_COLORS) do
                if controlPanelSettings[player .. 'Control'] ~= nil and controlPanelSettings[player .. 'Control']:sub(1,2) == 'AI' then
                    for controlPanelSetting, settingOn in pairs(controlPanelSettings) do
                        if settingOn and table.contains({'PnDDragon', 'AnMAbbey', 'AnMWagon', 'FlierFlier', 'GoldminesGold'}, controlPanelSetting) then
                            allErrorMessage("Cannot start an AI game with incompatible expansion: " .. controlPanelSetting .. ".", sPlayer)
                            return
                        end
                    end
                    break
                end
            end
            endGameButtonParam.label = 'End game\n(score\npoints)'
            startLuaCoroutine(self, 'startGame')
            --startGame()
        else
        endGameButtonParam.label = 'Score\nSummary'
            endGameButtonParam.click_function = 'printScoreSummary'
            endGame()
        end
        buttonBoard.editButton(endGameButtonParam)
    end
end

function startGame()
    clearCounters()
    local hasPlayer = false
    for _, player in ipairs(PLAYER_COLORS) do
        if Player[player].seated or controlPanelSettings[player .. 'Control'] ~= nil then
            hasPlayer = true
        end
    end
    if not hasPlayer then return 1 end
    for _, player in ipairs(PLAYER_COLORS) do
        --player_color_tints[player] = stringColorToRGB(player)
        --HACK: The above won't work because TTS has a bug where it won't save the variable correctly in onSave(). Omitting the numbered indexes seems to work around this
        player_color_tints[player] = {}
        player_color_tints[player]['r'] = stringColorToRGB(player)['r']
        player_color_tints[player]['g'] = stringColorToRGB(player)['g']
        player_color_tints[player]['b'] = stringColorToRGB(player)['b']
        if Player[player].seated or controlPanelSettings[player .. 'Control'] ~= nil then
            local playerPossessionArea = player_possession_areas[player]
            local params = {}
            params.rotation = {0.1,180,0.1}
            params.callback = "cbSpawnUnlock"  -- all the callback does is set gSpawnLock to false
            params.callback_owner = Global
            params.type = "ScriptingTrigger"
            local x, z = rotateCoordinates(3.2, 1.8, playerPossessionArea.rotation)
            params.position = {playerPossessionArea.x + x, TABLE_SURFACE_Y - 0.5 + PLAYER_POSSESSION_ZONE_HEIGHT / 2, playerPossessionArea.z + z}
            local x_scale, z_scale
            if playerPossessionArea.rotation % 2 == 0 then
                x_scale = PLAYER_POSSESSION_ZONE_WIDTH
                z_scale = PLAYER_POSSESSION_ZONE_DEPTH
            else
                x_scale = PLAYER_POSSESSION_ZONE_DEPTH
                z_scale = PLAYER_POSSESSION_ZONE_WIDTH
            end
            --params.scale = {x_scale, PLAYER_POSSESSION_ZONE_HEIGHT, z_scale}
            gSpawnLock = true
            local zoneObj = spawnObject(params)
            while gSpawnLock do
                coroutine.yield(0)
            end
            zoneObj.setName(player .. " possession zone")
            zoneObj.setScale({x_scale, PLAYER_POSSESSION_ZONE_HEIGHT, z_scale})
            local newColor = player
            coroutine.yield(0)
            local objs = zoneObj.getObjects()
            for _, obj in pairs(objs) do
                if obj.getName() == 'Follower' then
                    newColor = obj.getDescription()
                    --player_color_tints[newColor] = obj.getColorTint()
                    --HACK: The above won't work because TTS has a bug where it won't save the variable correctly in onSave(). Omitting the numbered indexes seems to work around this
                    player_color_tints[newColor] = {}
                    player_color_tints[newColor]['r'] = obj.getColorTint()['r']
                    player_color_tints[newColor]['g'] = obj.getColorTint()['g']
                    player_color_tints[newColor]['b'] = obj.getColorTint()['b']
                    allGameMessage(player .. " has substituted their color for " .. RGBToBracketedHex(player_color_tints[newColor]) .. newColor, player_color_tints[player])
                    break
                end
            end
            playerPossessionScriptingZones[player] = zoneObj.getGUID()
            if newColor ~= player then
                controllingPlayer = player
                if controlPanelSettings[controllingPlayer .. 'Control'] ~= nil then
                    controllingPlayer = controlPanelSettings[controllingPlayer .. 'Control']
                end
                controlPanelSettings[newColor .. 'Control'] = controllingPlayer
                score_counter_guids[newColor] = score_counter_guids[player]
                getObjectFromGUID(score_counter_guids[newColor]).setColorTint(player_color_tints[newColor])
                figurepad_GUIDs[newColor] = figurepad_GUIDs[player]
                player_possession_areas[newColor] = player_possession_areas[player]
                playerPossessionScriptingZones[newColor] = playerPossessionScriptingZones[player]
                handColor[newColor] = handColor[player]
            end
            table.insert(activePlayers, newColor)
            if Player[player].seated and vipFigureSettings[Player[player].steam_id] ~= nil and vipFigureSettings[Player[player].steam_id]['Intro'] ~= nil then
                allGameMessage(string.format(vipFigureSettings[Player[player].steam_id]['Intro'], Player[player].steam_name), NEUTRAL_COLOR)
            end
        end
    end
    for _, obj in ipairs(getAllObjects()) do
        if obj.getName() == 'Follower' or obj.getName() == 'Substitute Colors' then
            obj.destruct()
        end
    end
    currentPlayer = math.random(#activePlayers)
    preparePlayerPossessionAreaFinished = false
    prepareNeutralItemsFinished = false
    prepareStartingTilesFinished = false
    initializeScoreSummary()
    startLuaCoroutine(self, 'prepareTileStack')
    startLuaCoroutine(self, 'prepareStartingTiles')
    startLuaCoroutine(self, 'preparePlayerPossessionArea')
    startLuaCoroutine(self, 'prepareNeutralItems')
    return 1
end

function initializeScoreSummary()
    for _, player in pairs(activePlayers) do
        scoreSummary[player] = {}
        scoreSummary[player]['City'] = 0
        scoreSummary[player]['Road'] = 0
        scoreSummary[player]['Field'] = 0
        scoreSummary[player]['Cloister'] = 0
        if controlPanelSettings['TnBTradeGoods'] then
            scoreSummary[player]['Trade Goods'] = 0
        end
        if controlPanelSettings['HnSShepherd'] then
            scoreSummary[player]['Shepherd'] = 0
        end
        if controlPanelSettings['PnDFairy'] then
            scoreSummary[player]['Fairy'] = 0
        end
        if controlPanelSettings['KnRBKing'] or controlPanelSettings['KnRBRobber'] then
            scoreSummary[player]['King/Robber Tokens'] = 0
        end
        if controlPanelSettings['GoldminesGold'] then
            scoreSummary[player]['Gold'] = 0
        end
    end
end

function scorePoints(player, feature, points)
    if feature == 'Abbey' or feature == 'Shrine' or feature == 'Garden' or feature == "Baba Yaga's Hut" then feature = 'Cloister' end --these don't really need a seperate category
    if scoreSummary[player][feature] == nil then
        allErrorMessage("ERROR: " .. feature .. " is not valid. Please remove this figure.")
        return
    end
    scoreSummary[player][feature] = scoreSummary[player][feature] + points
    local scoreCounter = getObjectFromGUID(score_counter_guids[player])
    if scoreCounter ~= nil then
        scoreCounter.Counter.setValue(scoreCounter.Counter.getValue() + points)
    else
        allErrorMessage("Error adding score to " .. figure.getDescription() .. "'s counter")
    end
end

function printScoreSummary(object, sPlayer)
    printedPlayers = {}
    local playerNum = 1
    local rank = 1
    local lastHighscore = 0
    while true do
        local highscore = 0
        local color = nil
        for _, player in pairs(activePlayers) do
            local scoreCounter = getObjectFromGUID(score_counter_guids[player])
            if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                if scoreCounter.Counter.getValue() > highscore then
                    highscore = scoreCounter.Counter.getValue()
                    color = player
                end
            end
        end
        if highscore > 0 then
            if highscore < lastHighscore then rank = playerNum end
            local steam_name = ""
            if getPlayerOwner(color):sub(1,2) == 'AI' then
                steam_name = getPlayerOwner(color)
            elseif controlPanelSettings[color .. 'Control'] ~= nil then
                if Player[controlPanelSettings[color .. 'Control']].steam_name ~= nil then steam_name = Player[controlPanelSettings[color .. 'Control']].steam_name end
            else
                if Player[color].steam_name ~= nil then steam_name = Player[color].steam_name end
            end
            allGameMessage("#" .. rank .. " - " .. highscore .. " points - ".. color .. " - " .. steam_name, player_color_tints[color])
            local accountedPoints = 0
            for key, score in pairs(scoreSummary[color]) do
                local featureName = key
                if key == 'Field' then featureName = 'Farms'
                elseif key == 'Road' then featureName = 'Roads'
                elseif key == 'City' then featureName = 'Cities'
                elseif key == 'Cloister' then featureName = 'Cloisters'
                end
                printToColor("  " .. featureName .. ": " .. score, sPlayer, player_color_tints[color])
                accountedPoints = accountedPoints + score
            end
            if accountedPoints ~= highscore then
                printToColor("  unaccounted points: " .. highscore - accountedPoints, sPlayer, player_color_tints[color])
            end
        else
            break
        end
        table.insert(printedPlayers, color)
        playerNum = playerNum + 1
        lastHighscore = highscore
    end
end

function prepareTileStack()
    local tileStack = getObjectFromGUID(tileStack_GUID)
    if tileStack ~= nil then
        local tileStackPosition = tileStack.getPosition()
        local tileStackAddPosition = tileStackPosition
        local stackY = tileStackPosition.y
        for rule_id, rule in pairs(tileSettings) do
            if controlPanelSettings[rule_id] then
                for expansion_id, expansion in pairs(rule) do
                    for item_id, item_settings in pairs(expansion) do
                        tileStackAddPosition.y = stackY + 1 + tileStack.getQuantity() * TILE_THICKNESS
                        local newStack = takeObjectSafe(getObjectFromGUID(expansionBags[expansion_id].guid), {guid = expansionBags[expansion_id].contents[item_id].guid, position = tileStackAddPosition, rotation = {0,180,180}})
                        if newStack == nil then
                        else
                            tileStack.putObject(newStack)
                        end
                        coroutine.yield(0)
                    end
                end
            end
        end
        while not preparePlayerPossessionAreaFinished or not prepareNeutralItemsFinished or not prepareStartingTilesFinished do
            coroutine.yield(0)
        end
        wait(1.0)
        --shuffle and lock starting tiles
        for rule_id, rule in pairs(startingTileSettings) do
            if controlPanelSettings[rule_id] then
                for expansion_id, expansion in pairs(rule) do
                    for item_id, item_settings in pairs(expansion) do
                        local stackObject = getObjectFromGUID(expansionBags[expansion_id].contents[item_id].guid)
                        if stackObject ~= nil then
                            if item_settings.shuffle then stackObject.shuffle() end
                            if item_settings.lock then stackObject.setLock(true) end
                        end
                        if item_settings.contents ~= nil then
                            for sub_item_id, sub_item_settings in pairs(item_settings.contents) do
                                local sub_tile = getObjectFromGUID(expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid)
                                if sub_tile ~= nil then
                                    if sub_item_settings.lock then sub_tile.setLock(true) end
                                    if sub_item_settings.addToGrid then
                                        local xIndex = math.floor((sub_item_settings.position.x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                        local zIndex = math.floor((sub_item_settings.position.z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                        if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
                                        tileGrid[xIndex][zIndex] = {}
                                        tileGrid[xIndex][zIndex].tile_guid = expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid
                                        local tileRotation = math.floor(sub_item_settings.rotation.y / 90 + 0.5)
                                        if tileRotation == 0 then tileRotation = 4 end
                                        tileGrid[xIndex][zIndex].rotation = tileRotation
                                        addTile(xIndex, zIndex, getObjectFromGUID(expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid), tileRotation, false)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        tileStack.shuffle()
        if controlPanelSettings['StartingTileRiverII'] then
            allGameMessage("You are currently playing with the river. Please place a river tile, then you may add more to it. According to the rules, the fork should be the first tile placed, followed by the facedown tiles until they are gone, then the spring, and lastly the lake piece.", NEUTRAL_COLOR)
            tileStack.setLock(true)
            tileStack.interactable = false
        elseif controlPanelSettings['StartingTileRiver'] or controlPanelSettings['StartingTileRiverBB5'] then
            allGameMessage("You are currently playing with the river. Please place a river tile, then you may add more to it. According to the rules, the spring should be the first tile placed, followed by the facedown tiles until they are gone, and then the lake.", NEUTRAL_COLOR)
            tileStack.setLock(true)
            tileStack.interactable = false
        end
        allGameMessage("Game started. Good luck!", NEUTRAL_COLOR)
        allGameMessage(activePlayers[currentPlayer] .. " was randomly chosen as the first player.", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])

        if controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] == nil then
            allGameMessage("-----------It is now " .. getPlayerOwnerName(activePlayers[currentPlayer]) .. "'s turn-----------", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
        else
            allGameMessage("-----------It is now " .. activePlayers[currentPlayer] .. "'s turn-----------", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
            allGameMessage("-------" .. activePlayers[currentPlayer] .. " is controlled by " .. stringToBracketedHex(controlPanelSettings[activePlayers[currentPlayer] .. 'Control']) .. getPlayerOwnerName(activePlayers[currentPlayer]) .. stringToBracketedHex(activePlayers[currentPlayer]) .. "------", player_color_tints[activePlayers[currentPlayer]], nil)
        end
    else
        allErrorMessage("Error: Tile stack not found. Scripting will be partially broken unless the game is reloaded.")
    end
    gameover = false
    turnState = 'begin turn'
    stateHandler()
    return 1
end

function prepareStartingTiles()
    if not controlPanelSettings['StartingTileBase'] then
        local baseStartingTile = getObjectFromGUID(startingTile_GUID)
        if baseStartingTile ~= nil then
            baseStartingTile.destruct()
            startingTile_GUID = nil
            tileGrid[25][25] = nil
        end
    else
        local newTile = startingTile_GUID
        startingTile_GUID = nil
        addTile(25, 25, getObjectFromGUID(newTile), 2, false)
    end
    for rule_id, rule in pairs(startingTileSettings) do
        if controlPanelSettings[rule_id] then
            for expansion_id, expansion in pairs(rule) do
                for item_id, item_settings in pairs(expansion) do
                    if (item_id ~= "RiverSpringTile" or springTile_GUID == nil) and (item_id ~= "RiverLakeTile" or lakeTile_GUID == nil) then
                        --HACK: only use GamesQuarterly river tiles if one of the rivers is enabled
                        if not (rule_id == 'GamesQuarterlyTiles' and (item_id == "RiverSpringTile" or item_id == "RiverBodyTiles") and not controlPanelSettings['StartingTileRiverII'] and not controlPanelSettings['StartingTileRiver'] and not controlPanelSettings['StartingTileRiverBB5']) then
                            prepareStartingTileLock = true
                            if takeObjectSafe(getObjectFromGUID(expansionBags[expansion_id].guid), {guid = expansionBags[expansion_id].contents[item_id].guid, position = item_settings.position, rotation = item_settings.rotation, callback_owner = Global, callback = "prepareStartingTileUnlock"}) == nil then
                                prepareStartingTileLock = false
                            end
                            while prepareStartingTileLock do
                                coroutine.yield(0)
                            end
                            if item_id == "RiverForkTile" and forkTile_GUID == nil then
                                forkTile_GUID = expansionBags[expansion_id].contents[item_id].guid
                            end
                            if item_id == "RiverSpringTile" then
                                springTile_GUID = expansionBags[expansion_id].contents[item_id].guid
                            end
                            if item_id == "RiverLakeTile" then
                                lakeTile_GUID = expansionBags[expansion_id].contents[item_id].guid
                            end
                            if item_id == "RiverBodyTiles" and rule_id ~= 'GamesQuarterlyTiles' and riverBodyTiles_GUID == nil then --HACK: gamesquarterly has a single body tile, so it won't be used as the bodyTileStack
                                riverBodyTiles_GUID = expansionBags[expansion_id].contents[item_id].guid
                            end
                            wait(1.0)
                        end
                    end
                    if item_settings.contents ~= nil then
                        for sub_item_id, sub_item_settings in pairs(item_settings.contents) do
                            prepareStartingTileLock = true
                            if getObjectFromGUID(expansionBags[expansion_id].contents[item_id].guid) ~= nil then
                                getObjectFromGUID(expansionBags[expansion_id].contents[item_id].guid).takeObject({guid = expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid, position = sub_item_settings.position, rotation = sub_item_settings.rotation, callback_owner = Global, callback = "prepareStartingTileUnlock"})
                            else
                                getObjectFromGUID(expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid).setPositionSmooth(sub_item_settings.position)
                                getObjectFromGUID(expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid).setRotationSmooth(sub_item_settings.rotation)
                                prepareStartingTileLock = false
                                wait(2)
                            end
                            if startingTile_GUID == nil then
                                startingTile_GUID = expansionBags[expansion_id].contents[item_id].contents[sub_item_id].guid
                            end
                            while prepareStartingTileLock do
                                coroutine.yield(0)
                            end
                        end
                    end
                end
            end
        end
    end
    --HACK: if there is no fork, assign the spring to fork so that it is placed first
    if forkTile_GUID == nil and springTile_GUID ~= nil then
        forkTile_GUID = springTile_GUID
        springTile_GUID = nil
    end
    prepareStartingTilesFinished = true
    return 1
end

function prepareStartingTileUnlock()
    prepareStartingTileLock = false
end

function preparePlayerPossessionArea()
    if controlPanelSettings['AnMAbbey'] then
        gSpawnLock = true
        if takeObjectSafe(getObjectFromGUID(expansionBags['AnM'].guid), {guid = expansionBags['AnM'].contents['AnMAbbey'].guid, position = {x = 0.0, y = 3.0, z = -10.0}, rotation = {0,180,0}, callback_owner = Global, callback = "cbSpawnUnlock"}) == nil then
            gSpawnLock = false
        end
        while gSpawnLock do
            coroutine.yield(0)
        end
        wait(0.1) --need to wait before taking objects from this stack. Wait time is arbitrary, but seems to work.
    end
    for _, player in ipairs(activePlayers) do
        local playerPossessionArea = player_possession_areas[player]
        if controlPanelSettings['AnMAbbey'] then
            local params = {}
            local x, z = rotateCoordinates(-7.15, 0.0, playerPossessionArea.rotation)
            params.position = {playerPossessionArea.x + x, 2, playerPossessionArea.z + z}
            params.rotation = {0, playerPossessionArea.rotation * -90, 0}
            params.callback_owner = Global
            params.callback = "cbSpawnUnlock"
            getObjectFromGUID(expansionBags['AnM'].contents['AnMAbbey'].guid).takeObject(params)
        end

        local figurePad = getObjectFromGUID(figurepad_GUIDs[player])
        figurePositions[player] = {}

        for figureSetting, figure in pairs(figureSettings) do
            figurePositions[player][figure.name] = {}
            if controlPanelSettings[figureSetting] then
                if getPlayerOwner(player):sub(1,2) ~= 'AI' and Player[getPlayerOwner(player)].seated and vipFigureSettings[Player[getPlayerOwner(player)].steam_id] ~= nil and vipFigureSettings[Player[getPlayerOwner(player)].steam_id][figureSetting] ~= nil then
                    figure = vipFigureSettings[Player[getPlayerOwner(player)].steam_id][figureSetting]
                end
                local num
                if figure.num ~= nil then num = controlPanelSettings[figure.num] else num = 1 end
                for i=1, num do
                    local x, z = rotateCoordinatesDegrees(figure.offset.x + (((i - 1) % 4) * -1.45), figure.offset.z + (math.floor((i - 1) / 4) * 1.0), -figurePad.getRotation().y)
                    local params = {}
                    params.type = 'Custom_Model'

                    params.position = {figurePad.getPosition().x + x, 2, figurePad.getPosition().z + z}
                    params.rotation = {0, figurePad.getRotation().y, 0}
                    params.scale = figure.scale
                    params.callback_owner = Global
                    params.callback = "cbSpawnUnlock"
                    gSpawnLock = true
                    local obj = spawnObject(params)

                    local custom_params = {}
                    custom_params.mesh = figure.mesh
                    custom_params.diffuse = figure.diffuse
                    custom_params.type = 1
                    custom_params.material = 1
                    custom_params.specular_intensity = 0.05
                    obj.setCustomObject(custom_params)
                    obj.setName(figure.name)
                    obj.setDescription(player)
                    obj.setColorTint(player_color_tints[player])
                    obj.use_grid = false
                    obj.use_snap_points = figure.use_snap_points
                    while gSpawnLock do
                        coroutine.yield(0)
                    end
                    figurePositions[player][figure.name][i] = obj.getGUID()
                end
            end
        end
    end
    if controlPanelSettings['AnMAbbey'] then
        getObjectFromGUID(expansionBags['AnM'].guid).putObject(getObjectFromGUID(expansionBags['AnM'].contents['AnMAbbey'].guid))
    end
    wait(2)
    preparePlayerPossessionAreaFinished = true
    return 1
end

function prepareNeutralItems()
    local offset = 0
    for rule_id, rule in pairs(neutralFigureSettings) do
        if controlPanelSettings[rule_id] then
            for expansion_id, expansion in pairs(rule) do
                for item_id, item_settings in pairs(expansion) do
                    neutralItemsLock = true
                    offset = offset + item_settings.width / 2
                    if takeObjectSafe(getObjectFromGUID(expansionBags[expansion_id].guid), {guid = expansionBags[expansion_id].contents[item_id].guid, position = {x = NEUTRAL_ITEMS_LOCATION.x + offset, y = NEUTRAL_ITEMS_LOCATION.y, z = NEUTRAL_ITEMS_LOCATION.z}, rotation = {0,180,0}, callback_owner = Global, callback = "neutralItemsUnlock"}) == nil then
                        neutralItemsLock = false
                    end
                    offset = offset + item_settings.width / 2
                    while neutralItemsLock do
                        coroutine.yield(0)
                    end
                end
            end
        end
    end
    prepareNeutralItemsFinished = true
    return 1
end

function neutralItemsUnlock()
    neutralItemsLock = false
end

function endGame()
    gameover = true
    if scoring ~= true then
        turnState = 'game over'
        stateHandler()
    end
end

-- Activates when button is pressed
function switchDebugLevel()
    -- switches between debug mode levels. Updates button's label to match
    debugMode = debugMode + 1
    if debugMode > 3 then debugMode = 0 end
    debugButtonParam.label = 'Debug mode:\n' .. debugMode
    buttonBoard.editButton(debugButtonParam)
end

-- sets the scores to 0
function clearCounters()
    --Clear all victory point counters
    for _, scoreCounter_GUID in pairs(score_counter_guids) do
        local scoreCounter = getObjectFromGUID(scoreCounter_GUID)
        if scoreCounter ~= nil then
            scoreCounter.Counter.clear()
        end
    end
end

-- Activates whenever any object is dropped
function onObjectDrop(player, droppedObject)
    if droppedObject.getName() == "Position Marker" then
        print("x: " .. droppedObject.getPosition().x .. " y: " .. droppedObject.getPosition().y .. " z: " .. droppedObject.getPosition().z)
    end
    if not gameover then
        if (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
            (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            for _, featureMarker in ipairs(featureMarkers) do
                featureMarker.destruct()
            end
            featureMarkers = {}
            if not dropLock then
                dropLock = true
                lastDroppedObject_GUID = droppedObject.getGUID() --global used for the coroutines
                lastDroppedTime = os.clock()
                -- Checks if the dropped object was a single 'card' (tile)
                if tostring(droppedObject) == 'Card(Clone) (LuaGameObjectScript)' then
                    if turnState == 'awaiting tile placement' then
                        Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='checkTile', function_owner=nil, parameters={time=lastDroppedTime}, delay=1})
                    else
                        dropLock = false
                        if not spamLock then
                            allErrorMessage("It is currently not allowed to place a tile. You are only allowed to place a tile at the beginning of your turn. Current state: " .. turnState, player)
                            spamLock = true
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
                        end
                    end
                elseif table.contains(FOLLOWER_TYPES, droppedObject.getName()) or table.contains(SPECIAL_FIGURE_TYPES, droppedObject.getName()) or droppedObject.getName() == "Fairy" then
                    if (currentMiniTurn ~= nil and (droppedObject.getDescription() == activePlayers[currentMiniTurn])) or
                        (currentMiniTurn == nil and (droppedObject.getDescription() == activePlayers[currentPlayer])) or droppedObject.getName() == "Fairy" then
                        if turnState == 'awaiting figure decision' then
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='checkFigure', function_owner=nil, parameters={time=lastDroppedTime}, delay=2})
                        elseif turnState == 'replace finished wagons' then
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='checkWagon', function_owner=nil, parameters={time=lastDroppedTime}, delay=2})
                        elseif turnState == 'awaiting flier decision' then
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='checkFlier', function_owner=nil, parameters={time=lastDroppedTime}, delay=2})
                        else
                            dropLock = false
                            if not spamLock then
                                allErrorMessage("It is currently not allowed to place a figure. You are only allowed to place a figure after a tile. Current state: " .. turnState, player)
                                spamLock = true
                                Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters={time=lastDroppedTime}, delay=2})
                            end
                        end
                    else
                        dropLock = false
                        if not spamLock then
                            playerErrorMessage("Incorrect colored figure was dropped. Are you sure it is yours?", player)
                            spamLock = true
                            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
                        end
                    end
                else
                    dropLock = false
                end
            else
                if not spamLock then
                    allErrorMessage("Multiple pieces dropped too fast, please wait.", player)
                    spamLock = true
                    Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
                end
            end
        else
            if not spamLock then
                playerErrorMessage("It is currently not your turn. Dropped pieces will not count.", player)
                spamLock = true
                Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
            end
        end
    elseif tostring(droppedObject) == 'Card(Clone) (LuaGameObjectScript)' then
        if not spamLock then
            allErrorMessage("Game over or not yet started. Press the start game button and re-lay tile", player)
            spamLock = true
            Timer.create({identifier=droppedObject.getGUID() .. os.clock(), function_name='spamUnlock', function_owner=nil, parameters=nil, delay=2})
        end
    end
end

function spamunlock()
    spamLock = false
end

function onObjectPickUp(player, pickedUpObject)
    if lastDroppedObject_GUID == pickedUpObject.getGUID() then
        dropLock = false
        lastDroppedTime = 0
    end
    if tostring(pickedUpObject) == 'Card(Clone) (LuaGameObjectScript)' then
        local xPosition = (pickedUpObject.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
        local zPosition = (pickedUpObject.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
        local xIndex = math.floor(xPosition + TILE_POSITION_MARGIN)
        local zIndex = math.floor(zPosition + TILE_POSITION_MARGIN)
        if tileGridOccupied(xIndex, zIndex) and tileGrid[xIndex][zIndex].tile_guid == pickedUpObject.getGUID() then
            if lastPlacedTileX ~= nil then
                clearFigureOptions()
                seducedKnights = {}
            end
            tileGrid[xIndex][zIndex] = nil
            if pickedUpObject.getGUID() == startingTile_GUID then
                startingTile_GUID = nil
            end
            if pickedUpObject.getGUID() == startingRiverTile_GUID then
                startingRiverTile_GUID = nil
            end
            lastPlacedTileX = nil
            removeTile(xIndex, zIndex, pickedUpObject)
            allGameMessage("Tile removed from grid", NEUTRAL_COLOR)
            clearArbitraryButtons()
            turnState = 'awaiting tile placement'
            stateHandler()
        end
        if (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
            (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            if turnState == 'awaiting tile placement' then
                showTileMarkers(pickedUpObject)
            end
        end
    elseif table.contains(FOLLOWER_TYPES, pickedUpObject.getName()) or table.contains(SPECIAL_FIGURE_TYPES, pickedUpObject.getName()) then
        if (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
            (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            if turnState == 'awaiting figure decision' then
                gPickedUpObject = pickedUpObject
                startLuaCoroutine(self, 'showFeatureMarkers')
            elseif pickedUpObject.getName() == 'Wagon' and turnState == 'replace finished wagons' then
                gPickedUpObject = pickedUpObject
                startLuaCoroutine(self, 'showWagonFeatureMarkers')
            elseif turnState == 'awaiting flier decision' then
                showFlierFeatureMarkers(pickedUpObject)
            end
        end
        -- if (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
        --     (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
        --     turnState = 'awaiting figure placement'
        -- end
        pickedUpObject.clearButtons()
    end
end

function showTileMarkers(newTile)
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    if showMarkers == 'Hints' or showMarkers == 'Both' then
        local tileMarkers = {}
        for x, tileColumn in pairs(tileGrid) do
            for z, tileLocation in pairs(tileColumn) do
                for side, sideDelta in pairs(SIDE_DELTA) do
                    if tileMarkers[x + sideDelta.x] == nil then
                        tileMarkers[x + sideDelta.x] = {}
                    end
                    if tileMarkers[x + sideDelta.x][z + sideDelta.z] == nil then
                        tileMarkers[x + sideDelta.x][z + sideDelta.z] = false
                        for tileRotation=1, 4 do
                            if isValidTileLocation(newTile, tileRotation, x + sideDelta.x, z + sideDelta.z, false) then
                                tileMarkers[x + sideDelta.x][z + sideDelta.z] = true
                            end
                        end
                    end
                end
            end
        end
        local hasTileLocation = false
        for x, tileColumn in pairs(tileMarkers) do
            for z, tileLocation in pairs(tileColumn) do
                if tileLocation == true then
                    local params = {}
                    params.type = 'Custom_AssetBundle'

                    params.position = {(x * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.0, (z * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                    params.scale = {0.75, 1.2, 0.75}
                    params.callback_owner = Global
                    params.callback = "identifyFeature"
                    local newObject = spawnObject(params)
                    table.insert(featureMarkers, newObject)

                    local custom_params = {}
                    custom_params.assetbundle = 'https://drive.google.com/uc?export=download&id=0BzBZwl-j9sHXZDBpTmotNmhRV00'
                    custom_params.type = 0
                    custom_params.material = 0
                    newObject.setCustomObject(custom_params)
                    hasTileLocation = true
                end
            end
        end
        if not hasTileLocation then
            if not newTile.getVar('isStartingPiece') then
                allGameMessage("There is no valid location to put this tile. If the tile was drawn from the stack, put it back in and shuffle, then draw another.", NEUTRAL_COLOR)
            elseif startingTile_GUID == nil then
                allGameMessage("You may place this starting tile anywhere. It is recommended to place it near the center of the table.", NEUTRAL_COLOR)
            end
        end
    end
    return 1
end

function showFeatureMarkers()
    local newFigure = gPickedUpObject
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    if showMarkers == 'Hints' or showMarkers == 'Both' then
        alreadyVisitedPositions = {}
        figureMarkers = {}
        figureMarkers[lastPlacedTileX] = {}
        figureMarkers[lastPlacedTileX][lastPlacedTileZ] = {}

        local featuresToVisit = { }

        local tile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
        local specialFeatures = tile.getTable('specialFeatures')
        if specialFeatures ~= nil then
            for i, feature in ipairs(specialFeatures) do
                if feature[3] ~= nil then
                    table.insert(featuresToVisit, i+12)
                end
            end
        end
        for i=1, 12 do
            if newFigure.getName() ~= 'Barn' or i > 4 then
                table.insert(featuresToVisit, i)
            end
        end

        for _, i in ipairs(featuresToVisit) do
            if alreadyVisitedPositions[lastPlacedTileX] == nil or alreadyVisitedPositions[lastPlacedTileX][lastPlacedTileZ] == nil or alreadyVisitedPositions[lastPlacedTileX][lastPlacedTileZ][i] ~= true then
                local nameOfFeature = getFeatureName(tile, i)
                local featureOpenings = getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, true)
                if isValidFigureLocation(newFigure, lastPlacedTileX, lastPlacedTileZ, i, nameOfFeature, featureOpenings, false, false) then
                    figureMarkers[lastPlacedTileX][lastPlacedTileZ][i] = true
                end
                if newFigure.getName() ~= 'Barn' then
                    for xIndex, gridColumn in pairs(transversedFeaturePositions) do
                        for zIndex, tileLocation in pairs(gridColumn) do
                            for transversedPosition, transversalLevel in pairs(tileLocation) do
                                if transversalLevel == 1 then
                                    if alreadyVisitedPositions[xIndex] == nil then
                                        alreadyVisitedPositions[xIndex] = {}
                                    end
                                    if alreadyVisitedPositions[xIndex][zIndex] == nil then
                                        alreadyVisitedPositions[xIndex][zIndex] = {}
                                    end
                                    alreadyVisitedPositions[xIndex][zIndex][transversedPosition] = true
                                end
                            end
                        end
                    end
                else
                    if alreadyVisitedPositions[lastPlacedTileX] == nil then
                        alreadyVisitedPositions[lastPlacedTileX] = {}
                    end
                    if alreadyVisitedPositions[lastPlacedTileX][lastPlacedTileZ] == nil then
                        alreadyVisitedPositions[lastPlacedTileX][lastPlacedTileZ] = {}
                    end
                    alreadyVisitedPositions[lastPlacedTileX][lastPlacedTileZ][i] = true
                end
            end
        end
        if tileHasMagicPortal and table.contains(FOLLOWER_TYPES, newFigure.getName()) then
            lastFrameTime = os.clock()
            allGameMessage("Calculating all possible magic portal locations. Hints may be delayed...", NEUTRAL_COLOR)
            for x, tileColumn in pairs(tileGrid) do
                for z, tileLocation in pairs(tileColumn) do
                    if figureMarkers[x] == nil then
                        figureMarkers[x] = {}
                    end
                    if figureMarkers[x][z] == nil then
                        figureMarkers[x][z] = {}
                    end

                    local featuresToVisit = { }

                    local tile = getObjectFromGUID(tileLocation.tile_guid)
                    local specialFeatures = getObjectFromGUID(tileGrid[x][z].tile_guid).getTable('specialFeatures')
                    if specialFeatures ~= nil then
                        for i, feature in ipairs(specialFeatures) do
                            if feature[3] ~= nil then
                                table.insert(featuresToVisit, i+12)
                            end
                        end
                    end
                    for i=1, 12 do
                        table.insert(featuresToVisit, i)
                    end

                    for _, i in ipairs(featuresToVisit) do
                        if alreadyVisitedPositions[x] == nil or alreadyVisitedPositions[x][z] == nil or alreadyVisitedPositions[x][z][i] ~= true then
                            local nameOfFeature = getFeatureName(tile, i)
                            local featureOpenings = getFeatureComponents(x, z, i, 1, true)
                            if isValidFigureLocation(newFigure, x, z, i, nameOfFeature, featureOpenings, false, false) then
                                figureMarkers[x][z][i] = true
                            end
                            for xIndex, gridColumn in pairs(transversedFeaturePositions) do
                                for zIndex, tileLocation in pairs(gridColumn) do
                                    for transversedPosition, transversalLevel in pairs(tileLocation) do
                                        if transversalLevel == 1 then
                                            if alreadyVisitedPositions[xIndex] == nil then
                                                alreadyVisitedPositions[xIndex] = {}
                                            end
                                            if alreadyVisitedPositions[xIndex][zIndex] == nil then
                                                alreadyVisitedPositions[xIndex][zIndex] = {}
                                            end
                                            alreadyVisitedPositions[xIndex][zIndex][transversedPosition] = true
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if os.clock() - lastFrameTime > FRAME_TIME then
                        lastFrameTime = lastFrameTime + FRAME_TIME
                        coroutine.yield(0)
                    end
                    if turnState ~= 'awaiting figure decision' or newFigure.held_by_color == nil then
                        return 1
                    end
                end
            end
        end

        local hasFigureLocation = false
        for xIndex, tileColumn in pairs(figureMarkers) do
            for zIndex, tileLocation in pairs(tileColumn) do
                for position, transversedFeaturePosition in pairs(tileLocation) do
                    if transversedFeaturePosition == true then
                        local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                        local rotation = tileGrid[xIndex][zIndex].rotation
                        if position < 13 or tile.getTable('specialFeatures')[position - 12][3] ~= nil then
                            local x = nil
                            local z = nil
                            if newFigure.getName() ~= 'Barn' then
                                x, z = getFeatureLocation(position, tile, rotation)
                            else --put the marker on the corner instead of the feature position
                                if position % 2 == 1 then --pick one arbitrary position (assuming both were valid), then get the corner closest to it
                                    local side = math.floor((position - 3) / 2)
                                    x, z = rotateCoordinates(-0.5, 0.5, ((8 + TILE_STANDARD_ROTATION - side - rotation) % 4) + 1)
                                end
                            end
                            if x ~= nil and z ~= nil then
                                local params = {}
                                params.type = "BlockSquare"
                                params.position = {(x * TILE_SPACING) + (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                                params.scale = {0.25, 0.25, 0.25}
                                params.callback_owner = Global
                                params.callback = "identifyFeature"
                                local newObject = spawnObject(params)
                                table.insert(featureMarkers, newObject)
                                hasFigureLocation = true
                            end
                        end
                    end
                end
            end
        end
        if not hasFigureLocation then
            allGameMessage("There is no valid location to put this figure. If no other figure is valid, you'll need to skip placing a figure.", NEUTRAL_COLOR)
        end
    end
    return 1
end

function showWagonFeatureMarkers()
    local newFigure = gPickedUpObject
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    if showMarkers == 'Hints' or showMarkers == 'Both' then
        allGameMessage("Calculating all possible wagon locations. Hints may be delayed...", NEUTRAL_COLOR)
        lastFrameTime = os.clock()
        alreadyVisitedPositions = {}
        figureMarkers = {}

        for x, tileColumn in pairs(tileGrid) do
            for z, tileLocation in pairs(tileColumn) do
                if figureMarkers[x] == nil then
                    figureMarkers[x] = {}
                end
                if figureMarkers[x][z] == nil then
                    figureMarkers[x][z] = {}
                end

                local featuresToVisit = { }

                local tile = getObjectFromGUID(tileLocation.tile_guid)
                local specialFeatures = getObjectFromGUID(tileGrid[x][z].tile_guid).getTable('specialFeatures')
                if specialFeatures ~= nil then
                    for i, feature in ipairs(specialFeatures) do
                        if feature[3] ~= nil then
                            table.insert(featuresToVisit, i+12)
                        end
                    end
                end
                for i=1, 12 do
                    table.insert(featuresToVisit, i)
                end

                for _, i in ipairs(featuresToVisit) do
                    if alreadyVisitedPositions[x] == nil or alreadyVisitedPositions[x][z] == nil or alreadyVisitedPositions[x][z][i] ~= true then
                        local nameOfFeature = getFeatureName(tile, i)
                        local featureOpenings = getFeatureComponents(x, z, i, 2, true)
                        if isValidWagonLocation(newFigure, x, z, i, nameOfFeature, featureOpenings, false, false) then
                            figureMarkers[x][z][i] = true
                        end
                        for xIndex, gridColumn in pairs(transversedFeaturePositions) do
                            for zIndex, tileLocation in pairs(gridColumn) do
                                for transversedPosition, transversalLevel in pairs(tileLocation) do
                                    if transversalLevel == 1 then
                                        if alreadyVisitedPositions[xIndex] == nil then
                                            alreadyVisitedPositions[xIndex] = {}
                                        end
                                        if alreadyVisitedPositions[xIndex][zIndex] == nil then
                                            alreadyVisitedPositions[xIndex][zIndex] = {}
                                        end
                                        alreadyVisitedPositions[xIndex][zIndex][transversedPosition] = true
                                    end
                                end
                            end
                        end
                    end
                end
                if os.clock() - lastFrameTime > FRAME_TIME then
                    lastFrameTime = lastFrameTime + FRAME_TIME
                    coroutine.yield(0)
                end
                if turnState ~= 'replace finished wagons' or newFigure.held_by_color == nil then
                    return 1
                end
            end
        end
        local hasFigureLocation = false
        for xIndex, tileColumn in pairs(figureMarkers) do
            for zIndex, tileLocation in pairs(tileColumn) do
                for position, transversedFeaturePosition in pairs(tileLocation) do
                    if transversedFeaturePosition == true then
                        local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                        local rotation = tileGrid[xIndex][zIndex].rotation
                        if position < 13 or tile.getTable('specialFeatures')[position - 12][3] ~= nil then
                            local x, z = getFeatureLocation(position, tile, rotation)
                            local params = {}
                            params.type = "BlockSquare"
                            params.position = {(x * TILE_SPACING) + (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                            params.scale = {0.25, 0.25, 0.25}
                            params.callback_owner = Global
                            params.callback = "identifyFeature"
                            local newObject = spawnObject(params)
                            table.insert(featureMarkers, newObject)
                            hasFigureLocation = true
                        end
                    end
                end
            end
        end
        if not hasFigureLocation then
            allGameMessage("There is no valid location to put this figure. If no other figure is valid, you'll need to skip placing a figure.", NEUTRAL_COLOR)
        end
    end
end

function showFlierFeatureMarkers(newFigure)
    local xIndex = lastPlacedTileX + flierOffset.x
    local zIndex = lastPlacedTileZ + flierOffset.z
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    if showMarkers == 'Hints' or showMarkers == 'Both' then
        alreadyVisitedPositions = {}
        figureMarkers = {}
        figureMarkers[xIndex] = {}
        figureMarkers[xIndex][zIndex] = {}

        local featuresToVisit = { }

        local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
        local specialFeatures = tile.getTable('specialFeatures')
        if specialFeatures ~= nil then
            for i, feature in ipairs(specialFeatures) do
                if feature[3] ~= nil then
                    table.insert(featuresToVisit, i+12)
                end
            end
        end
        for i=1, 12 do
            table.insert(featuresToVisit, i)
        end

        for _, i in ipairs(featuresToVisit) do
            if alreadyVisitedPositions[xIndex] == nil or alreadyVisitedPositions[xIndex][zIndex] == nil or alreadyVisitedPositions[xIndex][zIndex][i] ~= true then
                local nameOfFeature = getFeatureName(tile, i)
                local featureOpenings = getFeatureComponents(xIndex, zIndex, i, 1, true)
                if isValidFlierLocation(newFigure, xIndex, zIndex, i, nameOfFeature, featureOpenings, false, false) then
                    figureMarkers[xIndex][zIndex][i] = true
                end
                for xIndex, gridColumn in pairs(transversedFeaturePositions) do
                    for zIndex, tileLocation in pairs(gridColumn) do
                        for transversedPosition, transversalLevel in pairs(tileLocation) do
                            if transversalLevel == 1 then
                                if alreadyVisitedPositions[xIndex] == nil then
                                    alreadyVisitedPositions[xIndex] = {}
                                end
                                if alreadyVisitedPositions[xIndex][zIndex] == nil then
                                    alreadyVisitedPositions[xIndex][zIndex] = {}
                                end
                                alreadyVisitedPositions[xIndex][zIndex][transversedPosition] = true
                            end
                        end
                    end
                end
            end
        end
        local hasFigureLocation = false
        for xIndex, tileColumn in pairs(figureMarkers) do
            for zIndex, tileLocation in pairs(tileColumn) do
                for position, transversedFeaturePosition in pairs(tileLocation) do
                    if transversedFeaturePosition == true then
                        local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                        local rotation = tileGrid[xIndex][zIndex].rotation
                        if position < 13 or tile.getTable('specialFeatures')[position - 12][3] ~= nil then
                            local x, z = getFeatureLocation(position, tile, rotation)
                            local params = {}
                            params.type = "BlockSquare"
                            params.position = {(x * TILE_SPACING) + (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                            params.scale = {0.25, 0.25, 0.25}
                            params.callback_owner = Global
                            params.callback = "identifyFeature"
                            local newObject = spawnObject(params)
                            table.insert(featureMarkers, newObject)
                            hasFigureLocation = true
                        end
                    end
                end
            end
        end
        if not hasFigureLocation then
            allGameMessage("There is no valid location to put this figure. If no other figure is valid, you'll need to skip placing a figure.", NEUTRAL_COLOR)
        end
    end
    return 1
end

function isValidTileLocation(newTile, tileRotation, xIndex, zIndex, verbose)
    local isStartingPiece = newTile.getVar('isStartingPiece')
    if (startingTile_GUID == nil and isStartingPiece) or
    tileGridOccupied(xIndex + 1, zIndex) or tileGridOccupied(xIndex - 1, zIndex) or
    tileGridOccupied(xIndex, zIndex + 1) or tileGridOccupied(xIndex, zIndex - 1) then
        if not tileGridOccupied(xIndex, zIndex) then
            if ((not tileGridOccupied(xIndex + 1, zIndex) or tileConnectsToSide(newTile, tileRotation, 4, getObjectFromGUID(tileGrid[xIndex + 1][zIndex].tile_guid), tileGrid[xIndex + 1][zIndex].rotation)) and
            (not tileGridOccupied(xIndex - 1, zIndex) or tileConnectsToSide(newTile, tileRotation, 2, getObjectFromGUID(tileGrid[xIndex - 1][zIndex].tile_guid), tileGrid[xIndex - 1][zIndex].rotation)) and
            (not tileGridOccupied(xIndex, zIndex + 1) or tileConnectsToSide(newTile, tileRotation, 3, getObjectFromGUID(tileGrid[xIndex][zIndex + 1].tile_guid), tileGrid[xIndex][zIndex + 1].rotation)) and
            (not tileGridOccupied(xIndex, zIndex - 1) or tileConnectsToSide(newTile, tileRotation, 1, getObjectFromGUID(tileGrid[xIndex][zIndex - 1].tile_guid), tileGrid[xIndex][zIndex - 1].rotation))) then
                if newTile.getTable('sides')[1] == 'Abbey' and
                ((not tileGridOccupied(xIndex + 1, zIndex)) or (not tileGridOccupied(xIndex - 1, zIndex)) or (not tileGridOccupied(xIndex, zIndex + 1)) or (not tileGridOccupied(xIndex, zIndex - 1))) then
                    if verbose then allErrorMessage("Invalid Location: Abbey must be surrounded by tiles on all 4 sides", activePlayers[currentPlayer]) end
                    return false
                end
                if controlPanelSettings['CultTiles'] then
                    local challengerTile = nil
                    local challengedTile = nil
                    local specialFeatures = newTile.getTable('specialFeatures')
                    if specialFeatures ~= nil then
                        for _, feature in ipairs(specialFeatures) do
                            if feature[1] == 'Cloister' or feature[1] == 'Shrine' then challengerTile = feature[1] end
                            if feature[1] == 'Abbey' then challengerTile = 'Cloister' end
                        end
                    end
                    if challengerTile ~= nil then
                        if challengerTile == 'Cloister' then
                            challengedTile = 'Shrine'
                        else
                            challengedTile = 'Cloister'
                        end
                        local numChallenger = 1
                        local numChallenged = 0
                        for x=-1, 1 do
                            for z=-1, 1 do
                                if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                    local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
                                    if specialFeatures ~= nil then
                                        for _, feature in ipairs(specialFeatures) do
                                            local adjacentFeature = feature[1]
                                            if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                            if adjacentFeature == challengedTile then
                                                numChallenged = numChallenged + 1
                                                for nested_x=-1, 1 do
                                                    for nested_z=-1, 1 do
                                                        if not (nested_x == 0 and nested_z == 0) and tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
                                                            local nestedSpecialFeatures = getObjectFromGUID(tileGrid[xIndex + x + nested_x][zIndex + z + nested_z].tile_guid).getTable('specialFeatures')
                                                            if nestedSpecialFeatures ~= nil then
                                                                for _, nestedFeature in ipairs(nestedSpecialFeatures) do
                                                                    local nestedAdjacentFeature = nestedFeature[1]
                                                                    if nestedAdjacentFeature == 'Abbey' then nestedAdjacentFeature = 'Cloister' end
                                                                    if nestedAdjacentFeature == challengerTile then
                                                                        numChallenger = numChallenger + 1
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if numChallenged > 1 or numChallenger > 1 then
                            if verbose then allErrorMessage("Invalid Location: Cannot place a tile such that more than one cloister is next to a shrine or vice versa.", activePlayers[currentPlayer]) end
                            return false
                        end
                    end
                end
                --validate river piece
                if isStartingPiece then
                    local hasRiver = false
                    local riverHasConnection = false
                    for i=1, 4 do
                        if newTile.getTable('sides')[(3 + i - tileRotation) % 4 + 1] == 'River' then
                            hasRiver = true
                            local diff = 0
                            local x = xIndex
                            local z = zIndex
                            if i > 2 then diff = 1 else diff = -1 end
                            if i % 2 == 0 then x = x + diff else z = z + diff end
                            --if it has a river, then the following must be true for at least one of the sides
                            if tileGridOccupied(x, z) and tileConnectsToSide(newTile, tileRotation, i, getObjectFromGUID(tileGrid[x][z].tile_guid), tileGrid[x][z].rotation) then
                                riverHasConnection = true
                                --the following checks to see if this tile would create a "U-turn" such that the river folds back on itself
                                --this is illegal and can easily lead to issues
                                --Though technically illegal, it is possible to still make a river that folds back on itself.
                                --TODO: In the future, consider checking n number of tiles in the direction of the new rivers direction (with a width of 3 tiles) to see if there are any pieces in the way
                                if ((newTile.getTable('sides')[(3 + i + 1 - tileRotation) % 4 + 1] == 'River' and getObjectFromGUID(tileGrid[x][z].tile_guid).getTable('sides')[(3 + i + 1 - tileGrid[x][z].rotation) % 4 + 1] == 'River') or
                                (newTile.getTable('sides')[(3 + i + 3 - tileRotation) % 4 + 1] == 'River' and getObjectFromGUID(tileGrid[x][z].tile_guid).getTable('sides')[(3 + i + 3 - tileGrid[x][z].rotation) % 4 + 1] == 'River')) then
                                    if verbose then allErrorMessage("Invalid Location: U-turns are not allowed on rivers", activePlayers[currentPlayer]) end
                                    return false
                                end
                            end
                        end
                    end
                    if startingRiverTile_GUID ~= nil and hasRiver and not riverHasConnection then
                        if verbose then allErrorMessage("Invalid Location: Tile must continue the already placed river", activePlayers[currentPlayer]) end
                        return false
                    end
                end
                return true
            else
                if verbose then allErrorMessage("Invalid Location: Adjacent tiles do not match", activePlayers[currentPlayer]) end
            end
        else
            if verbose then allErrorMessage("Invalid Location: Space already occupied by another tile", activePlayers[currentPlayer]) end
        end
    else
        if verbose then allErrorMessage("Invalid Location: Must be adjacent to at least one tile", activePlayers[currentPlayer]) end
    end
    return false
end

function isValidFigureLocation(newFigure, xIndex, zIndex, position, nameOfFeature, featureOpenings, newFigureInTranversal, verbose)
    local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
    if controlPanelSettings['PnDDragon'] and dragon ~= nil and newFigure.getName() ~= 'Barn' and (table.contains(FOLLOWER_TYPES, newFigure.getName()) or table.contains(SPECIAL_FIGURE_TYPES, newFigure.getName())) then
        if xIndex == math.floor((dragon.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
           zIndex == math.floor((dragon.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
            if verbose then allErrorMessage("Invalid Location: Cannot place a figure on the tile containing the dragon.", activePlayers[currentPlayer]) end
            return false
        end
    end
    if nameOfFeature == 'River' then
        if verbose then allErrorMessage("Invalid Location: You can't occupy a river.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Carcassonne' then
        if verbose then allErrorMessage("Invalid Location: The City of Carcassonne is not yet implemented.", activePlayers[currentPlayer]) end
        return false
    end
    if string.sub(nameOfFeature,1,6) == 'Flier-' then
        if controlPanelSettings['FlierFlier'] then
            if table.contains(FOLLOWER_TYPES, newFigure.getName()) then
                return true
            else
                if verbose then allErrorMessage("Invalid Location: Only a follower can be placed on a flier.", activePlayers[currentPlayer]) end
                return false
            end
        else
            if verbose then allErrorMessage("The Flier was disabled in the control panel. You may not place anything on the flier.", activePlayers[currentPlayer]) end
            return false
        end
    end
    if newFigure.getName() == 'Shepherd' and nameOfFeature ~= 'Field' then
        if verbose then allErrorMessage("Invalid Location: Shepherd can only be placed on fields.", activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getName() == 'Abbot' and not (nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey') then
        if verbose then allErrorMessage("Invalid Location: An abbot can only be placed on a garden or cloister.", activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getName() ~= 'Abbot' and nameOfFeature == 'Garden' then
        if verbose then allErrorMessage("Invalid Location: Only an abbot can be placed on a garden.", activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getName() == 'Builder' and nameOfFeature ~= 'Road' and nameOfFeature ~= 'City' then
        if verbose then allErrorMessage("Invalid Location: A builder can only be placed on roads and cities.", activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getName() == 'Pig' and nameOfFeature ~= 'Field' then
        if verbose then allErrorMessage("Invalid Location: A pig can only be placed on fields.", activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getName() == 'Mayor' and nameOfFeature ~= 'City' then
        if verbose then allErrorMessage("Invalid Location: A mayor can only occupy a city.", activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getName() == 'Wagon' and nameOfFeature == 'Field' then
        if verbose then allErrorMessage("Invalid Location: A wagon cannot occupy a field.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Road' and controlPanelSettings['BaseDisableRoads'] then
        if verbose then allErrorMessage("Invalid Location: Roads are disabled via the house rules.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'City' and controlPanelSettings['BaseDisableCities'] then
        if verbose then allErrorMessage("Invalid Location: Cities are disabled via the house rules.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Cloister' and controlPanelSettings['BaseDisableCloisters'] then
        if verbose then allErrorMessage("Invalid Location: Cloisters are disabled via the house rules.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Field' and newFigure.getName() ~= 'Shepherd' and controlPanelSettings['BaseDisableFarms'] then
        if verbose then allErrorMessage("Invalid Location: Farms are disabled via the house rules.", activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getName() == 'Barn' then
        if nameOfFeature ~= 'Field' or not checkBarn(position, xIndex, zIndex) then
            if verbose then allErrorMessage("Invalid Location: A barn can only be placed on a corner of fields.", activePlayers[currentPlayer]) end
            return false
        end
    end
    if featureOpenings == 0 and not (xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ) and newFigure.getName() ~= 'Barn' then
        if verbose then allErrorMessage("Invalid Location: You may not use the magic portal to place a follower on a completed feature.", activePlayers[currentPlayer]) end
        return false
    end
    local numFollowers = 0
    local numCurrentPlayerFollowers = 0
    local numShepherds = 0
    local numBarns = 0
    for _, follower in ipairs(transversedFollowers) do
        if table.contains(FOLLOWER_TYPES, follower.getName()) then
            numFollowers = numFollowers + 1
            if follower.getDescription() == activePlayers[currentPlayer] then
                numCurrentPlayerFollowers = numCurrentPlayerFollowers + 1
            end
        end
    end
    for _, figure in ipairs(transversedSpecialFigures) do
        if figure.getName() == 'Shepherd' then
            numShepherds = numShepherds + 1
        end
        if figure.getName() == 'Barn' then
            numBarns = numBarns + 1
        end
    end
    if not newFigureInTranversal then
        if table.contains(FOLLOWER_TYPES, newFigure.getName()) then
            numFollowers = numFollowers + 1
            if newFigure.getDescription() == activePlayers[currentPlayer] then
                numCurrentPlayerFollowers = numCurrentPlayerFollowers + 1
            end
        end
        if newFigure.getName() == 'Shepherd' then
            numShepherds = numShepherds + 1
        end
        if newFigure.getName() == 'Barn' then
            numBarns = numBarns + 1
        end
    end
    if newFigure.getName() == 'Builder' and numCurrentPlayerFollowers == 0 then
        if verbose then allErrorMessage("Invalid Location: A builder can only be placed on a road/city containing at least one of your followers.", activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getName() == 'Pig' and numCurrentPlayerFollowers == 0 then
        if verbose then allErrorMessage("Invalid Location: A pig can only be placed on a field containing at least one of your followers.", activePlayers[currentPlayer]) end
        return false
    end
    if (table.contains(FOLLOWER_TYPES, newFigure.getName()) and numFollowers == 1 and numBarns == 0) or
        (newFigure.getName() == 'Shepherd' and numShepherds == 1) or
        (newFigure.getName() == 'Barn' and numBarns == 1) or
         newFigure.getName() == 'Builder' or newFigure.getName() == 'Pig' then
        return true
    elseif (table.contains(FOLLOWER_TYPES, newFigure.getName()) and numFollowers == 0) or
        (newFigure.getName() == 'Shepherd' and numShepherds == 0) or
        (newFigure.getName() == 'Barn' and numBarns == 0) then
        if verbose then allErrorMessage("ERROR: Placed a " .. newFigure.getName() .. ", but no " .. newFigure.getName() .. " found. This should never happen. Tell the dev.") end
    else
        if verbose then allErrorMessage("Invalid Location: Feature already occupied.", activePlayers[currentPlayer]) end
    end
    return false
end

function isValidWagonLocation(newFigure, xIndex, zIndex, position, nameOfFeature, featureOpenings, newFigureInTranversal, verbose)
    if nameOfFeature == 'River' then
        if verbose then allErrorMessage("Invalid Location: You can't occupy a river.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Carcassonne' then
        if verbose then allErrorMessage("Invalid Location: The City of Carcassonne is not yet implemented.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Field' then
        if verbose then allErrorMessage("Invalid Location: A wagon cannot occupy a field.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Road' and controlPanelSettings['BaseDisableRoads'] then
        if verbose then allErrorMessage("Invalid Location: Roads are disabled via the house rules.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'City' and controlPanelSettings['BaseDisableCities'] then
        if verbose then allErrorMessage("Invalid Location: Cities are disabled via the house rules.", activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Cloister' and controlPanelSettings['BaseDisableCloisters'] then
        if verbose then allErrorMessage("Invalid Location: Cloisters are disabled via the house rules.", activePlayers[currentPlayer]) end
        return false
    end
    if featureOpenings > 0 then
        local oldXIndex = math.floor((wagonLocations[activePlayers[currentMiniTurn]].x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local oldZIndex = math.floor((wagonLocations[activePlayers[currentMiniTurn]].z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        local oldXPosition = (wagonLocations[activePlayers[currentMiniTurn]].x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
        local oldZPosition = (wagonLocations[activePlayers[currentMiniTurn]].z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
        oldXPosition = oldXPosition - oldXIndex
        oldZPosition = oldZPosition - oldZIndex

        if tileGrid[oldXIndex] == nil or tileGrid[oldXIndex][oldZIndex] == nil then
            if verbose then allErrorMessage("Error: previous tile is missing. It may have been removed.") end
            return false
        end
        local oldTile = getObjectFromGUID(tileGrid[oldXIndex][oldZIndex].tile_guid)
        local oldTileRotation = tileGrid[oldXIndex][oldZIndex].rotation
        local oldPosition = findClosestFeature(oldXPosition, oldZPosition, oldTile, oldTileRotation)
        --debugMessage(3, "wagon old xIndex: " .. oldXIndex .. " zIndex: " .. oldZIndex .. " position: " .. oldPosition)
        if transversedGrid[oldXIndex] ~= nil and transversedGrid[oldXIndex][oldZIndex] ~= nil and transversedGrid[oldXIndex][oldZIndex][oldPosition] ~= nil then
            if (#transversedFollowers == 1 and newFigureInTranversal) or (#transversedFollowers == 0 and not newFigureInTranversal) then
                return true
            elseif #transversedFollowers == 0 then
                if verbose then allErrorMessage("ERROR: Placed a " .. newFigure.getName() .. ", but no " .. newFigure.getName() .. " found. This should never happen. Tell the dev.") end
            else
                if verbose then allErrorMessage("Invalid Location: Feature already occupied.", activePlayers[currentPlayer]) end
            end
        else
            if verbose then allErrorMessage("Invalid Location: Not connected to the previous feature by road.", activePlayers[currentPlayer]) end
        end
    else
        if verbose then allErrorMessage("Invalid Location: Feature already finished. You must place the wagon in an incomplete feature", activePlayers[currentPlayer]) end
    end
    return false
end

function isValidFlierLocation(newFigure, xIndex, zIndex, position, nameOfFeature, featureOpenings, newFigureInTranversal, verbose)
    if newFigure.getName() == 'Abbot' and nameOfFeature ~= 'Garden' and nameOfFeature ~= 'Cloister' and nameOfFeature ~= 'Abbey' then
        if verbose then allErrorMessage("Invalid Location: An abbot can only be placed on a garden or cloister.", activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getName() == 'Mayor' and nameOfFeature ~= 'City' then
        if verbose then allErrorMessage("Invalid Location: A mayor can only occupy a city.", activePlayers[currentPlayer]) end
        return
    end
    if nameOfFeature ~= 'City' and nameOfFeature ~= 'Road' and nameOfFeature ~= 'Cloister' then
        if verbose then allErrorMessage("Invalid Location: A flier can only be placed on a city, road, or cloister.", activePlayers[currentPlayer]) end
        return
    end
    if featureOpenings == 0 then
        if verbose then allErrorMessage("Invalid Location: You may only place the flier on an incomplete feature.", activePlayers[currentPlayer]) end
        return false
    end
    return true
end

--tileConnectsToSide
-- params:
--  obj: tile 1
--  int: rotation 1 (rotation of the tile)
--  int: which side of the first tile is being checked
--  obj: tile 2
--  int: rotation 2
-- returns:
--  bool: true if they match
function tileConnectsToSide(t1, r1, n1, t2, r2)
    s1 = t1.getTable('sides')[(3 + n1 - r1) % 4 + 1]
    s2 = t2.getTable('sides')[(3 + n1 - r2 + TILE_180_ROTATION) % 4 + 1]
    --debugMessage(2, "s1(" .. (3 + n1 - r1) % 4 + 1 .. "): " .. s1 .. " s2(" .. (3 + n1 - r2 + TILE_180_ROTATION) % 4 + 1 .. "): " .. s2)
    if s1 == 'Abbey' or s2 == 'Abbey' then return true end
    if s1 == s2 then return true else return false end
end

--tileGridOccupied
-- params:
--  int: x
--  int: z
-- returns:
--  bool: true if occupied
function tileGridOccupied(x, z)
    if tileGrid[x] == nil or tileGrid[x][z] == nil then return false else return true end
end

--ensure this tile is valid for this location
function checkTile(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID ~= nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newTile = getObjectFromGUID(lastDroppedObject_GUID)
        if newTile ~= nil and newTile.held_by_color == nil then
            if newTile.getTable('sides') == nil then
                allErrorMessage("Error: This tile has no script data. Most likely this expansion hasn't yet been implemented.")
                return
            end
            local xPosition = (newTile.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
            local zPosition = (newTile.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
            local yRotation = newTile.getRotation().y / 90
            local zRotation = newTile.getRotation().z
            --debugMessage(3, "piece rotation: " .. yRotation .. " piece position: x: " .. xPosition .. " z: " .. zPosition)
            if isWithinErrorMargin(xPosition, math.floor(xPosition + TILE_POSITION_MARGIN), TILE_POSITION_MARGIN) and
            isWithinErrorMargin(zPosition, math.floor(zPosition + TILE_POSITION_MARGIN), TILE_POSITION_MARGIN) and
            isWithinErrorMargin(yRotation, math.floor(yRotation + TILE_ROTATION_MARGIN), TILE_ROTATION_MARGIN) and
            --is tile flipped over?
            isWithinErrorMargin(0, math.floor(zRotation + TILE_ROTATION_MARGIN), TILE_ROTATION_MARGIN) then
                local xIndex = math.floor(xPosition + TILE_POSITION_MARGIN)
                local zIndex = math.floor(zPosition + TILE_POSITION_MARGIN)
                --by adding 0.5, getting the floor will round to the nearest whole number
                local tileRotation = math.floor(yRotation + 0.5)
                if tileRotation == 0 then tileRotation = 4 end
                --debugMessage(2, "piece rotation: " .. tileRotation .. " piece indexes: x: " .. xIndex .. " z: " .. zIndex)
                if isValidTileLocation(newTile, tileRotation, xIndex, zIndex, true) then
                    if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
                    tileGrid[xIndex][zIndex] = {}
                    tileGrid[xIndex][zIndex].tile_guid = newTile.getGUID()
                    tileGrid[xIndex][zIndex].rotation = tileRotation
                    lastPlacedTileX = xIndex
                    lastPlacedTileZ = zIndex
                    if newTile.getGUID() == finalTile_GUID then
                        finalTile_GUID = nil
                    end
                    if newTile.getGUID() == forkTile_GUID then
                        forkTile_GUID = nil
                    end
                    if newTile.getGUID() == springTile_GUID then
                        springTile_GUID = nil
                    end
                    if newTile.getGUID() == lakeTile_GUID then
                        lakeTile_GUID = nil
                    end

                    if AUTOLOCK then
                        newTile.setLock(true)
                    end
                    addTile(xIndex, zIndex, newTile, tileRotation, false)
                    if startingTile_GUID == nil and newTile.getVar('isStartingPiece') then
                        startingTile_GUID = newTile.getGUID()
                    end
                    if startingRiverTile_GUID == nil and newTile.getVar('isStartingPiece') then
                        startingRiverTile_GUID = newTile.getGUID()
                    end
                    return nextState('tile placed')
                end
            else
                allErrorMessage("Invalid Location: Tile not aligned with the grid", activePlayers[currentPlayer])
            end
        else
            allErrorMessage("Tile picked up before validation. Please replace tile", activePlayers[currentPlayer])
        end
    end
end

function addTile(xIndex, zIndex, tile, rotation, temp)
    if startingTile_GUID == nil and tile.getVar('isStartingPiece') and not temp then
        startingTile_GUID = tile.getGUID()
        linkedFeatures = {['City-Field'] = {}, ['Road Intersection'] = {}}
        featureMap = {}
        featureIndex = 0
        featureList = {}
    end
    if temp then --do not modify the original data. If anything is modified, make a copy of it before modifying
        tempLinkedFeatures = {['City-Field'] = {}, ['Road Intersection'] = {}}
        tempFeatureMap = {}
        tempFeatureIndex = featureIndex
        tempFeatureList = {}
        tempJoinedFeature = {}
    else
        if featureMap[xIndex] == nil then featureMap[xIndex] = {} end
        if featureMap[xIndex][zIndex] == nil then featureMap[xIndex][zIndex] = {} end
    end
    local visitedFeatures = {}
    local features = tile.getTable('specialFeatures')
    local numSpecialFeatures = 0
    if features ~= nil then numSpecialFeatures = #features end
    local numFeatures = 12 + numSpecialFeatures
    for position=1, numFeatures do
        local nameOfFeature = getFeatureName(tile, position)
        if (position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' or nameOfFeature == 'Abbey') and not (position > 12 and features[position-12][3] == nil) and not visitedFeatures[position] then
            local featurePositions = {}
            local linkedSpecialFeatures = {}
            local connectedFeatures = {}
            local featureOpenings = 0
            local links = nil

            if position < 5 then
                links = tile.getTable('linkedQuadrants')
            elseif position < 13 then
                links = tile.getTable('linkedOctants')
            end
            local visitedPosition = false
            while not visitedPosition do
                if links ~= nil then
                    for _, link in ipairs(links) do
                        --HACK: Because quadrants and octants can't be linked, Abbeys create a scenario where they get different feature numbers.
                        --The least hacky way I could fix it (without having to redo huge chunks of code) was as follows, in addition to linking all 12 positions to the 13th on the tiles...
                        if nameOfFeature == 'Abbey' then
                            link = {1,2,3,4,5,6,7,8,9,10,11,12}
                        end
                        if table.contains(link, position) then
                            visitedPosition = true
                            for _, nestedPosition in ipairs(link) do
                                featurePositions[nestedPosition] = true
                                if nestedPosition < 13 then
                                    local connectedTilePosition
                                    local connectedX, connectedZ
                                    if nestedPosition < 5 then
                                        local direction = (3 + nestedPosition + rotation) % 4 + 1
                                        local sideDirection = (3 + nestedPosition + rotation) % 4 + 1
                                        connectedX = xIndex + SIDE_DELTA[sideDirection].x
                                        connectedZ = zIndex + SIDE_DELTA[sideDirection].z
                                        connectedTilePosition = (3 + nestedPosition + rotation - TILE_STANDARD_ROTATION + TILE_180_ROTATION) % 4 + 1
                                    else
                                        local direction = (3 + nestedPosition + (rotation * 2)) % 8 + 5
                                        local sideDirection = math.floor(((3 + nestedPosition + (rotation * 2)) % 8 + 5 - 3) / 2)
                                        connectedX = xIndex + SIDE_DELTA[sideDirection].x
                                        connectedZ = zIndex + SIDE_DELTA[sideDirection].z
                                        connectedTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (TILE_STANDARD_ROTATION * 2) - 4) % 8 + 5
                                    end
                                    if featureMap[connectedX] ~= nil and featureMap[connectedX][connectedZ] ~= nil and featureMap[connectedX][connectedZ][connectedTilePosition] ~= nil then
                                        if nameOfFeature ~= 'Abbey' then
                                            featureOpenings = featureOpenings - 1
                                            if not table.contains(connectedFeatures, featureMap[connectedX][connectedZ][connectedTilePosition]) then
                                                table.insert(connectedFeatures, featureMap[connectedX][connectedZ][connectedTilePosition])
                                            end
                                        else
                                            if temp then
                                                if tempFeatureList[featureMap[connectedX][connectedZ][connectedTilePosition]] == nil then
                                                    tempFeatureList[featureMap[connectedX][connectedZ][connectedTilePosition]] = {}
                                                end
                                                tempFeatureList[featureMap[connectedX][connectedZ][connectedTilePosition]].openings = featureList[featureMap[connectedX][connectedZ][connectedTilePosition]].openings - 1
                                            else
                                                featureList[featureMap[connectedX][connectedZ][connectedTilePosition]].openings = featureList[featureMap[connectedX][connectedZ][connectedTilePosition]].openings - 1
                                            end
                                        end
                                    elseif nameOfFeature ~= 'Abbey' then
                                        featureOpenings = featureOpenings + 1
                                    end
                                end
                            end
                        end
                    end
                end
                if not visitedPosition then
                    links = {{position}}
                end
            end
            if features ~= nil then
                for i, feature in ipairs(features) do
                    if feature[2] ~= nil then
                        if table.contains(feature[2], position) then
                            if feature[3] ~= nil then
                                featurePositions[i+12] = true
                                --print("adding non-standard position: " .. feature[1])
                            elseif feature[1] ~= 'City-Field' and feature[1] ~= 'Road Intersection' then
                                table.insert(linkedSpecialFeatures, feature[1])
                                --print("adding special feature: " .. feature[1])
                            end
                        end
                    end
                end
            end

            local newFeatureIndex
            if #connectedFeatures > 0 then
                newFeatureIndex = connectedFeatures[1]

                if temp then
                    if tempFeatureList[newFeatureIndex] == nil then
                        tempFeatureList[newFeatureIndex] = {}
                    end
                    tempFeatureList[newFeatureIndex].specialFeatures = table.shallow_copy(featureList[newFeatureIndex].specialFeatures)
                    for _, specialFeature in ipairs(linkedSpecialFeatures) do
                        table.insert(tempFeatureList[newFeatureIndex].specialFeatures, specialFeature)
                    end
                    tempFeatureList[newFeatureIndex].nameOfFeature = featureList[newFeatureIndex].nameOfFeature
                    tempFeatureList[newFeatureIndex].openings = featureList[newFeatureIndex].openings + featureOpenings
                    if nameOfFeature ~= 'Field' then
                        tempFeatureList[newFeatureIndex].numTiles = featureList[newFeatureIndex].numTiles + 1
                    end
                    if linkedFeatures['City-Field'][newFeatureIndex] ~= nil then
                        tempLinkedFeatures['City-Field'][newFeatureIndex] = table.shallow_copy(linkedFeatures['City-Field'][newFeatureIndex])
                    end
                    if linkedFeatures['Road Intersection'][newFeatureIndex] ~= nil then
                        tempLinkedFeatures['Road Intersection'][newFeatureIndex] = table.shallow_copy(linkedFeatures['Road Intersection'][newFeatureIndex])
                    end
                else
                    for _, specialFeature in ipairs(linkedSpecialFeatures) do
                        table.insert(featureList[newFeatureIndex].specialFeatures, specialFeature)
                    end
                    featureList[newFeatureIndex].openings = featureList[newFeatureIndex].openings + featureOpenings --this takes into account all connected features, not just this first one
                    if nameOfFeature ~= 'Field' then
                        featureList[newFeatureIndex].numTiles = featureList[newFeatureIndex].numTiles + 1
                    end
                end
                if #connectedFeatures > 1 then
                    local visitedTiles = {}
                    for i, connectedFeature in ipairs(connectedFeatures) do
                        for linkType, originFeatures in pairs(linkedFeatures) do
                            if linkedFeatures[linkType][connectedFeature] ~= nil then
                                for destinationFeature, _ in pairs(linkedFeatures[linkType][connectedFeature]) do
                                    if destinationFeature ~= newFeatureIndex then --don't copy a reference to itself
                                        if temp then
                                            if linkedFeatures[linkType][newFeatureIndex] == nil then
                                                tempLinkedFeatures[linkType][newFeatureIndex] = {}
                                            end
                                            tempLinkedFeatures[linkType][newFeatureIndex][destinationFeature] = true
                                        else
                                            if linkedFeatures[linkType][newFeatureIndex] == nil then
                                                linkedFeatures[linkType][newFeatureIndex] = {}
                                            end
                                            linkedFeatures[linkType][newFeatureIndex][destinationFeature] = true
                                        end
                                    end
                                end
                            end
                            for originFeature, _ in pairs(originFeatures) do
                                if originFeature ~= newFeatureIndex then --don't copy a reference to itself
                                    if linkedFeatures[linkType][originFeature][connectedFeature] ~= nil then
                                        if temp then
                                            --if a link needs to be changed then it needs to be copied from the original table if it exists
                                            if tempLinkedFeatures[linkType][originFeature] == nil then
                                                if linkedFeatures[linkType][originFeature] ~= nil then
                                                    tempLinkedFeatures[linkType][originFeature] = table.shallow_copy(linkedFeatures[linkType][originFeature])
                                                else
                                                    tempLinkedFeatures[linkType][originFeature] = {}
                                                end
                                            end
                                            tempLinkedFeatures[linkType][originFeature][newFeatureIndex] = true
                                        else
                                            if linkedFeatures[linkType][originFeature] == nil then
                                                linkedFeatures[linkType][originFeature] = {}
                                            end
                                            linkedFeatures[linkType][originFeature][newFeatureIndex] = true
                                        end
                                    end
                                end
                            end
                        end
                        if i == 1 then
                            if nameOfFeature ~= 'Field' then
                                for nestedX, featureColumn in pairs(featureMap) do
                                    for nestedZ, tileFeatures in pairs(featureColumn) do
                                        for nestedFeature, feature in pairs(tileFeatures) do
                                            if feature == connectedFeature then
                                                if visitedTiles[nestedX] == nil then visitedTiles[nestedX] = {} end
                                                visitedTiles[nestedX][nestedZ] = true
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        else
                            if temp then
                                for _, specialFeature in ipairs(featureList[connectedFeature].specialFeatures) do
                                    table.insert(tempFeatureList[newFeatureIndex].specialFeatures, specialFeature)
                                end
                                tempFeatureList[newFeatureIndex].openings = tempFeatureList[newFeatureIndex].openings + featureList[connectedFeature].openings
                                tempJoinedFeature[connectedFeature] = newFeatureIndex
                            else
                                for _, specialFeature in ipairs(featureList[connectedFeature].specialFeatures) do
                                    table.insert(featureList[newFeatureIndex].specialFeatures, specialFeature)
                                end
                                featureList[newFeatureIndex].openings = featureList[newFeatureIndex].openings + featureList[connectedFeature].openings
                            end
                            for nestedX, featureColumn in pairs(featureMap) do
                                for nestedZ, tileFeatures in pairs(featureColumn) do
                                    for nestedFeature, feature in pairs(tileFeatures) do
                                        if feature == connectedFeature then
                                            --print("feature " .. newFeatureIndex .. " on x:" .. nestedX .. " y:" .. nestedZ .. " assigned to position " .. nestedFeature)
                                            if not temp then
                                                featureMap[nestedX][nestedZ][nestedFeature] = newFeatureIndex
                                            end
                                            if nameOfFeature ~= 'Field' then
                                                if visitedTiles[nestedX] == nil then visitedTiles[nestedX] = {} end
                                                if not visitedTiles[nestedX][nestedZ] then
                                                    --since there's a chance that multiple features occupy the same tile, we can't trust the numTiles property of this feature and must recount
                                                    if temp then
                                                        tempFeatureList[newFeatureIndex].numTiles = tempFeatureList[newFeatureIndex].numTiles + 1
                                                    else
                                                        featureList[newFeatureIndex].numTiles = featureList[newFeatureIndex].numTiles + 1
                                                    end
                                                    visitedTiles[nestedX][nestedZ] = true
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            if not temp then
                                featureList[connectedFeature] = nil
                                for linkType, originFeatures in pairs(linkedFeatures) do
                                    for origin, _ in pairs(originFeatures) do
                                        linkedFeatures[linkType][origin][connectedFeature] = nil
                                    end
                                    linkedFeatures[linkType][connectedFeature] = nil
                                end
                            end
                        end
                    end
                end
            else
                if temp then
                    tempFeatureIndex = tempFeatureIndex + 1
                    newFeatureIndex = tostring(tempFeatureIndex)
                    tempFeatureList[newFeatureIndex] = {}
                    tempFeatureList[newFeatureIndex].nameOfFeature = nameOfFeature
                    tempFeatureList[newFeatureIndex].specialFeatures = linkedSpecialFeatures
                    tempFeatureList[newFeatureIndex].openings = featureOpenings
                    if nameOfFeature ~= 'Field' then
                        tempFeatureList[newFeatureIndex].numTiles = 1
                    else
                        tempFeatureList[newFeatureIndex].numTiles = 0
                    end
                    if nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                        tempFeatureList[newFeatureIndex].featureLocation = {x=xIndex, z=zIndex}
                    end
                else
                    featureIndex = featureIndex + 1
                    newFeatureIndex = tostring(featureIndex)
                    featureList[newFeatureIndex] = {}
                    featureList[newFeatureIndex].nameOfFeature = nameOfFeature
                    featureList[newFeatureIndex].specialFeatures = linkedSpecialFeatures
                    featureList[newFeatureIndex].openings = featureOpenings
                    if nameOfFeature ~= 'Field' then
                        featureList[newFeatureIndex].numTiles = 1
                    else
                        featureList[newFeatureIndex].numTiles = 0
                    end
                    if nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                        featureList[newFeatureIndex].featureLocation = {x=xIndex, z=zIndex}
                    end
                end
            end
            for nestedPosition, featurePosition in pairs(featurePositions) do
                if nestedPosition < 5 then
                    direction = (3 + nestedPosition + rotation + TILE_STANDARD_ROTATION) % 4 + 1
                elseif nestedPosition < 13 then
                    direction = (3 + nestedPosition + ((rotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                else
                    direction = nestedPosition
                end
                --print("feature " .. newFeatureIndex .. " assigned to position " .. direction)
                if temp then
                    tempFeatureMap[direction] = newFeatureIndex
                else
                    featureMap[xIndex][zIndex][direction] = newFeatureIndex
                end
                visitedFeatures[nestedPosition] = true
            end
        end
    end

    if features ~= nil then
        for i, feature in ipairs(features) do
            if feature[2] ~= nil then
                if feature[1] == 'City-Field' or feature[1] == 'Road Intersection' then
                    local nestedLinkedFeatures = {}
                    for _, nestedPosition in ipairs(feature[2]) do
                        if nestedPosition < 5 then
                            direction = (3 + nestedPosition + rotation + TILE_STANDARD_ROTATION) % 4 + 1
                        elseif nestedPosition < 13 then
                            direction = (3 + nestedPosition + ((rotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                        else
                            direction = nestedPosition
                        end
                        local featureNum
                        if temp then
                            featureNum = tempFeatureMap[direction]
                        else
                            featureNum = featureMap[xIndex][zIndex][direction]
                        end
                        if not table.contains(nestedLinkedFeatures, featureNum) then
                            table.insert(nestedLinkedFeatures, featureNum)
                        end
                    end
                    for _, nestedLinkedFeature in ipairs(nestedLinkedFeatures) do
                        if temp then
                            --if feature[1] == 'Road Intersection' or tempFeatureList[nestedLinkedFeature].nameOfFeature == 'Field' then
                            if tempLinkedFeatures[feature[1]][nestedLinkedFeature] == nil then
                                tempLinkedFeatures[feature[1]][nestedLinkedFeature] = {}
                            end
                                for _, nestedNestedLinkedFeature in ipairs(nestedLinkedFeatures) do
                                    if nestedLinkedFeature ~= nestedNestedLinkedFeature and (feature[1] == 'Road Intersection' or tempFeatureList[nestedNestedLinkedFeature].nameOfFeature ~= tempFeatureList[nestedLinkedFeature].nameOfFeature) then
                                        tempLinkedFeatures[feature[1]][nestedLinkedFeature][nestedNestedLinkedFeature] = true
                                    end
                                end
                            --end
                        else
                            --if feature[1] == 'Road Intersection' or featureList[nestedLinkedFeature].nameOfFeature == 'Field' then
                            if linkedFeatures[feature[1]][nestedLinkedFeature] == nil then
                                linkedFeatures[feature[1]][nestedLinkedFeature] = {}
                            end
                                for _, nestedNestedLinkedFeature in ipairs(nestedLinkedFeatures) do
                                    if nestedLinkedFeature ~= nestedNestedLinkedFeature and (feature[1] == 'Road Intersection' or featureList[nestedNestedLinkedFeature].nameOfFeature ~= featureList[nestedLinkedFeature].nameOfFeature) then
                                    --if nestedLinkedFeature ~= nestedNestedLinkedFeature and (feature[1] == 'Road Intersection' or featureList[nestedNestedLinkedFeature].nameOfFeature == 'City') then
                                        linkedFeatures[feature[1]][nestedLinkedFeature][nestedNestedLinkedFeature] = true
                                    end
                                end
                            --end
                        end
                    end
                end
            end
        end
    end
end

function removeTile(xIndex, zIndex, removedTile)
    --if startingTile_GUID == tile.getGUID() then
    --    --TODO: find new tile to be the starting tile if one exists?
    --    startingTile_GUID = nil
    --end

    for _, featureNum in pairs(featureMap[xIndex][zIndex]) do
        --remove features
        featureList[featureNum] = nil
        for nestedX, featureColumn in pairs(featureMap) do
            for nestedZ, tileFeatures in pairs(featureColumn) do
                for nestedFeature, feature in pairs(tileFeatures) do
                    if feature == featureNum then
                        --remove from feature map
                        featureMap[nestedX][nestedZ][nestedFeature] = nil
                    end
                end
            end
        end

        --remove links
        for featureType, linkedSubFeatures in pairs(linkedFeatures) do
            linkedFeatures[featureType][featureNum] = nil
            for feature, _ in pairs(linkedSubFeatures) do
                if linkedFeatures[featureType][feature][featureNum] ~= nil then
                    linkedFeatures[featureType][feature][featureNum] = nil
                end
            end
        end
    end
    featureMap[xIndex][zIndex] = nil

    if removedTile.getTable('sides')[1] ~= 'Abbey' then
        local tempLinkedFeatures = {['City-Field'] = {}, ['Road Intersection'] = {}}

        for position=1, 12 do
            local connectedTilePosition, featureMapPosition
            local connectedX, connectedZ
            local direction
            if position < 5 then
                direction = (3 + position + TILE_STANDARD_ROTATION) % 4 + 1
                local sideDirection = (3 + position + TILE_STANDARD_ROTATION) % 4 + 1
                connectedX = xIndex + SIDE_DELTA[sideDirection].x
                connectedZ = zIndex + SIDE_DELTA[sideDirection].z
            else
                direction = (3 + position + TILE_STANDARD_ROTATION) % 8 + 5
                local sideDirection = math.floor(((3 + position + TILE_STANDARD_ROTATION) % 8 + 5 - 3) / 2)
                connectedX = xIndex + SIDE_DELTA[sideDirection].x
                connectedZ = zIndex + SIDE_DELTA[sideDirection].z
            end

            if tileGridOccupied(connectedX, connectedZ) then
                local connectedTile = getObjectFromGUID(tileGrid[connectedX][connectedZ].tile_guid)
                local connectedTileRotation = tileGrid[connectedX][connectedZ].rotation

                if position < 5 then
                    connectedTilePosition = (3 + position + TILE_STANDARD_ROTATION - connectedTileRotation + TILE_180_ROTATION) % 4 + 1
                    featureMapPosition = (3 + position + TILE_STANDARD_ROTATION - TILE_STANDARD_ROTATION + TILE_180_ROTATION) % 4 + 1
                else
                    connectedTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (connectedTileRotation * 2) - 4) % 8 + 5
                    featureMapPosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (TILE_STANDARD_ROTATION * 2) - 4) % 8 + 5
                end

                local nameOfFeature = getFeatureName(connectedTile, connectedTilePosition)
                if (position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River') and featureMap[connectedX][connectedZ][featureMapPosition] == nil then
                    --print(position .. ": checking x:" .. connectedX .. " z:" .. connectedZ .. " tilePosition:" .. connectedTilePosition .. " featureMapPosition:" .. featureMapPosition)
                    local openings = getFeatureComponents(connectedX, connectedZ, connectedTilePosition, 2, true, nameOfFeature == 'City')

                    featureIndex = featureIndex + 1
                    newFeatureIndex = tostring(featureIndex)

                    featureList[newFeatureIndex] = {}
                    featureList[newFeatureIndex].nameOfFeature = nameOfFeature
                    local specialFeatures = {}
                    for i, specialFeature in ipairs(transversedSpecialFeatures) do
                        if specialFeature ~= 'Road Intersection' and specialFeature ~= 'City-Field' and specialFeature ~= 'Completed City' then
                            table.insert(specialFeatures, specialFeature)
                        end
                    end
                    featureList[newFeatureIndex].specialFeatures = transversedSpecialFeatures
                    featureList[newFeatureIndex].openings = openings
                    if nameOfFeature ~= 'Field' then
                        featureList[newFeatureIndex].numTiles = #transversedTileCoords
                    else
                        featureList[newFeatureIndex].numTiles = 0
                    end
                    if nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                        featureList[newFeatureIndex].featureLocation = {x=connectedX, z=connectedZ}
                    end
                    tempLinkedFeatures['City-Field'][newFeatureIndex] = {}
                    tempLinkedFeatures['Road Intersection'][newFeatureIndex] = {}
                    for nestedXIndex, gridColumn in pairs(transversedFeaturePositions) do
                        for nestedZIndex, tileLocation in pairs(gridColumn) do
                            for nestedPosition, transversedFeaturePosition in pairs(tileLocation) do
                                local tile = getObjectFromGUID(tileGrid[nestedXIndex][nestedZIndex].tile_guid)
                                local rotation = tileGrid[nestedXIndex][nestedZIndex].rotation
                                --print("transversing " .. newFeatureIndex .. " to x: " .. nestedXIndex .. " z: " .. nestedZIndex .. " pos: " .. nestedPosition)
                                if nestedPosition < 13 or tile.getTable('specialFeatures')[nestedPosition - 12][3] ~= nil then
                                    if nestedPosition > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' then
                                        local nestedDirection = nestedPosition
                                        if nestedPosition < 5 then
                                            nestedDirection = (3 + nestedPosition + rotation + TILE_STANDARD_ROTATION) % 4 + 1
                                        elseif nestedPosition < 13 then
                                            nestedDirection = (3 + nestedPosition + ((rotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                                        end

                                        if transversedFeaturePosition == 1 then
                                            --print("assigning " .. newFeatureIndex .. " to x: " .. nestedXIndex .. " z: " .. nestedZIndex .. " dir: " .. nestedDirection .. " pos: " .. nestedPosition)
                                            featureMap[nestedXIndex][nestedZIndex][nestedDirection] = newFeatureIndex
                                        elseif transversedFeaturePosition == 2 then
                                            if nameOfFeature == 'Field' then
                                                table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedDirection})
                                            elseif nameOfFeature == 'City' then
                                                table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedDirection})
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    for nestedXIndex, gridColumn in pairs(transversedGrid) do
                        for nestedZIndex, tileLocation in pairs(gridColumn) do
                            for nestedPosition, transversedPosition in pairs(tileLocation) do
                                local tile = getObjectFromGUID(tileGrid[nestedXIndex][nestedZIndex].tile_guid)
                                local rotation = tileGrid[nestedXIndex][nestedZIndex].rotation
                                if nestedPosition < 13 or tile.getTable('specialFeatures')[nestedPosition - 12][3] ~= nil then
                                    if nestedPosition > 4 or getFeatureName(tile, nestedPosition) == 'Road' or getFeatureName(tile, nestedPosition) == 'River' then
                                        local nestedDirection = nestedPosition
                                        if nestedPosition < 5 then
                                            nestedDirection = (3 + nestedPosition + rotation + TILE_STANDARD_ROTATION) % 4 + 1
                                        elseif nestedPosition < 13 then
                                            nestedDirection = (3 + nestedPosition + ((rotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                                        end

                                        --print("transversed x: " .. nestedXIndex .. " z: " .. nestedZIndex .. " dir: " .. nestedDirection .. " pos: " .. nestedPosition)
                                        if transversedFeaturePositions[nestedXIndex] == nil or transversedFeaturePositions[nestedXIndex][nestedZIndex] == nil or transversedFeaturePositions[nestedXIndex][nestedZIndex][nestedPosition] == nil or transversedFeaturePositions[nestedXIndex][nestedZIndex][nestedPosition] == 2 then
                                            if getFeatureName(tile, nestedPosition) == 'Field' then
                                                --table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedDirection})
                                            elseif nameOfFeature == 'Field' then
                                                table.insert(tempLinkedFeatures['City-Field'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedDirection})
                                            else
                                                table.insert(tempLinkedFeatures['Road Intersection'][newFeatureIndex], {x=nestedXIndex, z=nestedZIndex, position=nestedDirection})
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        --re-add links
        for featureType, linkedFeatureCategory in pairs(tempLinkedFeatures) do
            for newFeatureIndex, categoryLinkedFeatures in pairs(linkedFeatureCategory) do
                for _, connectedFeatureDetails in ipairs(categoryLinkedFeatures) do
                    local connectedFeature = featureMap[connectedFeatureDetails.x][connectedFeatureDetails.z][connectedFeatureDetails.position]

                    if connectedFeature == nil and connectedFeatureDetails.position < 5 and featureMap[connectedFeatureDetails.x][connectedFeatureDetails.z][(connectedFeatureDetails.position * 2) + 3] ~= nil then
                        if featureList[featureMap[connectedFeatureDetails.x][connectedFeatureDetails.z][(connectedFeatureDetails.position * 2) + 3]].nameOfFeature ~= 'Road' and featureList[featureMap[connectedFeatureDetails.x][connectedFeatureDetails.z][(connectedFeatureDetails.position * 2) + 3]].nameOfFeature ~= 'River' then
                            connectedFeature = featureMap[connectedFeatureDetails.x][connectedFeatureDetails.z][(connectedFeatureDetails.position * 2) + 3]
                        end
                    end
                    if connectedFeature == nil then
                        allErrorMessage("no feature found at: x: " .. connectedFeatureDetails.x .. " z: " .. connectedFeatureDetails.z .. " pos: " .. connectedFeatureDetails.position)
                    else
                        if connectedFeature ~= newFeatureIndex then
                            if linkedFeatures[featureType][newFeatureIndex] == nil then
                                linkedFeatures[featureType][newFeatureIndex] = {}
                            end
                            --print("from location: x: " .. connectedFeatureDetails.x .. " z: " .. connectedFeatureDetails.z .. " pos: " .. connectedFeatureDetails.position)
                            --print("adding " .. featureType .. " link from " .. newFeatureIndex .. " to " .. connectedFeature)
                            linkedFeatures[featureType][newFeatureIndex][connectedFeature] = true
                            if linkedFeatures[featureType][connectedFeature] == nil then
                                linkedFeatures[featureType][connectedFeature] = {}
                            end
                            --print("adding " .. featureType .. " link from " .. connectedFeature .. " to " .. newFeatureIndex)
                            linkedFeatures[featureType][connectedFeature][newFeatureIndex] = true
                        end
                    end
                end
            end
        end
    end
end

function checkTileForHill()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if not controlPanelSettings['HnSDoNotBuryHills'] and specialFeature[1] == "Hill" then
                local buriedTile_obj = nil
                if buriedTile == nil then
                    local drawPile = getObjectFromGUID(tileStack_GUID)
                    if drawPile ~= nil then
                        local params = {}
                        params.position = {newTile.getPosition().x, newTile.getPosition().y + 1, newTile.getPosition().z}
                        buriedTile_obj = drawPile.takeObject(params)
                        buriedTile = buriedTile_obj.getGUID()
                    elseif finalTile_GUID ~= nil then
                        buriedTile = finalTile_GUID
                        buriedTile_obj = getObjectFromGUID(buriedTile)
                        local position = {newTile.getPosition().x, newTile.getPosition().y + 1, newTile.getPosition().z}
                        buriedTile_obj.setPositionSmooth(position)
                        finalTile_GUID = nil
                    else
                        allErrorMessage("Warning: Hill drawn but draw pile not found.")
                        allErrorMessage("This could be because the draw pile has only 1 tile left or none.")
                        allErrorMessage("If there is 1 tile left, it must be manually placed underneath the hill")
                        return nextState('next')
                    end
                else
                    buriedTile_obj = getObjectFromGUID(buriedTile)
                end

                buriedTile_obj.interactable = false
                newTile.use_gravity = false
                newTile.interactable = false
                newTile.setPositionSmooth({newTile.getPosition().x, newTile.getPosition().y + 2, newTile.getPosition().z}, false, false)
                Timer.create({identifier=newTile.getGUID() .. os.clock(), function_name='freezeFloatingHillTile', function_owner=nil, parameters={tile=newTile, buriedTile=buriedTile_obj}, delay=0.8})
                return
            end
        end
    end
    return nextState('next')
end

--the next 3 functions use Timers to create a sequence to allow for a tile to be buried underneath

--locks the tile for a moment to wait for the tile to be buried
function freezeFloatingHillTile(param)
    local tile = param.tile
    local buriedTile = param.buriedTile
    tile.setLock(true)
    Timer.create({identifier=tile.getGUID() .. os.clock(), function_name='unfreezeFloatingHillTile', function_owner=nil, parameters={tile=tile, buriedTile=buriedTile}, delay=0.5})
end

--unlock the tile and wait for it to fall back down
function unfreezeFloatingHillTile(param)
    local tile = param.tile
    local buriedTile = param.buriedTile
    tile.use_gravity = true
    tile.setLock(false)
    Timer.create({identifier=tile.getGUID() .. os.clock(), function_name='finishHillTile', function_owner=nil, parameters={tile=tile, buriedTile=buriedTile}, delay=0.8})
end

--lock the tile and other post tile actions
function finishHillTile(param)
    local tile = param.tile
    local buriedTile = param.buriedTile
    tile.interactable = true
    buriedTile.interactable = true
    if AUTOLOCK then
        buriedTile.setLock(true)
        tile.setLock(true)
    end
    return nextState('next')
end

function checkTileForVolcano()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if controlPanelSettings['PnDDragon'] and specialFeature[1] == "Volcano" then
                tileHasVolcano = true
                if not dragonHasAwaken then
                    dragonHasAwaken = true
                    gameNotification("The dragon has awaken!", NEUTRAL_COLOR, activePlayers[currentPlayer])
                end
                return moveDragonToTile(lastPlacedTileX, lastPlacedTileZ)
            end
        end
    end
    return nextState('next')
end

function checkTileForDragon()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if controlPanelSettings['PnDDragon'] and specialFeature[1] == "Dragon" then
                if dragonHasAwaken then
                    dragonMoveNumber = 1
                    dragonIllegalTiles = {}
                    currentMiniTurn = currentPlayer
                    local fairy = getObjectFromGUID(expansionBags['PnD'].contents['PnDFairy'].guid)
                    local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
                    if controlPanelSettings['PnDFairy'] and fairy ~= nil then
                        local xIndex = math.floor((fairy.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                        local zIndex = math.floor((fairy.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                        if tileGridOccupied(xIndex, zIndex) then
                            table.insert(dragonIllegalTiles, {xIndex, zIndex})
                            getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).highlightOn({1,0,0})
                        end
                    end
                    if dragon ~= nil then
                        local xIndex = math.floor((dragon.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                        local zIndex = math.floor((dragon.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                        if tileGridOccupied(xIndex, zIndex) then
                            table.insert(dragonIllegalTiles, {xIndex, zIndex})
                            getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).highlightOn({1,0,0})
                        end
                    end
                    allGameMessage("The dragon is on the move!", NEUTRAL_COLOR)
                    return nextState('has dragon')
                else
                    allGameMessage("Dragon tile played, but the dragon has not yet awaken.", NEUTRAL_COLOR)
                end
            end
        end
    end
    return nextState('no dragon')
end

function createDragonButtons()
    local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
    local xIndex = math.floor((dragon.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local zIndex = math.floor((dragon.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local hasValidMove = false
    for i=1, 4 do
        local newX = xIndex + SIDE_DELTA[i].x
        local newZ = zIndex + SIDE_DELTA[i].z
        if tileGridOccupied(newX, newZ) and not table.contains(dragonIllegalTiles, {newX, newZ}) then
            hasValidMove = true
            local label
            local font_size = 200
            if i == 1 then
                label = 'V'
                font_size = 120
            elseif i == 2 then label = '<'
            elseif i == 3 then label = '^'
            elseif i == 4 then label = '>'
            end
            local moveDragonButtonParam = {
               index = i, label = label, click_function = 'moveDragonButton',
               position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW * FLOATING_BUTTON_Y_SCALE, z=0}, width = 800, height=600, font_size = font_size, function_owner = nil
            }
            --createNormalizedArbitraryButton(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), moveDragonButtonParam, false)
            createNormalizedButton(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), moveDragonButtonParam, false)
        end
    end

    if hasValidMove then
        allGameMessage("Dragon move # " .. dragonMoveNumber .. ". " .. activePlayers[currentMiniTurn] .. "'s turn to move.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
    else
        allGameMessage("Dragon has no valid places to move to. Ending dragon movement.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
        return nextState('next')
    end
end

function moveDragonButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
        local dragonXIndex = math.floor((dragon.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local dragonZIndex = math.floor((dragon.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        for i=1, 4 do
            local newX = dragonXIndex + SIDE_DELTA[i].x
            local newZ = dragonZIndex + SIDE_DELTA[i].z
            if tileGridOccupied(newX, newZ) then
                getObjectFromGUID(tileGrid[newX][newZ].tile_guid).clearButtons()
                clearArbitraryButtons()
            end
        end

        local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        dragonMoveNumber = dragonMoveNumber + 1
        table.insert(dragonIllegalTiles, {xIndex, zIndex})
        getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).highlightOn({1,0,0})
        currentMiniTurn = currentMiniTurn + 1
        moveDragonToTile(xIndex, zIndex, rotation)
    end
end

function moveDragonToTile(xIndex, zIndex, rotation)
    local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
    local xDestination = (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x
    local zDestination = (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z

    local dragonTravelAngle = math.deg(math.atan2(dragon.getPosition().x - xDestination, dragon.getPosition().z - zDestination)) + 90
    if dragonTravelAngle > 360 then dragonTravelAngle = dragonTravelAngle - 360 end
    dragon.setLock(false)
    dragon.setRotationSmooth({0, dragonTravelAngle, 0})
    dragon.setPositionSmooth({xDestination, 1.5, zDestination})
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for _, object in ipairs(objs) do
        if object.getName() ~= 'Barn' and (table.contains(FOLLOWER_TYPES, object.getName()) or table.contains(SPECIAL_FIGURE_TYPES, object.getName()) or table.contains(SHEEP_TOKEN_TYPES, object.getName())) then
            if xIndex == math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
               zIndex == math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
               if table.contains(SHEEP_TOKEN_TYPES, object.getName()) then
                   local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
                   if sheepTileBag ~= nil then
                       allGameMessage(object.getDescription() .. " " .. object.getName() .. " eaten by the dragon! Om nom nom!", NEUTRAL_COLOR)
                       sheepTileBag.putObject(object)
                   else
                       allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to return sheep tokens")
                   end
               else
                    --an assumption is made here that there won't be more than 1 figure on the same tile that the figures are dependent on.
                    --It is possible for more than 1 figure from the same player to be on the same tile through use of the magic portal, but not on the same feature.
                    --Therefore, I think the assumption is safe unless there is interference from the players
                    table.insert(removedFigures, {guid=object.getGUID(), winner=false})
                    allGameMessage(object.getDescription() .. " " .. object.getName() .. " has been eaten by the dragon! Om nom nom!", player_color_tints[object.getDescription()])
                    removeDependentFigures(object)
                end
            end
        end
    end
    if #removedFigures > 0 then
        returnFigures()
    else
        nextState('dragon moved')
    end
end

function checkTileForMagicPortal()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if controlPanelSettings['PnDMagicPortal'] and specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if specialFeature[1] == "Magic Portal" then
                tileHasMagicPortal = true
            end
        end
    end
    return nextState('next')
end

function checkTileForGold()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if controlPanelSettings['GoldminesGold'] and specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if specialFeature[1] == "Gold" then
                return nextState('has gold')
            end
        end
    end
    return nextState('next')
end

function addGoldToTile(xIndex, zIndex)
    local goldbag = getObjectFromGUID(expansionBags['Goldmines'].contents['GoldminesGold'].guid)
    if goldbag ~= nil then
        local xDestination = (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x
        local zDestination = (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z

        local params = {}
        params.position = {xDestination, 1.5, zDestination}
        goldbag.takeObject(params)
    else

    end
    nextState('next')
end

function displayGoldButtons()
    for x=-1, 1 do
        for z=-1, 1 do
            if not (x == 0 and z == 0) then
                local newX = lastPlacedTileX + x
                local newZ = lastPlacedTileZ + z
                if tileGridOccupied(newX, newZ) then
                    local placeGoldButtonParam = {
                       index = i, label = "Place\nGold", click_function = 'placeGoldButton',
                       position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW * FLOATING_BUTTON_Y_SCALE, z=0}, width = 800, height=600, font_size = 200, function_owner = nil
                    }
                    --createNormalizedArbitraryButton(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), placeGoldButtonParam, false)
                    createNormalizedButton(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), placeGoldButtonParam, false)
                end
            end
        end
    end
end

function placeGoldButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        for x=-1, 1 do
            for z=-1, 1 do
                if not (x == 0 and z == 0) then
                    local newX = lastPlacedTileX + x
                    local newZ = lastPlacedTileZ + z
                    if tileGridOccupied(newX, newZ) then
                        getObjectFromGUID(tileGrid[newX][newZ].tile_guid).clearButtons()
                        clearArbitraryButtons()
                    end
                end
            end
        end

        local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        addGoldToTile(xIndex, zIndex)
    end
end

--check for special actions to take when the latest tile has added to or finished a feature
function checkAddedTileFeatureExtensions()
    --check if the new tile has completed the biggest city/longest road and award token
    --Note: you might think that this transversal could be combined with the below transversal, but it didn't work out
    --due to the way that i coded transversedTileCoords. It's a long story, but basically I would have to loop through the entire
    --table for each position on every tile. Had I coded it as an indexable table, I wouldn't be able to use the # operator
    --in order to see how many elements it transversed. Perhaps there is a better solution, but I'm hoping this won't cause any huge performance hits
    local longestNewRoad = 0
    local largestNewCity = 0
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    if newTile.getTable('sides')[1] ~= 'Abbey' then
        local specialFeatures = newTile.getTable('specialFeatures')
        for i=1, 12 do --roads and cities
            local hasPrincess = false
            if specialFeatures ~= nil and i >= 5 and controlPanelSettings['PnDPrincess'] then
                for featureNum, specialFeature in ipairs(specialFeatures) do
                    if controlPanelSettings['PnDPrincess'] and specialFeature[1] == "Princess" then
                        if table.contains(specialFeature[2], i) then
                            hasPrincess = true
                            table.remove(specialFeatures, featureNum) --remove it so we only add it once
                        end
                    end
                end
            end
            if (i < 5 and controlPanelSettings['KnRBRobber'] and newTile.getTable('sides')[i] == 'Road') or (i >= 5 and (controlPanelSettings['KnRBKing'] or hasPrincess) and newTile.getTable('sides')[math.floor((i - 3) / 2)] == 'City') then
                if getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, true) == 0 then
                    --since there is a chance of the player breaking the new city or road record twice, wait until afterwards to award the token
                    if newTile.getTable('sides')[i] == 'Road' and #transversedTileCoords > longestNewRoad then
                        longestNewRoad = #transversedTileCoords
                    elseif newTile.getTable('sides')[math.floor((i - 3) / 2)] == 'City' and #transversedTileCoords > largestNewCity then
                        largestNewCity = #transversedTileCoords
                    end
                end
                if hasPrincess then
                    for _, follower in ipairs(transversedFollowers) do
                        table.insert(seducedKnights, follower.getGUID())
                    end
                end
            end
        end
    else --if an abbey was used, then we cannot simply transverse it's features like above in order to find completed features. instead, we transverse the surrounding features
        for i=1, 12 do --roads and cities
            local tile = newTile
            local rotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation
            if i < 5 and controlPanelSettings['KnRBRobber'] then
                local direction = (3 + i + rotation) % 4 + 1
                local newX = lastPlacedTileX + SIDE_DELTA[direction].x
                local newZ = lastPlacedTileZ + SIDE_DELTA[direction].z
                if tileGridOccupied(newX, newZ) then
                    local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                    local newTileRotation = tileGrid[newX][newZ].rotation
                    local newTilePosition = (3 + i + rotation - newTileRotation + TILE_180_ROTATION) % 4 + 1
                    if getObjectFromGUID(tileGrid[newX][newZ].tile_guid).getTable('sides')[newTilePosition] == 'Road' then
                        if getFeatureComponents(newX, newZ, newTilePosition, 1, true) == 0 then
                            --since there is a chance of the player breaking the new city or road record twice, wait until afterwards to award the token
                            if #transversedTileCoords > longestNewRoad then
                                longestNewRoad = #transversedTileCoords
                            end
                        end
                    end
                end
            elseif i >= 5 and controlPanelSettings['KnRBKing'] then
                local direction = (3 + i + (rotation * 2)) % 8 + 5
                local newX = lastPlacedTileX + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                local newZ = lastPlacedTileZ + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                if tileGridOccupied(newX, newZ) then
                    local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                    local newTileRotation = tileGrid[newX][newZ].rotation
                    local newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (newTileRotation * 2) - 4) % 8 + 5
                    if getObjectFromGUID(tileGrid[newX][newZ].tile_guid).getTable('sides')[math.floor((newTilePosition - 3) / 2)] == 'City' then
                        if getFeatureComponents(newX, newZ, newTilePosition, 1, true) == 0 then
                            --since there is a chance of the player breaking the new city record twice, wait until afterwards to award the token
                            if #transversedTileCoords > largestNewCity then
                                largestNewCity = #transversedTileCoords
                            end
                        end
                    end
                end
            end
        end
    end
    if controlPanelSettings['KnRBRobber'] and longestNewRoad > longestRoad then
        longestRoad = longestNewRoad
        local awardToken = getObjectFromGUID(expansionBags['KnRB'].contents['KnRBRobber'].guid)
        local x, z = rotateCoordinates(9.4, 0.0, player_possession_areas[activePlayers[currentPlayer]].rotation)
        if awardToken ~= nil then
            awardToken.setPositionSmooth({player_possession_areas[activePlayers[currentPlayer]].x + x, 2, player_possession_areas[activePlayers[currentPlayer]].z + z})
            awardToken.setRotationSmooth({0,  player_possession_areas[activePlayers[currentPlayer]].rotation * -90, 0})
            allGameMessage(activePlayers[currentPlayer] .. " has been awarded the Robber Baron token for completing the longest road (" .. longestRoad .. " tiles)", player_color_tints[activePlayers[currentPlayer]])
        else
            allErrorMessage("Error: Robber Baron token missing! The token needs to remain out in order to awarded")
        end
    end
    if controlPanelSettings['KnRBKing'] and largestNewCity > largestCity then
        largestCity = largestNewCity
        local awardToken = getObjectFromGUID(expansionBags['KnRB'].contents['KnRBKing'].guid)
        local x, z = rotateCoordinates(11.4, 0.0, player_possession_areas[activePlayers[currentPlayer]].rotation)
        if awardToken ~= nil then
            awardToken.setPositionSmooth({player_possession_areas[activePlayers[currentPlayer]].x + x, 2, player_possession_areas[activePlayers[currentPlayer]].z + z})
            awardToken.setRotationSmooth({0,  player_possession_areas[activePlayers[currentPlayer]].rotation * -90, 0})
            allGameMessage(activePlayers[currentPlayer] .. " has been awarded the King token for completing the biggest city (" .. largestCity .. " tiles)", player_color_tints[activePlayers[currentPlayer]])
        else
            allErrorMessage("Error: King token missing! The token needs to remain out in order to awarded")
        end
    end

    resetTransversal()
    local specialFeatures = {}

    --check for various completed features, as well as features that have been added to, including:
    --shepherds on fields, builders in cities or on roads, trade tokens in cities that were just completed
    --i can't think of any reason that special features (13+) would need to be checked (yet)

    --need to do cities first, otherwise fields will mark them as visited
    --the above is no longer true after I added transversal levels to getFeatureComponents. I'll leave the code as it is since it doesn't hurt
    for i=1, 12 do --roads and cities
        if newTile.getTable('sides')[1] ~= 'Abbey' then
            if (i < 5 and newTile.getTable('sides')[i] == 'Road') or (i >= 5 and newTile.getTable('sides')[math.floor((i - 3) / 2)] == 'City') then
                if getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, false) == 0 then
                    for _, transversedSpecialFeature in ipairs(transversedSpecialFeatures) do
                        table.insert(specialFeatures, transversedSpecialFeature)
                    end
                end
                transversedSpecialFeatures = {}
            end
        else
            for i=1, 12 do --roads and cities
                local tile = newTile
                local rotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation
                if i < 5 then
                    local direction = (3 + i + rotation) % 4 + 1
                    local newX = lastPlacedTileX + SIDE_DELTA[direction].x
                    local newZ = lastPlacedTileZ + SIDE_DELTA[direction].z
                    if tileGridOccupied(newX, newZ) then
                        local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                        local newTileRotation = tileGrid[newX][newZ].rotation
                        local newTilePosition = (3 + i + rotation - newTileRotation + TILE_180_ROTATION) % 4 + 1

                        if getObjectFromGUID(tileGrid[newX][newZ].tile_guid).getTable('sides')[newTilePosition] == 'Road' then
                            if getFeatureComponents(newX, newZ, newTilePosition, 1, false) == 0 then
                                for _, transversedSpecialFeature in ipairs(transversedSpecialFeatures) do
                                    table.insert(specialFeatures, transversedSpecialFeature)
                                end
                            end
                            transversedSpecialFeatures = {}
                        end
                    end
                else
                    local direction = (3 + i + (rotation * 2)) % 8 + 5
                    local newX = lastPlacedTileX + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                    local newZ = lastPlacedTileZ + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                    if tileGridOccupied(newX, newZ) then
                        local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                        local newTileRotation = tileGrid[newX][newZ].rotation
                        local newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (newTileRotation * 2) - 4) % 8 + 5
                        if getObjectFromGUID(tileGrid[newX][newZ].tile_guid).getTable('sides')[math.floor((newTilePosition - 3) / 2)] == 'City' then
                            if getFeatureComponents(newX, newZ, newTilePosition, 1, false) == 0 then
                                for _, transversedSpecialFeature in ipairs(transversedSpecialFeatures) do
                                    table.insert(specialFeatures, transversedSpecialFeature)
                                end
                            end
                            transversedSpecialFeatures = {}
                        end
                    end
                end
            end
        end
    end

    for i=5, 12 do --fields
        if newTile.getTable('sides')[math.floor((i - 3) / 2)] ~= 'City' then
            getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, false)
        end
    end

    transversedSpecialFeatures = {}  --just in case I try to use it

    getFigureComponents()
    if controlPanelSettings['TnBTradeGoods'] then
        for _, specialFeature in ipairs(specialFeatures) do
            local tradeGoodPile
            local x, z

            if specialFeature == 'Cloth Token' then
                tradeGoodPile = getObjectFromGUID(expansionBags['TnB'].contents['TnBClothTokenStack'].guid)
                x, z = rotateCoordinates(6.9, 0.5, player_possession_areas[activePlayers[currentPlayer]].rotation)
            elseif specialFeature == 'Wine Token' then
                tradeGoodPile = getObjectFromGUID(expansionBags['TnB'].contents['TnBWineTokenStack'].guid)
                x, z = rotateCoordinates(6.9, -0.5, player_possession_areas[activePlayers[currentPlayer]].rotation)
            elseif specialFeature == 'Wheat Token' then
                tradeGoodPile = getObjectFromGUID(expansionBags['TnB'].contents['TnBWheatTokenStack'].guid)
                x, z = rotateCoordinates(7.9, 0.5, player_possession_areas[activePlayers[currentPlayer]].rotation)
            end

            if table.contains(TRADE_TOKEN_TYPES, specialFeature) then
                if tradeGoodPile ~= nil then
                    local params = {}
                    params.position = {player_possession_areas[activePlayers[currentPlayer]].x + x, 2, player_possession_areas[activePlayers[currentPlayer]].z + z}
                    params.rotation = {0,  player_possession_areas[activePlayers[currentPlayer]].rotation * -90, 0}
                    tradeGoodPile.takeObject(params)
                    allGameMessage(activePlayers[currentPlayer] .. " has been awarded a " .. specialFeature .. " for completing the city", player_color_tints[activePlayers[currentPlayer]])
                else
                    allErrorMessage("Error: " .. specialFeature .. " pile missing! The pile needs to remain out in order to draw trade goods")
                end
            end
        end
    end
    for _, figure in ipairs(transversedSpecialFigures) do
        if activePlayers[currentPlayer] ~= nil and figure.getDescription() == activePlayers[currentPlayer] and
           newTile.getTable('sides')[1] ~= 'Abbey' then --do not give give sheep/extra builder tile (CAR ref 149)
            if figure.getName() == 'Shepherd' then
                shepherdAwaitingAction = figure.getGUID()
            elseif figure.getName() == 'Builder' and not hasAlreadyTakenBuilderTile then
                hasBuilderAwaitingAction = true
            end
        end
    end
    return nextState('next')
end

--events that should occur after placing a valid tile
function displayFigureButtons()
    local labelButtonParam = {
       index = 1, label = 'Place a figure\nOR', click_function = 'doNothing',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT * FLOATING_BUTTON_Y_SCALE, z=1.8 * FLOATING_BUTTON_Z_SCALE}, width = 0, height=0, font_size = 200, function_owner = nil
    }
    --createNormalizedArbitraryButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), labelButtonParam, true)
    createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), labelButtonParam, true)
    local skipFigureButtonParam = {
       index = 2, label = 'Skip placing\nfigure', click_function = 'skipFigureButton',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT * FLOATING_BUTTON_Y_SCALE, z=2.5 * FLOATING_BUTTON_Z_SCALE}, width = 1400, height=600, font_size = 200, function_owner = nil
    }
    --createNormalizedArbitraryButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), skipFigureButtonParam, true)
    createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), skipFigureButtonParam, true)
    for _, knight in ipairs(seducedKnights) do
        local seduceKnightButtonParam = {
           index = 1, label = 'Seduce\nknight', click_function = 'seduceKnightButton',
           position = {x=0, y=3.0, z=2.0}, width = 1700, height=600, font_size = 200, function_owner = nil
        }
        createNormalizedButton(getObjectFromGUID(knight), seduceKnightButtonParam, true)
    end
    for _, obj in ipairs(getAllObjects()) do
        if obj.getName() == 'Abbot' and obj.getDescription() == activePlayers[currentPlayer] then
            local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            if tileGridOccupied(xIndex, zIndex) then
                local retrieveAbbotButtonParam = {
                   index = 1, label = 'Retrieve\nabbot', click_function = 'retrieveAbbotButton',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0 * FLOATING_BUTTON_Z_SCALE}, width = 1400, height=600, font_size = 200, function_owner = nil
                }
                --createNormalizedArbitraryButton(obj, retrieveAbbotButtonParam, true)
                createNormalizedButton(obj, retrieveAbbotButtonParam, true)
                currentPlayerAbbot = obj.getGUID()
                return --there shouldn't be multiple abbots for each player, but stop just in case
            end
        end
    end
end

--creates a button, which is rotated according to the object's current rotation, so that the buttons always face the active player
function createNormalizedButton(obj, param, rotateToPlayer)
    local player = activePlayers[currentPlayer]
    if currentMiniTurn ~= nil then
        player = activePlayers[currentMiniTurn]
    end
    if controlPanelSettings[player .. 'Control'] ~= nil then
        player = controlPanelSettings[player .. 'Control']
    end
    --default rotation is 180 degrees
    local playerRotation = 2
    if rotateToPlayer then
        playerRotation = player_possession_areas[player].rotation
    end
    local objRotation = math.floor((obj.getRotation().y + (TILE_ROTATION_MARGIN * 90)) / 90)
    local x, z = rotateCoordinates(param.position.x, param.position.z, ((-playerRotation - objRotation + 7) % 4) + 1)
    param.position = {x, param.position.y, z}
    --if objRotation == 1 or objRotation == 3 then
    --    param.scale = {x=10/7, y=1, z=1}
    --else
    --    param.scale = {x=7/10, y=1, z=1}
    --end

    local rotation = (obj.getRotation().y * -1) - (playerRotation * 90)
    --this method is currently bugged(?)
    --local rotation = (obj.getRotation().y * -1) + (Player[player].getPointerRotation())
    if rotation < 0 then rotation = rotation + 360 end
    param.rotation = {0,  rotation, 0}
    obj.createButton(param)
end

function createNormalizedArbitraryButton(obj, params, rotateToPlayer)
    local player = activePlayers[currentPlayer]
    if currentMiniTurn ~= nil then
        player = activePlayers[currentMiniTurn]
    end
    if controlPanelSettings[player .. 'Control'] ~= nil then
        player = controlPanelSettings[player .. 'Control']
    end
    --default rotation is 180 degrees
    local playerRotation = 2
    if rotateToPlayer then
        playerRotation = player_possession_areas[player].rotation
    end

    local objRotation = math.floor((obj.getRotation().y + (TILE_ROTATION_MARGIN * 90)) / 90)
    local x, z = rotateCoordinates(params.position.x, params.position.z, ((playerRotation + 7) % 4) + 1)
    params.position = {x + obj.getPosition().x, params.position.y + obj.getPosition().y, z + obj.getPosition().z}

    local rotation =  -(playerRotation * 90)
    --this method is currently bugged(?)
    --local rotation = (obj.getRotation().y * -1) + (Player[player].getPointerRotation())
    if rotation < 0 then rotation = rotation + 360 end
    params.rotation = {0,  rotation, 0}
    params.scale = {0.5, 0.5, 0.5}
    createArbitraryButton(params)
end

--creates a button at the given position, dimensions, scale, and rotation
function createArbitraryButton(params)
    local objectParams = {}
    objectParams.type = "ScriptingTrigger"
    objectParams.position = params.position
    objectParams.scale = params.scale
    local zoneObj = spawnObject(objectParams)

    buttonParams = {}
    buttonParams.position = {0, 0, 0}
    buttonParams.rotation = params.rotation
    buttonParams.width = params.width
    buttonParams.height = params.height
    buttonParams.index = 1
    buttonParams.label = params.label
    buttonParams.font_size = params.font_size
    buttonParams.click_function = params.click_function
    zoneObj.createButton(buttonParams)
    table.insert(arbitraryButtonAnchors, zoneObj)
end

--dummy function for dummy button
function doNothing()

end

function skipFigureButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        return nextState('skip figure')
    end
end

function seduceKnightButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        --although we later remove these buttons, there is a slight delay during the figure removal, so we remove them now
        clearArbitraryButtons()
        for _, knight in ipairs(seducedKnights) do
            getObjectFromGUID(knight).clearButtons()
        end

        table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        if object.getName() == 'Wagon' then
            allGameMessage(object.getDescription() .. " " .. object.getName() .. " has been seduced by the princess! Well not the wagon but the wagon crew... all of them... wow. Let's move on and forget this.", player_color_tints[object.getDescription()])
        else
        allGameMessage(object.getDescription() .. " " .. object.getName() .. " has been seduced by the princess! bow chicka wow wow~", player_color_tints[object.getDescription()])
        end
        removeDependentFigures(object)
        return nextState('seduce knight')
    end
end

function retrieveAbbotButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
            local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
            local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
            xPosition = xPosition - xIndex
            zPosition = zPosition - zIndex
            local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
            local rotation = tileGrid[xIndex][zIndex].rotation
            local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
            local nameOfFeature = getFeatureName(tile, closestFeature)
            getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)
            if nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                score = #transversedTileCoords
                allGameMessage(object.getDescription() .. " retrieves their abbot back for " .. score .. " points on " .. nameOfFeature, player_color_tints[object.getDescription()]) -- .. " with a strength of " .. value .. " followers", player_color_tints[player])
                scorePoints(object.getDescription(), nameOfFeature, score)
                table.insert(removedFigures, {guid=object.getGUID(), winner=true})
                object.setLock(false)
                object.use_gravity = false
                object.interactable = false
                --raise the follower in the air
                object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)

                if showMarkers == 'Both' or showMarkers == 'Scoring' then
                    Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                else
                    returnFigures()
                end
                clearFigureOptions()
                return nextState('retrieve abbot')
            end
        end
    end
    allErrorMessage("Error: The abbot is currently on an invalid feature. Abbots can only be placed on gardens and cloisters.", activePlayers[currentPlayer])
end

--adds any special figures that were dependent on this figure to the removed figure list
function removeDependentFigures(object)
    local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
    local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
    xPosition = xPosition - xIndex
    zPosition = zPosition - zIndex
    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
    local rotation = tileGrid[xIndex][zIndex].rotation
    local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
    getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)
    local followersCount = 0
    for _, follower in ipairs(transversedFollowers) do
        if follower.getGUID() ~= object.getGUID() and follower.getDescription() == object.getDescription() then
            followersCount = followersCount + 1
        end
    end
    if followersCount == 0 then
        for _, figure in ipairs(transversedSpecialFigures) do
            if (figure.getName() == 'Pig' or figure.getName() == 'Builder') and figure.getDescription() == object.getDescription() then
                table.insert(removedFigures, {guid=figure.getGUID(), winner=false})
                allGameMessage(figure.getDescription() .. " no longer has a follower for their " .. figure.getName() .. " and must be removed.", player_color_tints[figure.getDescription()])
            end
        end
    end
end

function checkFigure(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID != nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
        if newFigure.held_by_color == nil then
            if not (lastPlacedTileX == nil or lastPlacedTileZ == nil) then
                local xIndex = math.floor((newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                if newFigure.getName() == 'Fairy' then
                    if tileGridOccupied(xIndex, zIndex) then
                        local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                        for _, follower in ipairs(objs) do
                            if follower.getDescription() == activePlayers[currentPlayer] and table.contains(FOLLOWER_TYPES, follower.getName()) then
                                if xIndex == math.floor((follower.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
                                 zIndex == math.floor((follower.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
                                    if AUTOLOCK then
                                       newFigure.setLock(true)
                                    end
                                    return nextState('placed fairy')
                                end
                            end
                        end
                    end
                    allErrorMessage("Invalid Location: Fairy must be placed on a tile containing a follower owned by you.", activePlayers[currentPlayer])
                    return
                end
                local tile, rotation
                if tileGridOccupied(xIndex, zIndex) then
                    tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    rotation = tileGrid[xIndex][zIndex].rotation
                else
                    --allErrorMessage("Invalid Location: Figure was not placed on a tile", activePlayers[currentPlayer])
                    return
                end
                if (xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ) or (tileHasMagicPortal and table.contains(FOLLOWER_TYPES, newFigure.getName())) or newFigure.getName() == 'Barn' then
                    local xPosition = (newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local zPosition = (newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    --debugMessage(3, "piece position: x: " .. xPosition .. " z: " .. zPosition)
                    local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
                    local nameOfFeature = getFeatureName(tile, closestFeature)
                    local featureOpenings
                    if closestFeature < 5 then
                        if nameOfFeature == 'Road' then
                            --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                            featureOpenings = getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
                        else
                            --check to make sure both octants in this quadrant are linked, then choose one arbitrary octant and check
                            local links = tile.getTable('linkedOctants')
                            local hasLink = false
                            for _, link in ipairs(links) do
                                if not hasLink and table.contains(link, (closestFeature * 2) + 3) and table.contains(link, (closestFeature * 2) + 4) then
                                    --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                                    featureOpenings = getFeatureComponents(xIndex, zIndex, (closestFeature * 2) + 3, 1, true)
                                    hasLink = true
                                end
                            end
                            if not hasLink then
                                allErrorMessage("Invalid Location: You must put the figure on one side of the feature or the other.", activePlayers[currentPlayer])
                                return
                            end
                        end
                    else
                        --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                        featureOpenings = getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
                    end
                    if isValidFigureLocation(newFigure, xIndex, zIndex, closestFeature, nameOfFeature, featureOpenings, true, true) then
                        if string.sub(nameOfFeature,1,6) == 'Flier-' then
                            flier = newFigure.getGUID()
                            if string.sub(nameOfFeature,7,7) == 'W' then flierDirection = 8 else flierDirection = 1 end --assumed to be Flier-NW if it is not Flier-W
                            flierDirection = flierDirection + ((rotation - TILE_STANDARD_ROTATION) * 2)
                            if flierDirection > 8 then flierDirection = flierDirection - 8 end
                            if flierDirection < 1 then flierDirection = flierDirection + 8 end
                            return nextState('placed flier')
                        end
                        if AUTOLOCK then
                            newFigure.setLock(true)
                        end
                        allGameMessage(newFigure.getDescription() .. " " .. newFigure.getName() .. " placed on " .. nameOfFeature, player_color_tints[newFigure.getDescription()])
                        if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' or nameOfFeature == 'Shrine' then
                            local challengerTile, challengedTile
                            if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                                challengerTile = 'Cloister'
                                challengedTile = 'Shrine'
                            else
                                challengerTile = 'Shrine'
                                challengedTile = 'Cloister'
                            end
                            for x=-1, 1 do
                                for z=-1, 1 do
                                    if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                        local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
                                        if specialFeatures ~= nil then
                                            for i, feature in ipairs(specialFeatures) do
                                                local adjacentFeature = feature[1]
                                                if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                if adjacentFeature == challengedTile then
                                                    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                    for _, object in ipairs(objs) do
                                                        if table.contains(FOLLOWER_TYPES, object.getName()) then
                                                            local objectXIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                                            local objectZIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                                            if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                                local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                                                                local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                                                                xPosition = xPosition - objectXIndex
                                                                zPosition = zPosition - objectZIndex
                                                                local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), rotation)
                                                                if closestFeature == i + 12 then
                                                                    allGameMessage(object.getDescription() .. " " .. object.getName() .. " on " .. feature[1] .. " has been challenged!", player_color_tints[object.getDescription()])
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        local pieceRotation = 0
                        if closestFeature < 5 then pieceRotation = (closestFeature - 1) * 90
                        elseif closestFeature < 13 then pieceRotation = math.floor((closestFeature - 5) / 2) * 90 end
                        if (newFigure.getName() == 'Follower' or newFigure.getName() == 'Big Follower') and nameOfFeature == 'Field' then
                            --lay the Follower down
                            newFigure.setRotation({tile.getRotation().x + 90, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        else
                            --align with the tile
                            newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        end
                        if newFigure.getName() == 'Barn' then
                            newBarn = newFigure.getGUID()
                        end
                        if newFigure.getName() == 'Shepherd' then
                            shepherdAwaitingAction = newFigure.getGUID()
                            return nextState('placed shepherd')
                        else
                            return nextState('placed figure')
                        end
                    end
                else
                    allErrorMessage("Invalid Location: You must place the figure on the tile you had just placed.", activePlayers[currentPlayer])
                end
            else
                allErrorMessage("You must place a tile before placing a figure.", activePlayers[currentPlayer])
            end
        else
            allErrorMessage("Follower picked up before validation. Please replace tile.", activePlayers[currentPlayer])
        end
    end
end

--checks if this position is on a corner or 4 tiles containing nothing but fields
--assumes that the given feature has already been checked and is a field
--returns true if it is, false otherwise
function checkBarn(closestFeature, xIndex, zIndex)
    tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
    rotation = tileGrid[xIndex][zIndex].rotation
    --NOTE: the following equation gives the other feature location on the same corner: ((closestFeature % 2) * -2) + 1 - 5) % 8 + 5
    if closestFeature > 12 or closestFeature < 5 then return false end
    local valid = false
    local includesLastTile = false
    if xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ then includesLastTile = true end
    local links = tile.getTable('linkedOctants')
    if links == nil then return false end
    for _, link in ipairs(links) do
        --check if both sides of the corner are linked together
        if table.contains(link, closestFeature) and table.contains(link, (closestFeature + ((closestFeature % 2) * -2) + 1 - 5) % 8 + 5) then
            -- go over both neighboring tiles
            for i, position in ipairs({closestFeature, (closestFeature + ((closestFeature % 2) * -2) + 1 - 5) % 8 + 5}) do
                local newTileDirection = (3 + position + (rotation * 2)) % 8 + 5
                local newX = xIndex + SIDE_DELTA[math.floor((newTileDirection - 3) / 2)].x
                local newZ = zIndex + SIDE_DELTA[math.floor((newTileDirection - 3) / 2)].z
                if newX == lastPlacedTileX and newZ == lastPlacedTileZ then includesLastTile = true end
                if not tileGridOccupied(newX, newZ) then return false end
                local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                local newTileRotation = tileGrid[newX][newZ].rotation
                local newTilePosition = (((newTileDirection % 2) * 2) + TILE_180_ROTATION + newTileDirection - (newTileRotation * 2) - 4) % 8 + 5
                if getFeatureName(newTile, newTilePosition) ~= 'Field' then return false end
                links = newTile.getTable('linkedOctants')
                if links == nil then return false end
                for _, link in ipairs(links) do
                    if table.contains(link, newTilePosition) and table.contains(link, (newTilePosition + ((newTilePosition % 2) * -2) + 1 - 5) % 8 + 5) then
                        local lastTileDirection = (3 + ((newTilePosition + ((newTilePosition % 2) * -2) + 1 - 5) % 8 + 5) + (newTileRotation * 2)) % 8 + 5
                        local lastX = newX + SIDE_DELTA[math.floor((lastTileDirection - 3) / 2)].x
                        local lastZ = newZ + SIDE_DELTA[math.floor((lastTileDirection - 3) / 2)].z
                        if lastX == lastPlacedTileX and lastZ == lastPlacedTileZ then includesLastTile = true end
                        if tileGrid[lastX] == nil or tileGrid[lastX][lastZ] == nil then return false end
                        local lastTile = getObjectFromGUID(tileGrid[lastX][lastZ].tile_guid)
                        local lastTileRotation = tileGrid[lastX][lastZ].rotation
                        local lastTilePosition = (((lastTileDirection % 2) * 2) + TILE_180_ROTATION + lastTileDirection - (lastTileRotation * 2) - 4) % 8 + 5
                        if getFeatureName(lastTile, lastTilePosition) ~= 'Field' then return false end
                        --only need to check the links once
                        if i == 2 then
                            --check if both sides of the corner are linked together
                            links = lastTile.getTable('linkedOctants')
                            if links == nil then return false end
                            for _, link in ipairs(links) do
                                if table.contains(link, lastTilePosition) and table.contains(link, (lastTilePosition + ((lastTilePosition % 2) * -2) + 1 - 5) % 8 + 5) then
                                    --if it managed to get to this point, then all conditions have been met
                                    valid = true
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if not includesLastTile then
        valid = false
    end
    return valid
end

function checkWagon(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID != nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
        if newFigure.getName() ~= 'Wagon' then
            allErrorMessage("Error: You are only allowed to place the wagon at this time.", activePlayers[currentPlayer])
            return
        end
        if newFigure.held_by_color == nil then
            if currentMiniTurn ~= nil then
                local xIndex = math.floor((newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                local xPosition = (newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local rotation = tileGrid[xIndex][zIndex].rotation
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    --debugMessage(1, "wagon position: x: " .. xPosition .. " z: " .. zPosition)
                    local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
                    local nameOfFeature = getFeatureName(tile, closestFeature)
                    local featureOpenings
                    if closestFeature < 5 then
                        if nameOfFeature == 'Road' then
                            --need a transversal level of 2 in order to transverse road intersections
                            featureOpenings = getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)
                        else
                            --check to make sure both octants in this quadrant are linked, then choose one arbitrary octant and check
                            local links = tile.getTable('linkedOctants')
                            local hasLink = false
                            for _, link in ipairs(links) do
                                if not hasLink and table.contains(link, (closestFeature * 2) + 3) and table.contains(link, (closestFeature * 2) + 4) then
                                    --need a transversal level of 2 in order to transverse road intersections
                                    featureOpenings = getFeatureComponents(xIndex, zIndex, (closestFeature * 2) + 3, 2, true)
                                    hasLink = true
                                end
                            end
                            if not hasLink then
                                allErrorMessage("Invalid Location: You must put the wagon on one side of the feature or the other.", activePlayers[currentPlayer])
                                return
                            end
                        end
                    else
                        --need a transversal level of 2 in order to transverse road intersections
                        featureOpenings = getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)
                    end
                    if isValidWagonLocation(newFigure, xIndex, zIndex, closestFeature, nameOfFeature, featureOpenings, true, true) then
                        if AUTOLOCK then
                            newFigure.setLock(true)
                        end
                        clearArbitraryButtons()
                        allGameMessage(newFigure.getDescription() .. " " .. newFigure.getName() .. " placed on " .. nameOfFeature, player_color_tints[newFigure.getDescription()])
                        local pieceRotation = 0
                        if closestFeature < 5 then pieceRotation = (closestFeature - 1) * 90
                        elseif closestFeature < 13 then pieceRotation = math.floor((closestFeature - 5) / 2) * 90 end
                        newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        wagonLocations[activePlayers[currentMiniTurn]] = nil
                        return replaceFinishedWagons()
                    end
                else
                    allErrorMessage("Invalid Location: No tile found.", activePlayers[currentPlayer])
                end
            end
        else
            allErrorMessage("Follower picked up before validation. Please replace tile", activePlayers[currentPlayer])
        end
    end
end

function checkFlier(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID != nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        if flier == lastDroppedObject_GUID then
            local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
            if newFigure.held_by_color == nil then
                local xIndex = math.floor((newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)

                local tile, rotation
                if tileGridOccupied(xIndex, zIndex) then
                    tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    rotation = tileGrid[xIndex][zIndex].rotation
                else
                    --allErrorMessage("Invalid Location: Figure was not placed on a tile", activePlayers[currentPlayer])
                    return
                end

                if (xIndex == lastPlacedTileX + flierOffset.x and zIndex == lastPlacedTileZ + flierOffset.z) then
                    local xPosition = (newFigure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local zPosition = (newFigure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    --debugMessage(3, "piece position: x: " .. xPosition .. " z: " .. zPosition)
                    local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
                    local nameOfFeature = getFeatureName(tile, closestFeature)
                    local featureOpenings
                    if closestFeature < 5 then
                        if nameOfFeature == 'Road' then
                            --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                            featureOpenings = getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
                        else
                            --check to make sure both octants in this quadrant are linked, then choose one arbitrary octant and check
                            local links = tile.getTable('linkedOctants')
                            local hasLink = false
                            for _, link in ipairs(links) do
                                if not hasLink and table.contains(link, (closestFeature * 2) + 3) and table.contains(link, (closestFeature * 2) + 4) then
                                    --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                                    featureOpenings = getFeatureComponents(xIndex, zIndex, (closestFeature * 2) + 3, 1, true)
                                    hasLink = true
                                end
                            end
                            if not hasLink then
                                allErrorMessage("Invalid Location: You must put the flier on one side of the feature or the other.", activePlayers[currentPlayer])
                                return
                            end
                        end
                    else
                        --only using transversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                        featureOpenings = getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
                    end
                    if isValidFlierLocation(newFigure, xIndex, zIndex, closestFeature, nameOfFeature, featureOpenings, true, true) then
                        if AUTOLOCK then
                            newFigure.setLock(true)
                        end
                        allGameMessage(newFigure.getDescription() .. " " .. newFigure.getName() .. " placed on " .. nameOfFeature, player_color_tints[newFigure.getDescription()])
                        if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' or nameOfFeature == 'Shrine' then
                            local challengerTile, challengedTile
                            if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                                challengerTile = 'Cloister'
                                challengedTile = 'Shrine'
                            else
                                challengerTile = 'Shrine'
                                challengedTile = 'Cloister'
                            end
                            for x=-1, 1 do
                                for z=-1, 1 do
                                    if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                        local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
                                        if specialFeatures ~= nil then
                                            for i, feature in ipairs(specialFeatures) do
                                                local adjacentFeature = feature[1]
                                                if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                if adjacentFeature == challengedTile then
                                                    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                    for _, object in ipairs(objs) do
                                                        if table.contains(FOLLOWER_TYPES, object.getName()) then
                                                            local objectXIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                                            local objectZIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                                            if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                                local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                                                                local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                                                                xPosition = xPosition - objectXIndex
                                                                zPosition = zPosition - objectZIndex
                                                                local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), rotation)
                                                                if closestFeature == i + 12 then
                                                                    allGameMessage(object.getDescription() .. " " .. object.getName() .. " on " .. feature[1] .. " has been challenged!", player_color_tints[object.getDescription()])
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        local pieceRotation = 0
                        if closestFeature < 5 then pieceRotation = (closestFeature - 1) * 90
                        elseif closestFeature < 13 then pieceRotation = math.floor((closestFeature - 5) / 2) * 90 end
                        --align with the tile
                        newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        return nextState('placed flier')
                    end
                else
                    allErrorMessage("Invalid Location: You must place the figure on the tile corresponding to the flier dice roll.", activePlayers[currentPlayer])
                end
            else
                allErrorMessage("Follower picked up before validation. Please replace tile.", activePlayers[currentPlayer])
            end
        else
            allErrorMessage("Can only place the follower that was used on the flier.", activePlayers[currentPlayer])
        end
    end
end

function clearFigureOptions()
    clearArbitraryButtons()
    if flierOffset ~= nil and tileGrid[lastPlacedTileX + flierOffset.x] ~= nil and tileGrid[lastPlacedTileX + flierOffset.x][lastPlacedTileZ + flierOffset.z] ~= nil then
        local possibleTile = getObjectFromGUID(tileGrid[lastPlacedTileX + flierOffset.x][lastPlacedTileZ + flierOffset.z].tile_guid)
        if possibleTile ~= nil then
            possibleTile.highlightOff()
        end
    end
    local fairy = getObjectFromGUID(expansionBags['PnD'].contents['PnDFairy'].guid)
    if controlPanelSettings['PnDFairy'] and fairy ~= nil then
        fairy.setLock(true)
        fairy.highlightOff()
    end
end

function clearArbitraryButtons()
    if lastPlacedTileX ~= nil then
        getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
    end
    if currentPlayerAbbot ~= nil then
        getObjectFromGUID(currentPlayerAbbot).clearButtons()
    end
    for _, knight in ipairs(seducedKnights) do
        getObjectFromGUID(knight).clearButtons()
    end
    if shepherdAwaitingAction ~= nil then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        shepherd.clearButtons()
    end
    for _, buttonAnchor in ipairs(arbitraryButtonAnchors) do
        buttonAnchor.destruct()
    end
    arbitraryButtonAnchors = {}
end

--will go through all possible locations on the field and find an empty spot where the sheep tile can be put
--Note: according to this forum post, this behavior actually violates the rules: https://boardgamegeek.com/thread/1434965/question-about-location-sheep-tokens
-- At first, I thought I could get around this by making the dragon not eat the sheep, but in the event that multiple fields are joined together, there needs to be a way to separate the different sheep groups
function addSheepToField(shepherd)
    --no error checking for the shepherd. Assume that it is still in a legal position
    local shepherdTileXIndex = math.floor((shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local shepherdTileZIndex = math.floor((shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local shepherdxPosition = (shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
    local shepherdzPosition = (shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
    shepherdxPosition = shepherdxPosition - shepherdTileXIndex
    shepherdzPosition = shepherdzPosition - shepherdTileZIndex
    local shepherdClosestFeature = findClosestFeature(shepherdxPosition, shepherdzPosition, getObjectFromGUID(tileGrid[shepherdTileXIndex][shepherdTileZIndex].tile_guid), tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation)
    getFeatureComponents(shepherdTileXIndex, shepherdTileZIndex, shepherdClosestFeature, 1, true)
    --now that we've transversed for this shepherd, check all positions in the field for an open spot
    for _, transversedTileCoord in ipairs(transversedTileCoords) do
        if transversedFeaturePositions[transversedTileCoord.x] ~= nil and transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z] ~= nil then
            for location, transversedFeaturePosition in pairs(transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z]) do
                if location > 4 and location < 13 and transversedFeaturePosition == 1 then
                    local occupied = false
                    --debugMessage(1, "checking x: " .. transversedTileCoord.x .. " z: " .. transversedTileCoord.z .. " location: " .. location .. " for empty sheep location")
                    for _, figureSet in ipairs({transversedFollowers, transversedSheepTokens, transversedSpecialFigures}) do
                        for _, figure in ipairs(figureSet) do
                            local xIndex = math.floor((figure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                            local zIndex = math.floor((figure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                            if xIndex == transversedTileCoord.x and zIndex == transversedTileCoord.z then
                                local xPosition = (figure.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                                local zPosition = (figure.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                                xPosition = xPosition - xIndex
                                zPosition = zPosition - zIndex
                                local x, z = getFeatureLocation(location, getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid), tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation)
                                if ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) < 0.1 then
                                    --debugMessage(2, "Too close to sheep location (" .. ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) .. ")")
                                    occupied = true
                                    break
                                end
                            end
                        end
                    end
                    if not occupied then
                        local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
                        if sheepTileBag ~= nil then
                            local params = {}
                            local x, z = getFeatureLocation(location, getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid), tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation)
                            params.position = {x=(x * TILE_SPACING) + (transversedTileCoord.x * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, y=1.5, z=(z * TILE_SPACING) + (transversedTileCoord.z * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}

                            local direction = (3 + location + (tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation * 2)) % 8 + 5
                            params.position.x = params.position.x - (SIDE_DELTA[math.floor((direction - 3) / 2)].x * 0.1 * TILE_SPACING)
                            params.position.z = params.position.z - (SIDE_DELTA[math.floor((direction - 3) / 2)].z * 0.1 * TILE_SPACING)

                            sheepTileBag.shuffle()
                            local newTile = sheepTileBag.takeObject(params)
                            if newTile.getName() == "Wolf" then
                                Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='scoreFlock', function_owner=nil, parameters={shepherd=shepherd}, delay=2.5})
                            else
                                Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=2.5})
                            end
                            return
                        else
                            allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to draw sheep tokens")
                            return
                        end
                    end
                end
            end
        end
    end
    gameNotification("No more room on field! Placing sheep on shepherd", NEUTRAL_COLOR, activePlayers[currentPlayer])
    addSheepToShepherd(shepherd)
end

--adds a sheep to the tile that the shepherd is on, if there is room
function addSheepToTile(shepherd)
    --no error checking for the shepherd. Assume that it is still in a legal position
    local shepherdTileXIndex = math.floor((shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local shepherdTileZIndex = math.floor((shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local tile = getObjectFromGUID(tileGrid[shepherdTileXIndex][shepherdTileZIndex].tile_guid)
    local rotation = tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation
    local shepherdxPosition = (shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
    local shepherdzPosition = (shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
    shepherdxPosition = shepherdxPosition - shepherdTileXIndex
    shepherdzPosition = shepherdzPosition - shepherdTileZIndex
    local shepherdClosestFeature = findClosestFeature(shepherdxPosition, shepherdzPosition, getObjectFromGUID(tileGrid[shepherdTileXIndex][shepherdTileZIndex].tile_guid), tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation)
    for _, linkedOctants in pairs(tile.getTable('linkedOctants')) do
        if table.contains(linkedOctants, shepherdClosestFeature) then
            for _, location in pairs(linkedOctants) do
                local x, z = getFeatureLocation(location, tile, rotation)
                local occupied = false
                local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                for _, object in ipairs(objs) do
                    if table.contains(FOLLOWER_TYPES, object.getName()) or table.contains(SPECIAL_FIGURE_TYPES, object.getName()) or
                    table.contains(NEUTRAL_FIGURE_TYPES, object.getName()) or table.contains(SHEEP_TOKEN_TYPES, object.getName()) then
                        local xIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                        local zIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                        if xIndex == shepherdTileXIndex and zIndex == shepherdTileZIndex then
                            local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                            local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                            xPosition = xPosition - xIndex
                            zPosition = zPosition - zIndex
                            if ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) < 0.1 then
                                --debugMessage(2, "Too close to sheep location (" .. ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) .. ")")
                                occupied = true
                                break
                            end
                        end
                    end
                end
                if not occupied then
                    local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
                    if sheepTileBag ~= nil then
                        local params = {}
                        params.position = {x=(x * TILE_SPACING) + (shepherdTileXIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, y=1.5, z=(z * TILE_SPACING) + (shepherdTileZIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}

                        local direction = (3 + location + (tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation * 2)) % 8 + 5
                        params.position.x = params.position.x - (SIDE_DELTA[math.floor((direction - 3) / 2)].x * 0.1 * TILE_SPACING)
                        params.position.z = params.position.z - (SIDE_DELTA[math.floor((direction - 3) / 2)].z * 0.1 * TILE_SPACING)

                        sheepTileBag.shuffle()
                        local newTile = sheepTileBag.takeObject(params)
                        if newTile.getName() == "Wolf" then
                            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='scoreFlock', function_owner=nil, parameters={shepherd=shepherd}, delay=2.5})
                        else
                            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=2.5})
                        end
                        return
                    else
                        allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to draw sheep tokens")
                        return
                    end
                end
            end
        end
    end
    gameNotification("No more room on field! Placing sheep on shepherd", NEUTRAL_COLOR, activePlayers[currentPlayer])
    addSheepToShepherd(shepherd)
end

--findClosestFeatureMap
-- params:
--  int: x
--  int: z
--  obj: tile to check
--  int: rotation (1-4)
-- returns:
--  int: 1-4 for quadrants, 5-12 for octants, 13.. for additional features
function findClosestFeatureMap(xPosition, zPosition, tile, rotation)
    --debugMessage(3, "finding closest feature for object at x:" .. xPosition .. " z:" .. zPosition .. " for rotation:" .. rotation)
    local rotatedXPosition, rotatedZPosition = rotateCoordinates(xPosition, zPosition, ((rotation + TILE_STANDARD_ROTATION - 1) % 4) + 1)

    local position = 1
    local closestFeature = 1
    local closestDistance = 999 --presumably every position should be closer than this

    for a = 0, 1 do -- a==0 is for quadrants, a==1 is for octants
        for side = 1, 4 do
            for j = 0, a do -- should do 1 loop for quadrants, 2 loops for octants
                local x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, 5 - side)
                local distance = (xPosition - x) * (xPosition - x) + (zPosition - z) * (zPosition - z)
                --debugMessage(3, "compare to position " .. position .. ": x: " .. x .. " z: " .. z .. " distance: " .. distance)
                if distance < closestDistance then
                    closestFeature = position
                    closestDistance = distance
                end
                position = position + 1
            end
        end
    end
    local specialFeatures = tile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        --check for specialFeatures with a position
        for _, feature in ipairs(specialFeatures) do
            if feature[3] ~= nil then
                local distance = (rotatedXPosition - feature[3][1]) * (rotatedXPosition - feature[3][1]) + (rotatedZPosition - feature[3][2]) * (rotatedZPosition - feature[3][2])
                --debugMessage(3, "compare to position " .. position .. ": x: " .. feature[3][1] .. " z: " .. feature[3][2] .. " distance: " .. distance)
                if distance < closestDistance then
                    closestFeature = position
                    closestDistance = distance
                end
            end
            position = position + 1
        end
    end
    return closestFeature
end



--findClosestFeature
-- params:
--  int: x
--  int: z
--  obj: tile to check
--  int: rotation (1-4)
-- returns:
--  int: 1-4 for quadrants, 5-12 for octants, 13.. for additional features
function findClosestFeature(xPosition, zPosition, tile, rotation)
    --debugMessage(3, "finding closest feature for object at x:" .. xPosition .. " z:" .. zPosition .. " for rotation:" .. rotation)
    xPosition, zPosition = rotateCoordinates(xPosition, zPosition, ((rotation + TILE_STANDARD_ROTATION - 1) % 4) + 1)

    local position = 1
    local closestFeature = 1
    local closestDistance = 999 --presumably every position should be closer than this

    for a = 0, 1 do -- a==0 is for quadrants, a==1 is for octants
        for side = 1, 4 do
            for j = 0, a do -- should do 1 loop for quadrants, 2 loops for octants
                local x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, 5 - side)
                local distance = (xPosition - x) * (xPosition - x) + (zPosition - z) * (zPosition - z)
                --debugMessage(3, "compare to position " .. position .. ": x: " .. x .. " z: " .. z .. " distance: " .. distance)
                if distance < closestDistance then
                    closestFeature = position
                    closestDistance = distance
                end
                position = position + 1
            end
        end
    end
    local specialFeatures = tile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        --check for specialFeatures with a position
        for _, feature in ipairs(specialFeatures) do
            if feature[3] ~= nil then
                local distance = (xPosition - feature[3][1]) * (xPosition - feature[3][1]) + (zPosition - feature[3][2]) * (zPosition - feature[3][2])
                --debugMessage(3, "compare to position " .. position .. ": x: " .. feature[3][1] .. " z: " .. feature[3][2] .. " distance: " .. distance)
                if distance < closestDistance then
                    closestFeature = position
                    closestDistance = distance
                end
            end
            position = position + 1
        end
    end
    return closestFeature
end

function promptShepherd()
    if shepherdAwaitingAction ~= nil then
        -- local shepherdExpandButtonParam = {
        --    index = 1, label = 'Expand the\nflock', click_function = 'addSheepToFlockButton',
        --    position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.5}, width = 1400, height=700, font_size = 200, function_owner = nil
        -- }
        -- local shepherdHerdButtonParam = {
        --    index = 2, label = 'Herd the flock\ninto the stable', click_function = 'scoreFlockButton',
        --    position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=2.3}, width = 1400, height=700, font_size = 200, function_owner = nil
        -- }
        local shepherdExpandButtonParam = {
           index = 1, label = 'Expand the\nflock', click_function = 'addSheepToFlockButton',
           position = {x=0, y=3, z=1.5 * FLOATING_BUTTON_Z_SCALE}, width = 1400, height=700, font_size = 200, function_owner = nil
        }
        local shepherdHerdButtonParam = {
           index = 2, label = 'Herd the flock\ninto the stable', click_function = 'scoreFlockButton',
           position = {x=0, y=3, z=2.3 * FLOATING_BUTTON_Z_SCALE}, width = 1400, height=700, font_size = 200, function_owner = nil
        }
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        --createNormalizedArbitraryButton(shepherd, shepherdExpandButtonParam, true)
        --createNormalizedArbitraryButton(shepherd, shepherdHerdButtonParam, true)
        createNormalizedButton(shepherd, shepherdExpandButtonParam, true)
        createNormalizedButton(shepherd, shepherdHerdButtonParam, true)
        allGameMessage(activePlayers[currentPlayer] .. " added to their Shepherd's field and has an opportunity to expand their flock", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
        return
    else
        return nextState('next')
    end
end

function addSheepToFlockButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        clearArbitraryButtons()
        if controlPanelSettings['PnDDragon'] then
            addSheepToTile(shepherd)
        else
            addSheepToField(shepherd)
        end
    end
end

function addSheepToShepherd(shepherd)
    local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
    if sheepTileBag ~= nil then
        local params = {}
        params.position = {shepherd.getPosition().x, shepherd.getPosition().y + 2, shepherd.getPosition().z}
        sheepTileBag.shuffle()
        local newTile = sheepTileBag.takeObject(params)
        if newTile.getName() == "Wolf" then
            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='scoreFlock', function_owner=nil, parameters={shepherd=shepherd}, delay=2.5})
        else
            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=2.5})
        end
    else
        allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to draw sheep tokens")
    end
end

function scoreFlockButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        clearArbitraryButtons()
        local params = {}
        params.shepherd = shepherd
        scoreFlock(params)
    end
end

function scoreFlock(params)
    shepherd = params.shepherd
    --startLuaCoroutine(self, 'scoreFlockCoroutine')

    local CoNew = coroutine.create(scoreFlockCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

function scoreFlockCoroutine()
    local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
    if sheepTileBag ~= nil then
        local xIndex = math.floor((shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        local xPosition = (shepherd.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
        local zPosition = (shepherd.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
        xPosition = xPosition - xIndex
        zPosition = zPosition - zIndex
        local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation)
        --only need a transversal level of 1, since we don't care about completed cities on the field
        getFeatureComponents(xIndex, zIndex, closestFeature, 1, true)
        local score = 0
        local hasWolf = false

        for _, token in ipairs(transversedSheepTokens) do
            if token.getName() == 'Sheep' then
                score = score + token.getDescription()
            elseif token.getName() == 'Wolf' then
                hasWolf = true
            end
            sheepTileBag.putObject(token)
        end
        for _, feature in ipairs(transversedSpecialFeatures) do
            if feature == 'Sheep' then
                score = score + 1
                break
            end
        end
        if hasWolf then score = 0 end
        for _, figure in ipairs(transversedSpecialFigures) do
            if figure.getName() == 'Shepherd' then
                local winner
                if score > 0 then winner = true else winner = false end
                table.insert(removedFigures, {guid=figure.getGUID(), winner=winner})
                if not hasWolf then
                    allGameMessage(figure.getDescription() .. "'s Shepherd scores " .. score .. " points for " .. score .. " sheep.", player_color_tints[figure.getDescription()])
                else
                    allGameMessage(figure.getDescription() .. "'s Shepherd loses all of its sheep to a wolf. No points scored.", player_color_tints[figure.getDescription()])
                end
                scorePoints(figure.getDescription(), 'Shepherd', score)
                figure.setLock(false)
                figure.use_gravity = false
                figure.interactable = false
                --raise the figure in the air
                figure.setPositionSmooth({figure.getPosition().x, figure.getPosition().y + 2.5, figure.getPosition().z}, false, false)
            end
        end
        if showMarkers == 'Both' or showMarkers == 'Scoring' then
            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='praiseShepherd', function_owner=nil, parameters=nil, delay=0.9})
        else
            returnShepherds()
        end
    else
        allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to return sheep tokens")
        nextState('next')
    end
    return 1
end

function praiseShepherd()
    --startLuaCoroutine(self, 'praiseFiguresCoroutine')

    local CoNew = coroutine.create(praiseShepherdCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--makes the winning shepherds spin and marks the features that were scored
function praiseShepherdCoroutine()
    for _, figure in ipairs(removedFigures) do
        if figure.winner then
            getObjectFromGUID(figure.guid).addTorque({0,25,0}, 4)
        end
    end
    if showMarkers == 'Scoring' or showMarkers == 'Both' then
        for _, transversedTileCoord in ipairs(transversedTileCoords) do
            if transversedFeaturePositions[transversedTileCoord.x] ~= nil and transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z] ~= nil then
                for position, transversedFeaturePosition in pairs(transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z]) do
                    if position < 13 or getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid).getTable('specialFeatures')[position - 12][3] ~= nil then
                        local tile = getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid)
                        local rotation = tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation
                        local x, z = getFeatureLocation(position, tile, rotation)
                        local params = {}
                        if transversedFeaturePosition == 1 then
                            params.type = "BlockSquare"
                        end
                        params.position = {(x * TILE_SPACING) + (transversedTileCoord.x * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (transversedTileCoord.z * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                        params.scale = {0.25, 0.25, 0.25}
                        params.callback = "identifyFeature"
                        local newObject = spawnObject(params)
                        table.insert(featureMarkers, newObject)
                    end
                end
                coroutine.yield(0)
            end
        end
    end
    Timer.create({identifier=os.clock(), function_name='returnShepherds', function_owner=nil, parameters=nil, delay=FIGURE_PRAISE_DELAY})
    return 1
end

function returnShepherds()
    --startLuaCoroutine(self, 'returnShepherdsCoroutine')

    local CoNew = coroutine.create(returnShepherdsCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--send figures back to the player supply area (assuming that's where they were when the game started)
function returnShepherdsCoroutine()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        figure_obj.use_gravity = true
        figure_obj.interactable = true
        local found_home = false
        if figurePositions[figure_obj.getDescription()] ~= nil and figurePositions[figure_obj.getDescription()][figure_obj.getName()] then
            for i, figure_GUID in ipairs(figurePositions[figure_obj.getDescription()][figure_obj.getName()]) do
                if figure_GUID == figure_obj.getGUID() then
                    local figurePad = getObjectFromGUID(figurepad_GUIDs[figure_obj.getDescription()])
                    local figureSetting = nil
                    for _, temp_figureSetting in pairs(figureSettings) do
                        if figure_obj.getName() == temp_figureSetting.name then
                            figureSetting = temp_figureSetting
                            break
                        end
                    end
                    if figureSetting ~= nil then
                        local x, z = rotateCoordinatesDegrees(figureSetting.offset.x + (((i - 1) % 4) * -1.45), figureSetting.offset.z + (math.floor((i - 1) / 4) * 1.0), -figurePad.getRotation().y)
                        figure_obj.setLock(false)
                        figure_obj.setPositionSmooth({x = figurePad.getPosition().x + x, y = figurePad.getPosition().y + 1, z = figurePad.getPosition().z + z}, false, false)
                        figure_obj.setRotationSmooth({x=0, y=figurePad.getRotation().y, z=0})
                        found_home = true
                    else
                        allErrorMessage("Warning: " .. figure_obj.getName() .. " missing from figure settings", activePlayers[currentPlayer])
                    end
                end
            end
        end
        if found_home == false then
            allErrorMessage("Warning: " .. figure_obj.getName() .. " doesn't have a home and must be returned manually", activePlayers[currentPlayer])
        end
        coroutine.yield(0)
    end
    removedFigures = {}

    nextState('next')
    return 1
end

function checkFlierDestination()
    if tileGridOccupied(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z) then
        local dragon = getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid)
        if controlPanelSettings['PnDDragon'] and dragon ~= nil then
            if lastPlacedTileX + flierOffset.x == math.floor((dragon.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
               lastPlacedTileZ + flierOffset.z == math.floor((dragon.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
                allGameMessage("The follower flew directly into the dragon's mouth! The dragon thanks you for the delicious aerial food delivery.", NEUTRAL_COLOR, activePlayers[currentPlayer])
                table.insert(removedFigures, {guid=flier, winner=false})
                return nextState('feature unavailable')
            end
        end
        resetTransversal()
        local destinationTile = getObjectFromGUID(tileGrid[lastPlacedTileX + flierOffset.x][lastPlacedTileZ + flierOffset.z].tile_guid)
        local hasIncompleteFeature = false
        for i=1, 12 do
            if getFeatureName(destinationTile, i) == 'City' or getFeatureName(destinationTile, i) == 'Road' then --fields are not valid destinations
                if getObjectFromGUID(flier).getName() ~= 'Mayor' or getFeatureName(destinationTile, i) == 'City' then
                    if getFeatureComponents(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z, i, 1, false) > 0 then
                        hasIncompleteFeature = true
                    end
                end
            end
        end
        local specialFeatures = destinationTile.getTable('specialFeatures')
        for j, feature in pairs(specialFeatures) do
            if (feature[1] == 'Cloister' or feature[1] == 'Abbey') and getObjectFromGUID(flier).getName() ~= 'Mayor' then
                if getFeatureComponents(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z, j + 12, 1, false) > 0 then
                    hasIncompleteFeature = true
                end
            end
            if feature[1] == 'Garden' and getObjectFromGUID(flier).getName() == 'Abbot' then
                if getFeatureComponents(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z, j + 12, 1, false) > 0 then
                    hasIncompleteFeature = true
                end
            end
        end
        if hasIncompleteFeature then
            return nextState('feature available')
        else
            allGameMessage("The destination tile has no valid incomplete features that this follower can land on. Returning follower.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        end
    else
        allGameMessage("No tile exists at flier destination. Returning follower.", NEUTRAL_COLOR, activePlayers[currentPlayer])
    end

    table.insert(removedFigures, {guid=flier, winner=false})
    return nextState('feature unavailable')
end

function scoreFeatures()
    scoring = true
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for i, figureTypes in ipairs({FOLLOWER_TYPES, SPECIAL_FIGURE_TYPES}) do
        for _, obj in ipairs(objs) do
            if table.contains(figureTypes, obj.getName()) and not (i == 2 and (not gameover or obj.getName() ~= 'Barn')) then
                if not table.contains(followersScored, obj) then
                    local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                    local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                    if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                        --debugMessage(1, "Checking " .. obj.getDescription() .. " " .. obj.getName() .. " for finished features at index: x: " .. xIndex .. " z: " .. zIndex)
                        local xPosition = (obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                        local zPosition = (obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                        xPosition = xPosition - xIndex
                        zPosition = zPosition - zIndex
                        local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                        local rotation = tileGrid[xIndex][zIndex].rotation
                        local closestFeature = findClosestFeature(xPosition, zPosition, tile, rotation)
                        local nameOfFeature = getFeatureName(tile, closestFeature)
                        --HACK: this hack will tell if there is a place to put the wagon if the feature had been completed
                        hasIncompleteSecondaryFeature = false
                        --debugMessage(2, "figure closest feature: index: x: " .. xIndex .. " z: " .. zIndex .. " position: " .. closestFeature .. " name: " .. nameOfFeature)
                        local finished = getFeatureComponents(xIndex, zIndex, closestFeature, 2, true)
                        local featureComplete
                        if finished == 0 then
                            featureComplete = true
                        else
                            featureComplete = false
                        end

                        local followerCounts = {}
                        local hasPig = {}
                        local hasHill = {}
                        local hasMayor = {}
                        local hasBarn = false
                        local hasNewBarn = false
                        local topWeight = -1
                        --find the relative weights for the followers on this feature
                        for _, follower in ipairs(transversedFollowers) do
                            local weight = 0
                            if follower.getName() == 'Follower' or follower.getName() == 'Wagon' or follower.getName() == 'Abbot' then weight = 1
                            elseif follower.getName() == 'Big Follower' then weight = 2
                            elseif follower.getName() == 'Mayor' then
                                for _, specialFeature in ipairs(transversedSpecialFeatures) do
                                    if specialFeature == 'Coat of Arms' then weight = weight + 1 end
                                end
                                hasMayor[follower.getDescription()] = true
                            end
                            if weight > 0 then
                                local followerXIndex = math.floor((follower.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                local followerZIndex = math.floor((follower.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                local specialFeatures = getObjectFromGUID(tileGrid[followerXIndex][followerZIndex].tile_guid).getTable('specialFeatures')
                                if controlPanelSettings['HnSHills'] and specialFeatures ~= nil then
                                    for _, specialFeature in ipairs(specialFeatures) do
                                        if specialFeature[1] == "Hill" then
                                            --although it would have been easier to just add 0.001 to the weight here, it would have technically violated the rules, since multiple hills are not supposed to give extra weight.
                                            hasHill[follower.getDescription()] = true
                                        end
                                    end
                                end
                            end
                            if followerCounts[follower.getDescription()] == nil then
                                followerCounts[follower.getDescription()] = weight
                            else
                                followerCounts[follower.getDescription()] = followerCounts[follower.getDescription()] + weight
                            end
                        end
                        --add hill weight if there is a hill, find top weight for the feature
                        for player, value in pairs(followerCounts) do
                            if hasHill[player] then
                                --if the follower is on a hill, add a small value to it to break any ties
                                followerCounts[player] = followerCounts[player] + 0.001
                            end
                            if followerCounts[player] > topWeight then topWeight = followerCounts[player] end
                        end

                        for _, figure in ipairs(transversedSpecialFigures) do
                            if figure.getName() == 'Pig' then hasPig[figure.getDescription()] = true end
                            if figure.getName() == 'Barn' then
                                hasBarn = true
                                if newBarn ~= nil and figure.getGUID() == newBarn then
                                    hasNewBarn = true
                                    newBarn = nil
                                end
                                --recalculate "follower count" with only barns. Technically they aren't followers but it was easier in code.
                                if #transversedFollowers == 0 then
                                    if followerCounts[figure.getDescription()] == nil then
                                        followerCounts[figure.getDescription()] = 1
                                    else
                                        followerCounts[figure.getDescription()] = followerCounts[figure.getDescription()] + 1
                                    end
                                    if followerCounts[figure.getDescription()] > topWeight then topWeight = followerCounts[figure.getDescription()] end
                                end
                            end
                        end
                        if #transversedFollowers == 0 and not hasBarn then
                            allErrorMessage("ERROR: no followers found. This should never happen. Tell the dev.")
                            return
                        end
                        local score = 0
                        local containsPigHerd = false
                        if nameOfFeature == 'City' then
                            score = #transversedTileCoords
                            local containsCathedral = false
                            for _, feature in ipairs(transversedSpecialFeatures) do
                                if feature == 'Coat of Arms' then
                                    score = score + 1
                                end
                                if feature == 'Cathedral' and controlPanelSettings['InCCathedrals'] then
                                    containsCathedral = true
                                end
                            end
                            if containsCathedral then
                                if featureComplete then
                                    score = score * 3
                                else
                                    score = 0
                                end
                            else
                                if featureComplete then
                                    score = score * 2
                                end
                            end
                            --do not nerf cities that were completed by an abbey, or incomplete cities
                            if lastPlacedTileX ~= nil and getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).getTable('sides')[1] ~= 'Abbey' and
                               featureComplete and controlPanelSettings['BaseNerfSmallCity'] and score == 4 then score = 2 end
                        elseif nameOfFeature == 'Field' then
                            for _, feature in ipairs(transversedSpecialFeatures) do
                                if feature == 'Completed City' then
                                    score = score + 1
                                end
                                if feature == 'Pig-herd' and not controlPanelSettings['RIIDisablePigherd'] then
                                    containsPigHerd = true
                                end
                            end
                            featureComplete = false --so that this feature won't be scored before the end of the game
                        elseif nameOfFeature == 'Road' then
                            score = #transversedTileCoords
                            local containsInn = false
                            for _, feature in ipairs(transversedSpecialFeatures) do
                                if feature == 'Inn' and controlPanelSettings['InCInns'] then
                                    containsInn = true
                                end
                            end
                            if containsInn then
                                if featureComplete then
                                    score = score * 2
                                else
                                    score = 0
                                end
                            end
                        elseif nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' or nameOfFeature == 'Shrine' then
                            score = #transversedTileCoords
                            if featureComplete and controlPanelSettings['HnSVineyards'] then
                                for _, feature in ipairs(transversedSpecialFeatures) do
                                    if feature == 'Vineyard' then
                                        score = score + 3
                                    end
                                end
                            end
                            if featureComplete then
                                local challengerTile, challengedTile
                                if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                                    challengerTile = 'Cloister'
                                    challengedTile = 'Shrine'
                                else
                                    challengerTile = 'Shrine'
                                    challengedTile = 'Cloister'
                                end
                                for x=-1, 1 do
                                    for z=-1, 1 do
                                        if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                            local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
                                            if specialFeatures ~= nil then
                                                for i, feature in ipairs(specialFeatures) do
                                                    local adjacentFeature = feature[1]
                                                    if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                    if adjacentFeature == challengedTile then
                                                        local numTiles = 0
                                                        for nested_x=-1, 1 do
                                                            for nested_z=-1, 1 do
                                                                if tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
                                                                    numTiles = numTiles + 1
                                                                end
                                                            end
                                                        end
                                                        if numTiles ~= 9 then
                                                            local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                            for _, object in ipairs(objs) do
                                                                if table.contains(FOLLOWER_TYPES, object.getName()) then
                                                                    local objectXIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                                                    local objectZIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                                                    if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                        				local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                                                        				local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                                                        				xPosition = xPosition - objectXIndex
                                                        				zPosition = zPosition - objectZIndex
                                                        				local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), rotation)
                                                                        if closestFeature == i + 12 then
                                                                            object.setLock(false)
                                                                            object.use_gravity = false
                                                                            object.interactable = false
                                                                            --raise the follower in the air
                                                                            object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)
                                                                            table.insert(removedFigures, {guid=object.getGUID(), winner=false})
                                                                            allGameMessage(object.getDescription() .. " " .. object.getName() .. " has lost the Cloister/Shrine challenge.", player_color_tints[object.getDescription()])
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        elseif nameOfFeature == "Baba Yaga's Hut" then
                            score = 10 - #transversedTileCoords
                            --unclear if vineyards should be counted. Leaving out for now
                        elseif nameOfFeature == "Garden" then
                            score = #transversedTileCoords
                        end
                        for player, value in pairs(followerCounts) do
                            if nameOfFeature ~= 'Carcassonne' and string.sub(nameOfFeature,1,6) ~= 'Flier' then --FIXME: need a better permanent solution
                                if gameover or featureComplete or (nameOfFeature == 'Field' and hasBarn and #transversedFollowers > 0) or (gameover and hasBarn and #transversedFollowers == 0) then
                                    if (topWeight > 0 and value >= topWeight) then
                                        playerScore = score
                                        if nameOfFeature == 'Field' then
                                            local scoreMultiplier = 3
                                            if hasBarn then
                                                if #transversedFollowers > 0 then
                                                    if not hasNewBarn then
                                                        scoreMultiplier = 1
                                                    end
                                                else
                                                    scoreMultiplier = 4
                                                end
                                            end
                                            if hasPig[player] ~= nil then
                                                scoreMultiplier = scoreMultiplier + 1
                                            end
                                            if containsPigHerd and #transversedFollowers > 0 then -- CAR pg 67 ref 194
                                                scoreMultiplier = scoreMultiplier + 1
                                            end
                                            playerScore = score * scoreMultiplier
                                        end
                                        allGameMessage(player .. " scores " .. playerScore .. " points on " .. nameOfFeature, player_color_tints[player]) -- .. " with a strength of " .. value .. " followers", player_color_tints[player])
                                        scorePoints(player, nameOfFeature, playerScore)
                                    elseif value > 0 then
                                        --allGameMessage(player .. " did not score any points with a strength of only " .. value .. " followers", player_color_tints[player])
                                    elseif topWeight == 0 and hasMayor[player] then
                                        allGameMessage(player .. " scores 0 points on " .. nameOfFeature .. ". A mayor can only score points if the city contains a coat of arms!", player_color_tints[player])
                                    end
                                end
                            end
                        end
                        for _, follower in ipairs(transversedFollowers) do
                            if not table.contains(followersScored, follower) then
                                table.insert(followersScored, follower)
                            end
                        end
                        if gameover and #transversedFollowers == 0 then
                            for _, figure in ipairs(transversedSpecialFigures) do
                                if not table.contains(followersScored, figure) and figure.getName() == 'Barn' then
                                    table.insert(followersScored, figure)
                                end
                            end
                        end
                        if nameOfFeature ~= 'Carcassonne' then --FIXME: need a better permanent solution
                        if gameover or featureComplete or (nameOfFeature == 'Field' and hasBarn) then
                            for _, follower in ipairs(transversedFollowers) do
                                local closestFollower = fairyClosestFollower()
                                if closestFollower == follower then
                                    allGameMessage(closestFollower.getDescription() .. " " .. closestFollower.getName() .. " scores 3 points for being next to the fairy when scoring a feature.", player_color_tints[closestFollower.getDescription()])
                                    scorePoints(closestFollower.getDescription(), 'Fairy', 3)
                                end
                                if follower.getName() == "Wagon" then
                                    wagonLocations[follower.getDescription()] = {}
                                    wagonLocations[follower.getDescription()].x = follower.getPosition().x
                                    wagonLocations[follower.getDescription()].z = follower.getPosition().z
                                    hasAvailableWagonFeature[follower.getDescription()] = hasIncompleteSecondaryFeature
                                end
                                local winner = false
                                if topWeight > 0 and followerCounts[follower.getDescription()] >= topWeight and score > 0 then winner = true end
                                if winner and nameOfFeature ~= 'Field' and #transversedGoldBars > 0 then
                                    if scoringRewards['Gold'] == nil then scoringRewards['Gold'] = {} end
                                    for _, gold in ipairs(transversedGoldBars) do
                                        if scoringRewards['Gold'][gold.getGUID()] == nil then scoringRewards['Gold'][gold.getGUID()] = {} end
                                        if not table.contains(scoringRewards['Gold'][gold.getGUID()], follower.getDescription()) then
                                            table.insert(scoringRewards['Gold'][gold.getGUID()], follower.getDescription())
                                        end
                                    end
                                end
                                table.insert(removedFigures, {guid=follower.getGUID(), winner=winner})
                                follower.setLock(false)
                                follower.use_gravity = false
                                follower.interactable = false
                                --raise the follower in the air
                                follower.setPositionSmooth({follower.getPosition().x, follower.getPosition().y + 2.5, follower.getPosition().z}, false, false)
                            end
                            for _, figure in ipairs(transversedSpecialFigures) do
                                --shepherds are never removed outside of a flock collection
                                --barns should only be scored at the end of the game, after all followers have been scored
                                if figure.getName() ~= 'Shepherd' and (figure.getName() ~= 'Barn' or (figure.getName() == 'Barn' and #transversedFollowers == 0 and gameover)) then
                                    local winner = false
                                    --builder not involved in scoring, so shouldn't be praised
                                    if figure.getName() ~= 'Builder' and topWeight > 0 and followerCounts[figure.getDescription()] >= topWeight and score > 0 then winner = true end
                                    table.insert(removedFigures, {guid=figure.getGUID(), winner=winner})
                                    figure.setLock(false)
                                    figure.use_gravity = false
                                    figure.interactable = false
                                    --raise the figure in the air
                                    figure.setPositionSmooth({figure.getPosition().x, figure.getPosition().y + 2.5, figure.getPosition().z}, false, false)
                                end
                            end
                            if showMarkers == 'Both' or showMarkers == 'Scoring' then
                                if gameover then
                                    praiseFiguresCameraFocus(false)
                                end
                                Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                            else
                                returnFigures()
                            end
                            return
                        end
                        end
                    end
                end
            end
        end
    end
    if gameover then --do possessions now
        if controlPanelSettings['TnBTradeGoods'] then
            for _, tokenType in ipairs(TRADE_TOKEN_TYPES) do --trade tokens
                local highestNumTokens = 0
                local tokenCounts = {}
                --find the highest count for this token
                for _, player in ipairs(activePlayers) do
                    local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                    local playerNumTokens = 0
                    for _, obj in ipairs(playerPossessions) do
                        if obj.getName() == tokenType then
                            local quantity = obj.getQuantity()
                            if quantity == -1 then quantity = 1 end
                            if tokenCounts[player] == nil then
                                tokenCounts[player] = quantity
                            else
                                tokenCounts[player] = tokenCounts[player] + quantity
                            end
                        end
                    end
                    if tokenCounts[player] ~= nil and tokenCounts[player] > highestNumTokens then
                        highestNumTokens = tokenCounts[player]
                    end
                end
                if highestNumTokens > 0 then
                    --give points to players with the most tokens
                    for _, player in ipairs(activePlayers) do
                        local winner
                        if tokenCounts[player] == highestNumTokens then
                            winner = true
                            allGameMessage(player .. " scores 10 points on " .. tokenType .. "s", player_color_tints[player])
                            scorePoints(player, 'Trade Goods', 10)
                        else
                            winner = false
                        end
                        local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                        for _, obj in ipairs(playerPossessions) do
                            if obj.getName() == tokenType then
                                table.insert(removedFigures, {guid=obj.getGUID(), winner=winner})
                                obj.setLock(false)
                                obj.use_gravity = false
                                obj.interactable = false
                                --raise the token in the air
                                if showMarkers == 'Both' or showMarkers == 'Scoring' then
                                    obj.setPositionSmooth({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                                else
                                    obj.setPosition({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                                end
                            end
                        end
                    end
                    transversedFeaturePositions = {}
                    if showMarkers == 'Both' or showMarkers == 'Scoring' then
                        praiseFiguresCameraFocus(true)
                        Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                    else
                        returnFigures()
                    end
                    return
                end
            end
        end
        if controlPanelSettings['GoldminesGold'] then
            --find the highest count for this token
            for _, player in ipairs(activePlayers) do
                local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                local playerNumGold = 0
                for _, obj in ipairs(playerPossessions) do
                    if obj.getName() == GOLD_BAR_NAME then
                        local quantity = obj.getQuantity()
                        if quantity == -1 then quantity = 1 end
                        playerNumGold = playerNumGold + quantity
                        table.insert(removedFigures, {guid=obj.getGUID(), winner=true})
                        obj.setLock(false)
                        obj.use_gravity = false
                        obj.interactable = false
                        --raise the token in the air
                        obj.setPositionSmooth({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                    end
                end
                if playerNumGold > 0 then
                    local goldPoints
                    local goldMultiplier
                    if playerNumGold > 9 then
                        goldMultiplier =  4
                    elseif playerNumGold > 6 then
                        goldMultiplier = 3
                    elseif playerNumGold > 3 then
                        goldMultiplier = 2
                    else
                        goldMultiplier = 1
                    end
                    allGameMessage(player .. " scores " .. playerNumGold * goldMultiplier .. " points on " .. playerNumGold .. " gold bars (" .. goldMultiplier .. " points each).", player_color_tints[player])
                    scorePoints(player, 'Gold', playerNumGold * goldMultiplier)
                    transversedFeaturePositions = {}

                    if showMarkers == 'Both' or showMarkers == 'Scoring' then
                        praiseFiguresCameraFocus(true)
                        Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                    else
                        returnFigures()
                    end
                    return
                end
            end
        end
        --count total completed cities and roads for king and robber points
        local numCities = 0
        local numRoads = 0
        resetTransversal()
        if controlPanelSettings['KnRBKing'] or controlPanelSettings['KnRBRobber'] then
            for x, tileColumn in pairs(tileGrid) do
                for z, tileLocation in pairs(tileColumn) do
                    local tile = getObjectFromGUID(tileLocation.tile_guid)
                    for i=1, 12 do --roads and cities
                        if transversedGrid[x] == nil or transversedGrid[x][z] == nil or transversedGrid[x][z][i] == nil or transversedGrid[x][z][i] > 1 then
                            if controlPanelSettings['KnRBRobber'] and i < 5 and tile.getTable('sides')[i] == 'Road' then
                                if getFeatureComponents(x, z, i, 1, false) == 0 then
                                    numRoads = numRoads + 1
                                end
                            elseif controlPanelSettings['KnRBKing'] and i >= 5 and (tile.getTable('sides')[math.floor((i - 3) / 2)] == 'City' or tile.getTable('sides')[math.floor((i - 3) / 2)] == 'Carcassonne') then
                                if getFeatureComponents(x, z, i, 1, false) == 0 then
                                    numCities = numCities + 1
                                end
                            end
                        end
                    end
                end
            end
            --find king and robber tokens and give points
            for _, player in ipairs(activePlayers) do
                local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                for _, obj in ipairs(playerPossessions) do
                    local score
                    if obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid then
                        score = numCities
                    elseif obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid then
                        score = numRoads
                    end
                    if (obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid and controlPanelSettings['KnRBKing']) or (obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid and controlPanelSettings['KnRBRobber']) then
                        allGameMessage(player .. " scores " .. score .. " points on " .. obj.getName(), player_color_tints[player])
                        scorePoints(player, 'King/Robber Tokens', score)
                        table.insert(removedFigures, {guid=obj.getGUID(), winner=true})
                        obj.setLock(false)
                        obj.use_gravity = false
                        obj.interactable = false
                        --raise the token in the air
                        obj.setPositionSmooth({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                        transversedFeaturePositions = {}

                        if showMarkers == 'Both' or showMarkers == 'Scoring' then
                            praiseFiguresCameraFocus(false)
                            Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                        else
                            returnFigures()
                        end
                        return
                    end
                end
            end
        end
    end
    scoring = false
    followersScored = {}
    if gameover then
        printedPlayers = {}
        local playerNum = 1
        local rank = 1
        local lastHighscore = 0
        while true do
            local highscore = 0
            local color = nil
            for _, player in pairs(activePlayers) do
                local scoreCounter = getObjectFromGUID(score_counter_guids[player])
                if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                    if scoreCounter.Counter.getValue() > highscore then
                        highscore = scoreCounter.Counter.getValue()
                        color = player
                    end
                end
            end
            if highscore > 0 then
                if highscore < lastHighscore then rank = playerNum end
                local steam_name = ""
                if getPlayerOwner(color):sub(1,2) == 'AI' then
                    steam_name = getPlayerOwner(color)
                elseif controlPanelSettings[color .. 'Control'] ~= nil then
                    if Player[controlPanelSettings[color .. 'Control']].steam_name ~= nil then steam_name = Player[controlPanelSettings[color .. 'Control']].steam_name end
                else
                    if Player[color].steam_name ~= nil then steam_name = Player[color].steam_name end
                end
                allGameMessage("#" .. rank .. " - " .. highscore .. " points - ".. color .. " - " .. steam_name, player_color_tints[color])
            else
                break
            end
            table.insert(printedPlayers, color)
            playerNum = playerNum + 1
            lastHighscore = highscore
        end
        allGameMessage("Game over.", NEUTRAL_COLOR)
        allGameMessage("If you enjoyed the mod, please give it a like on the workshop. If you encountered any bugs, please upload a save file and describe it in the workshop comments.", NEUTRAL_COLOR)
    else
        return nextState('next')
    end
end

function rewardFairy()
    local closestFollower = fairyClosestFollower()
    if closestFollower ~= nil and closestFollower.getDescription() == activePlayers[currentPlayer] then
        local tileStack = getObjectFromGUID(tileStack_GUID)
        if tileStack == nil and finalTile_GUID == nil then
            allGameMessage("WARNING: No tile stack found. No points awarded for fairy. If you just placed the last tile, you can ignore this message.", NEUTRAL_COLOR)
        else
            allGameMessage(closestFollower.getDescription() .. " scores 1 point for being next to the fairy on their turn.", player_color_tints[closestFollower.getDescription()])
            scorePoints(closestFollower.getDescription(), 'Fairy', 1)
        end
    end
    return nextState('next')
end

function fairyClosestFollower()
    local closestFollower = nil
    local fairy = getObjectFromGUID(expansionBags['PnD'].contents['PnDFairy'].guid)
    if fairy ~= nil then
        local xIndex = math.floor((fairy.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((fairy.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        if tileGridOccupied(xIndex, zIndex) then
            local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
            local eligibleFollowers = {}
            for _, follower in ipairs(objs) do
                if table.contains(FOLLOWER_TYPES, follower.getName()) then
                    if xIndex == math.floor((follower.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
                     zIndex == math.floor((follower.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
                        table.insert(eligibleFollowers, follower)
                    end
                end
            end
            if #eligibleFollowers == 1 then
                closestFollower = eligibleFollowers[1]
            elseif #eligibleFollowers > 1 then
                local closestDistanceToFairy = 999
                for i, follower in ipairs(eligibleFollowers) do
                    local distanceToFairy = (follower.getPosition().x - fairy.getPosition().x) * (follower.getPosition().x - fairy.getPosition().x) + (follower.getPosition().z - fairy.getPosition().z) * (follower.getPosition().z - fairy.getPosition().z)
                    if distanceToFairy < closestDistanceToFairy then
                        closestDistanceToFairy = distanceToFairy
                        closestFollower = follower
                    end
                end
            end
        end
    end
    return closestFollower
end

function rewardGold()
    if currentMiniTurn == nil then
        currentMiniTurn = currentPlayer
    else
        currentMiniTurn = currentMiniTurn + 1
    end
    local test = 0
    if scoringRewards['Gold'] ~= nil then
        while true do
            if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
            local eligiblePlayers = {}
            eligibleGold = {}
            for gold_guid, players in pairs(scoringRewards['Gold']) do
                for _, player in ipairs(players) do
                    if not table.contains(eligiblePlayers, player) then
                        table.insert(eligiblePlayers, player)
                    end
                end
                if table.contains(players, activePlayers[currentMiniTurn]) then
                    table.insert(eligibleGold, gold_guid)
                end
            end
            if #eligibleGold == 1 or (#eligibleGold > 0 and #eligiblePlayers == 1) then
                allGameMessage(activePlayers[currentMiniTurn] .. " was awarded a gold bar for having control over a finished feature.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                return giveGold(eligibleGold[1], activePlayers[currentMiniTurn])
            elseif #eligibleGold > 1 then
                allGameMessage(activePlayers[currentMiniTurn] .. " may choose a gold bar for having control over a finished feature.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                return promptGoldChoice(eligibleGold)
            end
            local count = 0
            for _, gold in pairs(scoringRewards['Gold']) do
                if gold ~= nil then
                    count = count + 1
                end
            end
            currentMiniTurn = currentMiniTurn + 1
            if count == 0 then break end
        end
    end
    currentMiniTurn = nil
    scoringRewards['Gold'] = nil
    return nextState('next')
end

function promptGoldChoice()
    for _, gold in ipairs(eligibleGold) do
        local goldButtonParam = {
           index = 1, label = 'Take\ngold', click_function = 'takeGoldButton',
           position = {x=0, y=3, z=2.0 * FLOATING_BUTTON_Z_SCALE}, width = 1400, height=600, font_size = 200, function_owner = nil
        }
        createNormalizedButton(getObjectFromGUID(gold), goldButtonParam, true)
    end
end

function takeGoldButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        for _, gold in pairs(eligibleGold) do
            getObjectFromGUID(gold).clearButtons()
        end
        return giveGold(object.getGUID(), sPlayer)
    end
end

function giveGold(gold, player)
    local tradeGoodPile
    local x, z = rotateCoordinates(6.9, 1.5, player_possession_areas[player].rotation)
    --params.rotation = {0,  player_possession_areas[activePlayers[currentPlayer]].rotation * -90, 0}
    getObjectFromGUID(gold).setPositionSmooth({player_possession_areas[player].x + x, 2, player_possession_areas[player].z + z})

    scoringRewards['Gold'][gold] = nil
    return rewardGold()
end

function replaceFinishedWagons()
    currentMiniTurn = currentPlayer
    while true do
        if wagonLocations[activePlayers[currentMiniTurn]] ~= nil then
            if hasAvailableWagonFeature[activePlayers[currentMiniTurn]] then
                allGameMessage(activePlayers[currentMiniTurn] .. "'s wagon has finished and may now be placed back on a connected feature.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                promptWagon()
                return
            else
                wagonLocations[activePlayers[currentMiniTurn]] = nil
                allGameMessage(activePlayers[currentMiniTurn] .. "'s wagon has finished, but there were no available features connected.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
            end
        end
        currentMiniTurn = currentMiniTurn + 1
        if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
        if currentMiniTurn == currentPlayer then break end
    end
    currentMiniTurn = nil
    return nextState('next')
end

function promptWagon()
    -- local labelButtonParam = {
    --    index = 1, label = 'Replace your wagon\nOR', click_function = 'doNothing',
    --    position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=1.8}, width = 0, height=0, font_size = 200, function_owner = nil
    -- }
    -- local skipFigureButtonParam = {
    --    index = 2, label = 'Skip placing\nwagon', click_function = 'skipWagonButton',
    --    position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=2.5}, width = 1400, height=600, font_size = 200, function_owner = nil
    -- }
    local labelButtonParam = {
       index = 1, label = 'Replace your wagon\nOR', click_function = 'doNothing',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT * FLOATING_BUTTON_Y_SCALE, z=1.8 * FLOATING_BUTTON_Z_SCALE}, width = 0, height=0, font_size = 200, function_owner = nil
    }
    local skipFigureButtonParam = {
       index = 2, label = 'Skip placing\nwagon', click_function = 'skipWagonButton',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT * FLOATING_BUTTON_Y_SCALE, z=2.5 * FLOATING_BUTTON_Z_SCALE}, width = 1400, height=600, font_size = 200, function_owner = nil
    }
    --createNormalizedArbitraryButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), labelButtonParam, true)
    --createNormalizedArbitraryButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), skipFigureButtonParam, true)
    createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), labelButtonParam, true)
    createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), skipFigureButtonParam, true)
end

function skipWagonButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        clearArbitraryButtons()
        wagonLocations[activePlayers[currentMiniTurn]] = nil
        return replaceFinishedWagons()
    end
end

--focus the camera on the currently praised figures
--params:
-- bool - only winning figures will be focused on
function praiseFiguresCameraFocus(onlyWinners)
    local camera_position = {x = 0.0, y = 0.0, z = 0.0}
    local num_winners = 0
    local max_separation = 0
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        if not onlyWinners or figure.winner then
            camera_position.x = camera_position.x + figure_obj.getPosition().x
            camera_position.y = camera_position.y + figure_obj.getPosition().y
            camera_position.z = camera_position.z + figure_obj.getPosition().z
            num_winners = num_winners + 1
            for _, other_figure in ipairs(removedFigures) do
                local other_figure_obj = getObjectFromGUID(other_figure.guid)
                local separation = math.sqrt((figure_obj.getPosition().x - other_figure_obj.getPosition().x) * (figure_obj.getPosition().x - other_figure_obj.getPosition().x) +
                          (figure_obj.getPosition().z - other_figure_obj.getPosition().z) * (figure_obj.getPosition().z - other_figure_obj.getPosition().z))
                if separation > max_separation then
                    max_separation = separation
                end
            end
        end
    end
    if num_winners > 0 then
        camera_position.x = camera_position.x / num_winners
        camera_position.y = camera_position.y / num_winners
        camera_position.z = camera_position.z / num_winners
    end
    for _, player in ipairs(activePlayers) do
        if getPlayerOwner(player):sub(1,2) ~= 'AI' and Player[getPlayerOwner(player)].seated then
            --getPointerRotation gives the player's current yaw (though +180 degrees). Use this to keep the yaw steady.
            local camera_yaw = Player[getPlayerOwner(player)].getPointerRotation() + 180
            if camera_yaw > 360 then camera_yaw = camera_yaw - 360 end
            local camera_params = {
                position = camera_position,
                yaw = camera_yaw,
                pitch = 35.0,
                --in theory this formula should give the camera distance needed to fit both objects in the screen
                --local camera_distance = math.tan((180 - fov) / 2) * (max_separation / 2)
                -- if the FoV is 90 degrees, then the altitude of the triangle is half the hypotenuse (which is the distance between the objects)
                -- is it correct? probably not, but it sounds good enough to me
                distance = 15.0 + (max_separation * 0.5)
            }
            Player[getPlayerOwner(player)].lookAt(camera_params)
        end
    end
end

function praiseFigures()
    --startLuaCoroutine(self, 'praiseFiguresCoroutine')

    local CoNew = coroutine.create(praiseFiguresCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--makes the winning followers spin and marks the features that were scored
function praiseFiguresCoroutine()
    for _, figure in ipairs(removedFigures) do
        if figure.winner then
            getObjectFromGUID(figure.guid).addTorque({0,25,0}, 4)
        end
    end
    if showMarkers == 'Scoring' or showMarkers == 'Both' then
        for _, transversedTileCoord in ipairs(transversedTileCoords) do
            if transversedFeaturePositions[transversedTileCoord.x] ~= nil and transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z] ~= nil then
                for position, transversedFeaturePosition in pairs(transversedFeaturePositions[transversedTileCoord.x][transversedTileCoord.z]) do
                    if position < 13 or getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid).getTable('specialFeatures')[position - 12][3] ~= nil then
                        local tile = getObjectFromGUID(tileGrid[transversedTileCoord.x][transversedTileCoord.z].tile_guid)
                        local rotation = tileGrid[transversedTileCoord.x][transversedTileCoord.z].rotation
                        local x, z = getFeatureLocation(position, tile, rotation)
                        local params = {}
                        if transversedFeaturePosition == 1 then
                            params.type = "BlockSquare"
                        elseif transversedFeaturePosition == 2 then
                            params.type = "BlockTriangle"
                        end
                        params.position = {(x * TILE_SPACING) + (transversedTileCoord.x * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (transversedTileCoord.z * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                        params.scale = {0.25, 0.25, 0.25}
                        params.callback = "identifyFeature"
                        local newObject = spawnObject(params)
                        table.insert(featureMarkers, newObject)
                    end
                end
                coroutine.yield(0)
            end
        end
    end
    Timer.create({identifier=os.clock(), function_name='returnFigures', function_owner=nil, parameters=nil, delay=FIGURE_PRAISE_DELAY})
    return 1
end

--when we spawn an object (to mark a feature), immediately lock it
function identifyFeature(obj)
    obj.setLock(true)
end

function returnFigures()
    --startLuaCoroutine(self, 'returnFiguresCoroutine')

    local CoNew = coroutine.create(returnFiguresCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--send figures back to the player supply area (assuming that's where they were when the game started)
function returnFiguresCoroutine()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        figure_obj.setLock(false)
        figure_obj.use_gravity = true
        figure_obj.interactable = true

        if figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid or figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid or table.contains(TRADE_TOKEN_TYPES, figure_obj.getName()) or figure_obj.getName() == GOLD_BAR_NAME then
            -- move the tokens away from the player possession area. It doesn't really matter where, as long as we move them so they aren't counted twice.
            local targetPosition = {x = NEUTRAL_ITEMS_LOCATION.x, y = NEUTRAL_ITEMS_LOCATION.y, z = NEUTRAL_ITEMS_LOCATION.z}
            if figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid then
                targetPosition.x = targetPosition.x + 1 --arbitrary location
            elseif figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid then
                targetPosition.x = targetPosition.x + 3 --arbitrary location
            end

            local container = nil
            if figure_obj.getName() == 'Wheat Token' then
                container = getObjectFromGUID(expansionBags['TnB'].contents['TnBWheatTokenStack'].guid)
            elseif figure_obj.getName() == 'Wine Token' then
                container = getObjectFromGUID(expansionBags['TnB'].contents['TnBWineTokenStack'].guid)
            elseif figure_obj.getName() == 'Cloth Token' then
                container = getObjectFromGUID(expansionBags['TnB'].contents['TnBClothTokenStack'].guid)
            elseif figure_obj.getName() == GOLD_BAR_NAME then
                container = getObjectFromGUID(expansionBags['Goldmines'].contents['GoldminesGold'].guid)
            end
            if container ~= nil then
                container.putObject(figure_obj)
            elseif table.contains(TRADE_TOKEN_TYPES, figure_obj.getName()) then
                allErrorMessage("Warning: Could not find target container for " .. figure_obj.getName() .. ". It is being moved to an arbitrary location.", activePlayers[currentPlayer])
                figure_obj.setPositionSmooth(targetPosition, false, false)
            else
                figure_obj.setPositionSmooth(targetPosition, false, false)
            end
        else
            local found_home = false
            if figurePositions[figure_obj.getDescription()] ~= nil and figurePositions[figure_obj.getDescription()][figure_obj.getName()] then
                for i, figure_GUID in ipairs(figurePositions[figure_obj.getDescription()][figure_obj.getName()]) do
                    if figure_GUID == figure_obj.getGUID() then
                        local figurePad = getObjectFromGUID(figurepad_GUIDs[figure_obj.getDescription()])
                        local figureSetting = nil
                        for _, temp_figureSetting in pairs(figureSettings) do
                            if figure_obj.getName() == temp_figureSetting.name then
                                figureSetting = temp_figureSetting
                                break
                            end
                        end
                        if figureSetting ~= nil then
                            local x, z = rotateCoordinatesDegrees(figureSetting.offset.x + (((i - 1) % 4) * -1.45), figureSetting.offset.z + (math.floor((i - 1) / 4) * 1.0), -figurePad.getRotation().y)
                            figure_obj.setLock(false)
                            figure_obj.setPositionSmooth({x = figurePad.getPosition().x + x, y = figurePad.getPosition().y + 1, z = figurePad.getPosition().z + z}, false, false)
                            figure_obj.setRotationSmooth({x=0, y=figurePad.getRotation().y, z=0})
                            found_home = true
                        else
                            allErrorMessage("Warning: " .. figure_obj.getName() .. " missing from figure settings", activePlayers[currentPlayer])
                        end
                    end
                end
                if figure_obj.getName() == 'Abbot' then --FIXME: this is a temporary solution until abbots can be added to the control panel
                    local i = 1
                    local figurePad = getObjectFromGUID(figurepad_GUIDs[figure_obj.getDescription()])
                    local figureSetting = nil
                    for _, temp_figureSetting in pairs(figureSettings) do
                        if figure_obj.getName() == temp_figureSetting.name then
                            figureSetting = temp_figureSetting
                            break
                        end
                    end
                    if figureSetting ~= nil then
                        local x, z = rotateCoordinatesDegrees(figureSetting.offset.x + (((i - 1) % 4) * -1.45), figureSetting.offset.z + (math.floor((i - 1) / 4) * 1.0), -figurePad.getRotation().y)
                        figure_obj.setPositionSmooth({x = figurePad.getPosition().x + x, y = figurePad.getPosition().y + 1, z = figurePad.getPosition().z + z}, false, false)
                        figure_obj.setRotationSmooth({x=0, y=figurePad.getRotation().y, z=0})
                        found_home = true
                    else
                        allErrorMessage("Warning: " .. figure_obj.getName() .. " missing from figure settings", activePlayers[currentPlayer])
                    end
                end
            end
            if found_home == false then
                allErrorMessage("Warning: " .. figure_obj.getName() .. " doesn't have a home and must be returned manually", activePlayers[currentPlayer])
            end
        end
        coroutine.yield(0)
    end
    removedFigures = {}

    --make sure to give enough time for pieces to travel back or they might be counted twice
    nextState('figures returned')
    return 1
end

function debugShowTransversal()
    for xIndex, gridColumn in pairs(transversedFeaturePositions) do
        for zIndex, tileLocation in pairs(gridColumn) do
            for position, transversedFeaturePosition in pairs(tileLocation) do
                if position < 13 or getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).getTable('specialFeatures')[position - 12][3] ~= nil then
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local rotation = tileGrid[xIndex][zIndex].rotation
                    local x, z = getFeatureLocation(position, tile, rotation)
                    if transversedFeaturePosition ~= 2 then
                        local params = {}
                        if transversedFeaturePosition == 1 then
                            params.type = "BlockSquare"
                        elseif transversedFeaturePosition == 2 then
                            params.type = "BlockTriangle"
                        end
                        params.position = {(x * TILE_SPACING) + (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                        params.scale = {0.25, 0.25, 0.25}
                        params.callback = "identifyFeature"
                        local newObject = spawnObject(params)
                        table.insert(featureMarkers, newObject)
                    end
                end
            end
        end
    end
    for xIndex, gridColumn in pairs(transversedGrid) do
        for zIndex, tileLocation in pairs(gridColumn) do
            for position, transversedPosition in pairs(tileLocation) do
                if position < 13 or getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).getTable('specialFeatures')[position - 12][3] ~= nil then
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local rotation = tileGrid[xIndex][zIndex].rotation
                    local x, z = getFeatureLocation(position, tile, rotation)
                    local params = {}
                    if transversedPosition ~= nil and (transversedFeaturePositions[xIndex] == nil or transversedFeaturePositions[xIndex][zIndex] == nil or transversedFeaturePositions[xIndex][zIndex][position] == nil or transversedFeaturePositions[xIndex][zIndex][position] == 2) then
                        params.type = "BlockRectangle"
                    end
                    params.position = {(x * TILE_SPACING) + (xIndex * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (zIndex * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}
                    params.scale = {0.25, 0.25, 0.25}
                    params.callback = "identifyFeature"
                    local newObject = spawnObject(params)
                    table.insert(featureMarkers, newObject)
                end
            end
        end
    end
    Timer.create({identifier=os.clock(), function_name='deleteMarkers', function_owner=nil, parameters=nil, delay=8})
end

function debugShowFeatureMap()
    --this will break if the starting tile is moved
    local minX = 25
    local maxX = 25
    local minZ = 25
    local maxZ = 25
    local chatWindowMaxWidth
    if featureIndex < 100 then
        chatWindowMaxWidth = 11
    else
        chatWindowMaxWidth = 6
    end

    for xIndex, gridColumn in pairs(featureMap) do
        if xIndex < minX then minX = xIndex end
        if xIndex > maxX then maxX = xIndex end
        for zIndex, tileLocation in pairs(gridColumn) do
            if zIndex < minZ then minZ = zIndex end
            if zIndex > maxZ then maxZ = zIndex end
        end
    end

    local printColumnMinX = minX
    for printColumnMaxX = minX + chatWindowMaxWidth, maxX + chatWindowMaxWidth, chatWindowMaxWidth + 1 do
        if printColumnMaxX > maxX then printColumnMaxX = maxX end
        print("printing feature map x:" .. printColumnMinX .. "-" .. printColumnMaxX .. " z:" .. minZ .. "-" .. maxZ)
        for zIndex=maxZ, minZ, -1 do
            for i, positionRow in ipairs({{99, 5, 1, 6, 99}, {12, 99, 99, 99, 7}, {4, 99, 99, 99, 2}, {11, 99, 99, 99, 8}, {99, 10, 3, 9, 99}}) do
                local printLine = ""
                for xIndex=printColumnMinX, printColumnMaxX do
                    if featureMap[xIndex] ~= nil then
                        if featureMap[xIndex][zIndex] ~= nil then
                            local tilePositionRow = table.shallow_copy(positionRow)
                            if i >= 2 and i <= 4 then
                                for j=2, 4 do
                                    local closestFeature = findClosestFeatureMap((j - 3) * 0.25, (i - 3) * 0.25, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation)
                                    if closestFeature > 12 then
                                        tilePositionRow[j] = closestFeature
                                    end
                                end
                            end
                            for _, position in ipairs(tilePositionRow) do
                                if position == 99 then
                                    if featureIndex < 100 then
                                        printLine = printLine .. '    '
                                    else
                                        printLine = printLine .. '      '
                                    end
                                else
                                    -- local nameOfFeature
                                    -- if featureMap[xIndex][zIndex][position] ~= nil then
                                    --     nameOfFeature = featureList[featureMap[xIndex][zIndex][position]].nameOfFeature
                                    -- else
                                    --     nameOfFeature = featureList[featureMap[xIndex][zIndex][(position * 2) + 3]].nameOfFeature
                                    -- end
                                    -- printLine = printLine .. nameOfFeature:sub(1,1)

                                    local featureNum = featureMap[xIndex][zIndex][position]
                                    if featureNum == nil and position < 5 and featureMap[xIndex][zIndex][(position * 2) + 3] ~= nil and featureMap[xIndex][zIndex][(position * 2) + 3] == featureMap[xIndex][zIndex][(position * 2) + 4] then
                                        featureNum = featureMap[xIndex][zIndex][(position * 2) + 3]
                                    end
                                    if featureNum == nil then
                                        print("no feature found for x:" .. xIndex .. " z:" .. zIndex .. " position:" .. position .. " on tile:" .. tileGrid[xIndex][zIndex].tile_guid)
                                        if featureIndex < 100 then
                                            featureNum = 'XX'
                                        else
                                            featureNum = 'XXX'
                                        end
                                    else
                                        featureNum = tonumber(featureNum)
                                        if featureIndex < 100 then
                                            if featureNum < 10 then featureNum = '0' .. featureNum end
                                        else
                                            if featureNum < 10 then featureNum = '00' .. featureNum elseif featureNum < 100 then featureNum = '0' .. featureNum end
                                        end
                                    end
                                    printLine = printLine .. featureNum
                                end
                            end
                        else
                            if featureIndex < 100 then
                                printLine = printLine .. '                    '
                            else
                                printLine = printLine .. '                              '
                            end
                        end
                    end
                end
                --substituing 1's for L's to keep the character width consistent
                printLine = printLine:gsub("1", "L")
                print(printLine)
            end
        end
        printColumnMinX = printColumnMinX + chatWindowMaxWidth + 1
    end
    print("printing features...")
    for featureKey, feature in pairs(featureList) do
        local specialFeatures = ""
        for i, specialFeature in ipairs(feature.specialFeatures) do
            specialFeatures = specialFeatures .. specialFeature
            if i ~= #feature.specialFeatures then
                specialFeatures = specialFeatures .. ", "
            end
        end
        local featureOpenings = feature.openings
        if feature.nameOfFeature ~= 'Road' and feature.nameOfFeature ~= 'River' then featureOpenings = featureOpenings / 2 end
        featureKey = "" .. tonumber(featureKey)
        featureKey = featureKey:gsub("1", "L")
        print(featureKey .. " (" .. feature.nameOfFeature .. "): has " .. feature.numTiles .. " tiles and " .. featureOpenings .. " openings. Special Features: " .. specialFeatures)
    end
    print("printing links...")
    for linkType, originFeatures in pairs(linkedFeatures) do
        local printLine = linkType .. ": "
        local first = true
        for origin, destinationFeatures in pairs(originFeatures) do
            origin = tonumber(origin)
            local nestedFirst = true
            if not first then printLine = printLine .. "; " end
            first = false
            printLine = printLine .. origin .. " - "
            for destination, _ in pairs(destinationFeatures) do
                destination = tonumber(destination)
                if not nestedFirst then printLine = printLine .. ", " end
                nestedFirst = false
                printLine = printLine .. destination
            end
        end
        printLine = printLine:gsub("1", "L")
        print(printLine)
    end
end

function deleteMarkers()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
end

function getFeatureLocation(feature, tile, rotation)
    local x, z
    if feature < 13 then
        local a, side, j
        if feature < 5 then
            side = feature
            a = 0
            j = 0
        else
            side = math.floor((feature - 3) / 2)
            a = 1
            j = (feature - 3) % 2
        end
        x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, ((8 + TILE_STANDARD_ROTATION - side - rotation) % 4) + 1)
    else
        local specialFeatures = tile.getTable('specialFeatures')
        x, z = rotateCoordinates(specialFeatures[feature - 12][3][1], specialFeatures[feature - 12][3][2], (TILE_STANDARD_ROTATION - 1 - rotation) % 4 + 1)
    end
    return x, z
end

--getFeatureName
--
-- Gets the name of the feature on the tile at the specified position
--
-- params:
--  obj: tile
--  position: 1-12, 13-...
-- returns:
--  string: name
function getFeatureName(tile, position)
    local nameOfFeature
    if position < 5 then
        nameOfFeature = tile.getTable('sides')[position]
    elseif position < 13 then
        nameOfFeature = tile.getTable('sides')[math.floor((position - 3) / 2)]
        if nameOfFeature == 'Road' or nameOfFeature == 'River' then nameOfFeature = 'Field' end
    else
        local specialFeatures = tile.getTable('specialFeatures')
        if specialFeatures[position - 12] ~= nil then
            nameOfFeature = specialFeatures[position - 12][1]
        else
            nameOfFeature = "ERROR: Feature at position " .. position .. " doesn't exist"
        end
    end
    return nameOfFeature
end

--getFeatureComponents
--
-- Transverses the tiles recursively, storing all associated tiles, features, and followers into their respective global variables
--
-- params:
--  int: xIndex
--  int: zIndex
--  int: position number to check
--  int: number of transversal levels do check
--  bool: false if multiple getFeatureComponents calls will be made. This prevents resetting the transversal and also does not check for followers each time. The goal is to save on performance.
-- returns:
--  bool: true if the feature is complete, false if not complete
function getFeatureComponents(xIndex, zIndex, position, tranversalLevels, reset, reverseCityTransversal)
    if reset then --for when we want to make multiple feature transversals without revisiting already visited positions
        resetTransversal()
    end

    local nameOfFeature = getFeatureName(getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), position)
    local finished = 0
    if position < 5 then
        --if nameOfFeature == 'River' then return 0
        if nameOfFeature == 'Road' or nameOfFeature == 'River' then
            finished = getTileComponents(xIndex, zIndex, position, tranversalLevels, 1, false, reverseCityTransversal)
        else
            --in theory this shouldn't happen unless a player allows a figure to stay somewhere they're not supposed to
            --if it happens, just pick an arbitrary octant
            finished = getTileComponents(xIndex, zIndex, (position * 2) + 3, tranversalLevels, 1, false, reverseCityTransversal)
        end
    else
        finished = getTileComponents(xIndex, zIndex, position, tranversalLevels, 1, false, reverseCityTransversal)
    end

    if reset then -- don't run for each call of getFeatureComponents. Instead, getFigureComponents should be called from the calling method.
        getFigureComponents()
    end

    if finished == 0 then
        --debugMessage(2, "Feature is complete")
    else
        --debugMessage(2, "Feature is not complete: " .. finished .. " openings.")
    end

    return finished
end

--getFigureComponents
--
-- Transverses the all objects in the play area, storing followers and tokens that were in the transversed positions
function getFigureComponents()
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for _, obj in ipairs(objs) do
        if table.contains(FOLLOWER_TYPES, obj.getName()) or table.contains(SPECIAL_FIGURE_TYPES, obj.getName()) or table.contains(SHEEP_TOKEN_TYPES, obj.getName()) or obj.getName() == GOLD_BAR_NAME then
            local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            --debugMessage(2, "Object on tile: x: " .. xIndex .. " z: " .. zIndex)
            if obj.getName() == GOLD_BAR_NAME and table.contains(transversedTileCoords, {x=xIndex, z=zIndex}) then
                --debugMessage(2, obj.getName() .. " added to transversedGoldBars table")
                table.insert(transversedGoldBars, obj)
            elseif transversedFeaturePositions[xIndex] ~= nil and transversedFeaturePositions[xIndex][zIndex] ~= nil then
                local xPosition = (obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                xPosition = xPosition - xIndex
                zPosition = zPosition - zIndex
                local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation)
                --debugMessage(2, "Object closest feature: index: x: " .. xIndex .. " z: " .. zIndex .. " feature: " .. closestFeature)
                if transversedFeaturePositions[xIndex][zIndex][closestFeature] == 1 then
                    if table.contains(FOLLOWER_TYPES, obj.getName()) then
                        --debugMessage(2, obj.getDescription() .. " " .. obj.getName() .. " added to transversedFollowers table")
                        table.insert(transversedFollowers, obj)
                    elseif table.contains(SPECIAL_FIGURE_TYPES, obj.getName()) then
                        --debugMessage(2, obj.getDescription() .. " " .. obj.getName() .. " added to transversedSpecialFigures table")
                        table.insert(transversedSpecialFigures, obj)
                    elseif table.contains(SHEEP_TOKEN_TYPES, obj.getName()) then
                        --debugMessage(2, obj.getName() .. " added to transversedSheepTokens table")
                        table.insert(transversedSheepTokens, obj)
                    end
                end
            end
        end
    end
    --debugMessage(1, "Transversed " .. #transversedTileCoords .. " tiles, " .. #transversedFollowers .. " followers, " .. #transversedSpecialFigures .. " special figures, " .. #transversedSpecialFeatures .. " special features, " .. #transversedSheepTokens .. " sheep tokens, and " .. #transversedGoldBars .. " gold bars")
end

--getSecondaryFigureComponents
--
-- Transverses the all followers in the play area, returns true if any of them are in the temporaryFeaturePositions
function hasSecondaryFigureComponents()
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for _, obj in ipairs(objs) do
        if table.contains(FOLLOWER_TYPES, obj.getName()) then
            local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            --debugMessage(2, "Object on tile: x: " .. xIndex .. " z: " .. zIndex)
            if temporaryFeaturePositions[xIndex] ~= nil and temporaryFeaturePositions[xIndex][zIndex] ~= nil then
                local xPosition = (obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                xPosition = xPosition - xIndex
                zPosition = zPosition - zIndex
                local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation)
                --debugMessage(2, "Object closest feature: index: x: " .. xIndex .. " z: " .. zIndex .. " feature: " .. closestFeature)
                if temporaryFeaturePositions[xIndex][zIndex][closestFeature] ~= nil then
                    return true
                end
            end
        end
    end
    return false
end

--getTileComponents
--
-- Transverses the tiles recursively, storing all associated tiles, features, and followers into their respective global variables
--
-- params:
--  int: xIndex
--  int: zIndex
--  int: position number to check
--  int: how many transversal levels to check
--       2 levels would be used for checking secondary features such as completed cities and road intersections
--  int: current transversal level
--  bool: if this value is true, add feature positions to a temporary table. This is used to check secondary positions for followers for the wagon
--  bool: reverseCityTransversal - traverses from cities to fields, when the feature is a city. Currently only used for recalculating field connections from the city's point of view
-- returns:
--  bool: true if the feature is complete, false if not complete
function getTileComponents(xIndex, zIndex, position, tranversalLevels, transversalNum, addToTempPositions, reverseCityTransversal)
    if transversalNum > tranversalLevels then return 0 end
    --debugMessage(2, "checking tile at x: " .. xIndex .. " z: " .. zIndex .. " position: " .. position .. " trans num: " .. transversalNum)
    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
    local rotation = tileGrid[xIndex][zIndex].rotation
    if transversedGrid[xIndex] == nil then
        transversedGrid[xIndex] = {}
    end
    if transversedGrid[xIndex][zIndex] == nil then
        transversedGrid[xIndex][zIndex] = {}
    end
    if transversedFeaturePositions[xIndex] == nil then
        transversedFeaturePositions[xIndex] = {}
    end
    if transversedFeaturePositions[xIndex][zIndex] == nil then
        transversedFeaturePositions[xIndex][zIndex] = {}
    end
    if transversalNum == 1 and not table.contains(transversedTileCoords, {x=xIndex, z=zIndex}) then
        table.insert(transversedTileCoords, {x=xIndex, z=zIndex})
        --debugMessage(2, "adding tile to transversedTileCoords: x: " .. xIndex .. " z: " .. zIndex)
    end
    if addToTempPositions then
        if temporaryFeaturePositions[xIndex] == nil then
            temporaryFeaturePositions[xIndex] = {}
        end
        if temporaryFeaturePositions[xIndex][zIndex] == nil then
            temporaryFeaturePositions[xIndex][zIndex] = {}
        end
    end
    if transversedGrid[xIndex][zIndex][position] ~= nil and transversedGrid[xIndex][zIndex][position] <= transversalNum then return 0 end
    local finished = 0
    local specialFeatures = tile.getTable('specialFeatures')
    if position < 5 then
        local links = tile.getTable('linkedQuadrants')
        while transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum do
            if links ~= nil then
                for _, link in ipairs(links) do
                    if table.contains(link, position) then
                        for _, quadrant in ipairs(link) do
                            if transversedGrid[xIndex][zIndex][quadrant] == nil or transversedGrid[xIndex][zIndex][quadrant] > transversalNum then
                                transversedGrid[xIndex][zIndex][quadrant] = transversalNum
                                if transversalNum == 1 then
                                    transversedFeaturePositions[xIndex][zIndex][quadrant] = 1
                                elseif addToTempPositions then
                                    temporaryFeaturePositions[xIndex][zIndex][quadrant] = transversalNum
                                end
                                local direction = (3 + quadrant + rotation) % 4 + 1
                                local newX = xIndex + SIDE_DELTA[direction].x
                                local newZ = zIndex + SIDE_DELTA[direction].z
                                --debugMessage(2, "checking x:" .. xIndex .. " z:" .. zIndex .. " quadrant:" .. quadrant .. " direction:" .. direction .. " newX:" .. newX .. " newZ:" .. newZ .. " trans num: " .. transversalNum)
                                if tileGridOccupied(newX, newZ) then
                                    local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                                    local newTileRotation = tileGrid[newX][newZ].rotation
                                    local newTilePosition = (3 + quadrant + rotation - newTileRotation + TILE_180_ROTATION) % 4 + 1
                                    --debugMessage(2, "newTilePosition: " .. newTilePosition)
                                    if getFeatureName(newTile, newTilePosition) ~= 'Abbey' and getFeatureName(tile, position) ~= 'Abbey' then
                                        finished = finished + getTileComponents(newX, newZ, newTilePosition, tranversalLevels, transversalNum, false, reverseCityTransversal)
                                    elseif transversalNum == 1 then
                                        if getFeatureName(newTile, newTilePosition) == 'Abbey' then
                                            getTileComponents(newX, newZ, (newTilePosition * 2) + 3, tranversalLevels, transversalNum + 1, false, reverseCityTransversal)
                                        elseif getFeatureName(newTile, newTilePosition) ~= 'Field' then
                                            getTileComponents(newX, newZ, newTilePosition, tranversalLevels, transversalNum + 1, false, reverseCityTransversal)
                                        end
                                    end
                                else
                                    --debugMessage(2, "Next tile is empty. Feature is not finished")
                                    finished = finished + 1
                                end
                            end
                        end
                    end
                end
            end
             --workaround for when the target position has no links and is the first tile of the chain
             --in that case, the target position would never be checked, and, therefore, none of its neighbors
             --so we force it to be checked by running again with a links table containing the element
            if transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum then
                links = {{position}}
            end
        end
    elseif position < 13 then
        local links = tile.getTable('linkedOctants')
        while transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum do
            if links ~= nil then
                for _, link in ipairs(links) do
                    if table.contains(link, position) then
                        for _, octant in ipairs(link) do
                            if transversedGrid[xIndex][zIndex][octant] == nil or transversedGrid[xIndex][zIndex][octant] > transversalNum then
                                transversedGrid[xIndex][zIndex][octant] = transversalNum
                                if transversalNum == 1 then
                                    transversedFeaturePositions[xIndex][zIndex][octant] = 1
                                elseif addToTempPositions then
                                    temporaryFeaturePositions[xIndex][zIndex][octant] = transversalNum
                                end
                                local direction = (3 + octant + (rotation * 2)) % 8 + 5
                                local newX = xIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                                local newZ = zIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                                --debugMessage(2, "checking x:" .. xIndex .. " z:" .. zIndex .. " octant:" .. octant .. " direction:" .. direction .. " newX:" .. newX .. " newZ:" .. newZ .. " trans num: " .. transversalNum)
                                if tileGridOccupied(newX, newZ) then
                                    local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                                    local newTileRotation = tileGrid[newX][newZ].rotation
                                    local newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (newTileRotation * 2) - 4) % 8 + 5
                                    --debugMessage(2, "newTileRotation: " .. newTileRotation .. " newTilePosition: " .. newTilePosition)
                                    if getFeatureName(newTile, newTilePosition) ~= 'Abbey' and getFeatureName(tile, position) ~= 'Abbey' then
                                        finished = finished + getTileComponents(newX, newZ, newTilePosition, tranversalLevels, transversalNum, false, reverseCityTransversal)
                                    elseif transversalNum == 1 then -- all of this is for Abbeys and Wagons
                                        if getFeatureName(newTile, (newTilePosition - 3) / 2) == 'Road' then
                                            getTileComponents(newX, newZ, math.floor((newTilePosition - 3) / 2), tranversalLevels, transversalNum + 1, false, reverseCityTransversal)
                                        elseif getFeatureName(newTile, newTilePosition) ~= 'Field' then
                                            getTileComponents(newX, newZ, newTilePosition, tranversalLevels, transversalNum + 1, false, reverseCityTransversal)
                                        end
                                    end
                                else
                                    --debugMessage(2, "Next tile is empty. Feature is not finished")
                                    finished = finished + 1
                                end
                            end
                        end
                    end
                end
            end
             --workaround for when the target position has no links and is the first tile of the chain
             --in that case, the target position would never be checked, and, therefore, none of its neighbors
             --so we force it to be checked by running again with a links table containing the element
            if transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum then
                links = {{position}}
            end
        end
    else
        if transversedGrid[xIndex][zIndex][position] == nil or transversedGrid[xIndex][zIndex][position] > transversalNum then
            transversedGrid[xIndex][zIndex][position] = transversalNum
            if transversalNum == 1 then
                transversedFeaturePositions[xIndex][zIndex][position] = 1
            elseif addToTempPositions then
                temporaryFeaturePositions[xIndex][zIndex][position] = transversalNum
            end
            local feature = specialFeatures[position - 12]
            if feature[1] == 'Cloister' or feature[1] == 'Abbey' or feature[1] == 'Shrine' or feature[1] == "Baba Yaga's Hut" or feature[1] == 'Garden' then
                if transversalNum == 1 then
                    table.insert(transversedSpecialFeatures, feature[1])
                    --debugMessage(2, feature[1] .. " added to transversedSpecialFeatures")
                end
                local tileNum = 1
                for i = -1, 1 do
                    for j = -1, 1 do
                        if tileGridOccupied(xIndex + i, zIndex + j) then
                            if not (i == 0 and j == 0) then --we already added the tile
                                tileNum = tileNum + 1
                                if transversalNum == 1 then
                                    table.insert(transversedTileCoords, {x=xIndex + i, z=zIndex + j})
                                    local nestedSpecialFeatures = getObjectFromGUID(tileGrid[xIndex + i][zIndex + j].tile_guid).getTable('specialFeatures')
                                    if nestedSpecialFeatures ~= nil then
                                        for _, specialFeature in ipairs(nestedSpecialFeatures) do
                                            if specialFeature[1] == "Vineyard" then
                                                table.insert(transversedSpecialFeatures, specialFeature[1])
                                                --debugMessage(2, specialFeature[1] .. " added to transversedSpecialFeatures")
                                            end
                                        end
                                    end
                                end
                            end
                            --this is purely for graphical effect of showing what tiles were used in scoring the cloister
                            if transversalNum == 1 and not (i == 0 and j == 0 and feature[1] == 'Abbey') then
                                if transversedFeaturePositions[xIndex + i] == nil then
                                    transversedFeaturePositions[xIndex + i] = {}
                                end
                                if transversedFeaturePositions[xIndex + i][zIndex + j] == nil then
                                    transversedFeaturePositions[xIndex + i][zIndex + j] = {}
                                end
                                for k = 1, 12 do
                                    if transversedFeaturePositions[xIndex + i][zIndex + j][k] == nil then
                                        transversedFeaturePositions[xIndex + i][zIndex + j][k] = 2
                                    end
                                end
                            end
                        end
                    end
                end
                if tileNum < 9 then finished = finished + 9 - tileNum end
            end
            if feature[1] == 'City' or feature[1] == 'Road' or feature[1] == 'Field' or feature[1] == 'Abbey' then
                if feature[2] ~= nil then
                    for _, location in ipairs(feature[2]) do
                        if transversedGrid[xIndex][zIndex][location] == nil or transversedGrid[xIndex][zIndex][location] > transversalNum then
                            if transversalNum == 1 then
                                transversedFeaturePositions[xIndex][zIndex][location] = 1
                            elseif addToTempPositions then
                                temporaryFeaturePositions[xIndex][zIndex][location] = transversalNum
                            end
                            finished = finished + getTileComponents(xIndex, zIndex, location, tranversalLevels, transversalNum, false, reverseCityTransversal)
                        end
                    end
                end
            end
        end
    end
    if specialFeatures ~= nil then
        for i, feature in ipairs(specialFeatures) do
            if feature[2] ~= nil then
                if table.contains(feature[2], position) then
                    if (transversedGrid[xIndex][zIndex][i+12] == nil or transversedGrid[xIndex][zIndex][i+12] > transversalNum) and not (feature[1] == 'City-Field' and ((not reverseCityTransversal and getFeatureName(tile, position) ~= 'Field') or (reverseCityTransversal and getFeatureName(tile, position) ~= 'City'))) then
                        if feature[1] == 'Abbey' then
                            finished = finished + getTileComponents(xIndex, zIndex, i+12, tranversalLevels, transversalNum, false, reverseCityTransversal)
                        else
                            transversedGrid[xIndex][zIndex][i+12] = transversalNum
                            if transversalNum == 1 then
                                transversedFeaturePositions[xIndex][zIndex][i+12] = 1
                                if feature[1] == 'City-Field' then
                                    if getFeatureName(tile, position) == 'Field' or (reverseCityTransversal and getFeatureName(tile, position) == 'City') then
                                        for _, octant in ipairs(feature[2]) do
                                            if getFeatureName(tile, octant) == 'City' or getFeatureName(tile, octant) == 'Carcassonne' or (reverseCityTransversal and getFeatureName(tile, octant) == 'Field') then
                                                if transversedGrid[xIndex][zIndex][octant] == nil or transversedGrid[xIndex][zIndex][octant] > transversalNum + 1 then
                                                    if getTileComponents(xIndex, zIndex, octant, tranversalLevels, transversalNum + 1, false, reverseCityTransversal) == 0 or reverseCityTransversal then
                                                        if not reverseCityTransversal then
                                                            table.insert(transversedSpecialFeatures, "Completed City")
                                                            --debugMessage(2, "Completed City added to transversedSpecialFeatures")
                                                        end
                                                        transversedFeaturePositions[xIndex][zIndex][octant] = 2
                                                    end
                                                end
                                            end
                                        end
                                    end
                                elseif feature[1] == 'Road Intersection' then
                                    for _, location in ipairs(feature[2]) do
                                        temporaryFeaturePositions = {}
                                        if getTileComponents(xIndex, zIndex, location, tranversalLevels, transversalNum + 1, true, reverseCityTransversal) > 0 then
                                            if not hasSecondaryFigureComponents() then
                                                hasIncompleteSecondaryFeature = true
                                            end
                                        end
                                    end
                                elseif feature[1] == 'Coat of Arms' or feature[1] == 'Inn' or feature[1] == 'Cathedral' or
                                    feature[1] == 'Cloth Token' or feature[1] == 'Wine Token' or feature[1] == 'Wheat Token' or
                                    feature[1] == 'Pig-herd' or feature[1] == 'Sheep' then
                                    table.insert(transversedSpecialFeatures, feature[1])
                                    --debugMessage(2, feature[1] .. " added to transversedSpecialFeatures")
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    for i=1, 4 do
        --this one is necessary for followers placed on center positions for quadrant features to be processed correctly
        if getFeatureName(tile, i) ~= 'Road' and getFeatureName(tile, i) ~= 'River' then
            if transversedFeaturePositions[xIndex][zIndex][i] ~= nil then
                if transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] == nil or transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] > transversedFeaturePositions[xIndex][zIndex][i] then
                    transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] = transversedFeaturePositions[xIndex][zIndex][i]
                end
                if transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] == nil or transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] > transversedFeaturePositions[xIndex][zIndex][i] then
                    transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] = transversedFeaturePositions[xIndex][zIndex][i]
                end
            end
            if addToTempPositions and temporaryFeaturePositions[xIndex][zIndex][i] ~= nil then
                if temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] == nil or temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] > temporaryFeaturePositions[xIndex][zIndex][i] then
                    temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] = temporaryFeaturePositions[xIndex][zIndex][i]
                end
                if temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] == nil or temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] > temporaryFeaturePositions[xIndex][zIndex][i] then
                    temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] = temporaryFeaturePositions[xIndex][zIndex][i]
                end
            end
            --this is just used for graphical effect
            if transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] ~= nil and transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] ~= nil and transversedFeaturePositions[xIndex][zIndex][i * 2 + 3] == transversedFeaturePositions[xIndex][zIndex][i * 2 + 4] then
                transversedFeaturePositions[xIndex][zIndex][i] = transversedFeaturePositions[xIndex][zIndex][i * 2 + 3]
            end
            if addToTempPositions and temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] ~= nil and temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] ~= nil and temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3] == temporaryFeaturePositions[xIndex][zIndex][i * 2 + 4] then
                temporaryFeaturePositions[xIndex][zIndex][i] = temporaryFeaturePositions[xIndex][zIndex][i * 2 + 3]
            end
            if addToTempPositions and transversedGrid[xIndex][zIndex][i * 2 + 3] ~= nil and transversedGrid[xIndex][zIndex][i * 2 + 4] ~= nil and transversedGrid[xIndex][zIndex][i * 2 + 3] == transversedGrid[xIndex][zIndex][i * 2 + 4] then
                transversedGrid[xIndex][zIndex][i] = transversedGrid[xIndex][zIndex][i * 2 + 3]
            end
        end
    end
    return finished
end

--resetTransversal
--Empties the transversal tables, so that they are ready for the next transversal
function resetTransversal()
    --debugMessage(2, "Clearing transversal tables")
    transversedGrid = {}
    temporaryFeaturePositions = {}
    transversedFeaturePositions = {}
    transversedTileCoords = {}
    transversedSpecialFeatures = {}
    transversedFollowers = {}
    transversedSpecialFigures = {}
    transversedSheepTokens = {}
    transversedGoldBars = {}
    return
end

--will print a message to all plyaers, but not to the log
function gameNotification(msg, rgb, target_player)
    if target_player == nil then
        printToAll(msg, rgb)
    else
        if controlPanelSettings[target_player .. 'Control'] ~= nil then
            target_player = controlPanelSettings[target_player .. 'Control']
        end
        for _, player in ipairs(getSeatedPlayers()) do
            if player == target_player then
                broadcastToColor(msg, player, rgb)
            else
                printToColor(msg, player, rgb)
            end
        end
    end
end

--will print a message to all players, broadcasting to the target_player
--spectators will not receive this message if target_player is not nil
function allGameMessage(msg, rgb, target_player)
    if target_player == nil then
        printToAll(msg, rgb)
    else
        if controlPanelSettings[target_player .. 'Control'] ~= nil then
            target_player = controlPanelSettings[target_player .. 'Control']
        end
        for _, player in ipairs(getSeatedPlayers()) do
            if player == target_player then
                broadcastToColor(msg, player, rgb)
            else
                printToColor(msg, player, rgb)
            end
        end
    end
    -- local params = {}
    -- notes = getNotebookTabs()
    --
    -- params.index = gameLogTabIndex
    -- params.body = notes[gameLogTabIndex].body .. "\n" .. msg
    -- editNotebookTab(params)
end

--will print an error message to all players
function allErrorMessage(msg, target_player)
    if target_player == nil then
        broadcastToAll(msg, ERROR_COLOR)
    else
        if controlPanelSettings[target_player .. 'Control'] ~= nil then
            target_player = controlPanelSettings[target_player .. 'Control']
        end
        for _, player in ipairs(getSeatedPlayers()) do
            if player == target_player then
                broadcastToColor(msg, player, ERROR_COLOR)
            else
                printToColor(msg, player, ERROR_COLOR)
            end
        end
    end
end

--will print an error message to the target player
function playerErrorMessage(msg, target_player)
    local target_player_owner = nil
    if controlPanelSettings[target_player .. 'Control'] ~= nil then
        target_player_owner = controlPanelSettings[target_player .. 'Control']
    end
    if target_player_owner == nil then target_player_owner = target_player end
    if Player[target_player_owner].seated then
        broadcastToColor(msg, target_player_owner, ERROR_COLOR)
    else
        broadcastToColor("You are seated in another player's hotseat and cannot play.", target_player, ERROR_COLOR)
    end
end

--will print the message if the debug level is high enough
function debugMessage(level, msg)
    if debugMode >= level then
        -- local params = {}
        -- notes = getNotebookTabs()
        --
        -- params.index = debugLogTabIndex
        -- params.body = notes[debugLogTabIndex].body .. "\n" .. msg
        -- editNotebookTab(params)
        print(msg)
    end
end

--will return a string in the form of bracketed hex codes (ie. [ffffff] for white) when passed the string name of the color
function stringToBracketedHex(color)
    return RGBToBracketedHex(player_color_tints[color])
end

--returns the bracketed hex color code for a color, which can be used to add colors to strings (ie. [ffffff] for white). input table must include correct rgb tags to work
function RGBToBracketedHex(rgb)
    if rgb ~= nil then
        return "[" .. string.format("%02x%02x%02x", rgb.r*255,rgb.g*255,rgb.b*255) .. "]"
    else
        return ""
    end
end

--perform takeObject only if the object exists in the container
function takeObjectSafe(container, params)
    if params.guid ~= nil then
        for _, item in pairs(container.getObjects()) do
            if item.guid == params.guid then
                return container.takeObject(params)
            end
        end
    else
        return container.takeObject(params)
    end
    printToAll("Warning: Object " .. params.guid .. " not found in container. It may have already been removed.", ERROR_COLOR)
end

--true if element is one of the elements of the table, otherwise false
--if element is a table, then checks if an identical table is in the table
function table.contains(table, element)
    if type(element) == 'table' then
        for _, subtable in pairs(table) do
            local allMatch = true
            for key, value in pairs(subtable) do
                if value ~= element[key] then
                    allMatch = false
                end
            end
            if allMatch then return true end
        end
    else
        for _, value in pairs(table) do
            if value == element then
                return true
            end
        end
    end
    return false
end

--non-recursive table copy
function table.shallow_copy(t)
  local t2 = {}
  for k,v in pairs(t) do
    t2[k] = v
  end
  return t2
end

--waits for the specified number of seconds. Can only be run from a coroutine
function wait(time)
  local start = os.clock()
  repeat coroutine.yield(0) until os.clock() > start + time
end

--isWithinErrorMargin
-- params:
--  float: number (to be compared)
--  float: targetNumber (to be compared to)
--  float: errorMargin
-- returns:
--  bool: true if number is within errorMargin of targetNumber
function isWithinErrorMargin(number, targetNumber, errorMargin)
    if number > targetNumber - errorMargin and number < targetNumber + errorMargin then return true
    else return false
    end
end

-------------------------------------------------------------------

--AI Code

-------------------------------------------------------------------

END_GAME_TRANSITION = 35 --when there are less than this number of tiles, the AI will begin abandoning difficult to complete roads with inns and cities with cathedrals
SCORE_THREAT_THRESHOLD = 50 --players that are more than this many points behind are no longer considered a threat and won't be factored into the decisions
FOLLOWER_SCORE_THRESHOLD = 0.75 --player won't use a figure to take a feature unless it is worth at least this much
USED_FOLLOWER_PENALTY = 0.45 --each follower that a player doesn't have in their supply will make it more picky of when to use a follower by this many points
OPEN_FEATURE_PENALTY = 0.30 --score penalty to apply for each open end of this feature, to provide incentive for easier features to complete
FIELD_PENALTY = 2.0 --score penalty to apply to the field, to prevent it being used too early in the game
AI_DRAW_TILE_TIME = 1.5 --time delay to allow the drawn tile to travel to the AI player's hand
UNFINISHED_TRADE_TOKEN_VALUE = 1.0

function AIStateHandler()
    --debugMessage(1, "AIStateHandler - " .. turnState)
    if turnState == 'begin turn' then
        hasAlreadyTakenBuilderTile = false
        wagonLocations = {}
        hasAvailableWagonFeature = {}
        newBarn = nil
        lastPlacedTileX = nil
        return nextState('next')
    elseif turnState == 'reward fairy' then
        return rewardFairy()
    elseif turnState == 'eliminate oldest flea' then
        return nextState('next')
    elseif turnState == 'awaiting tile placement' then
        gameNotification("AI player is calculating their move...", NEUTRAL_COLOR, activePlayers[currentPlayer])
        startLuaCoroutine(self, 'AIChooseTileLocation')
    elseif turnState == 'check added tile features' then
        buriedTile = nil
        tileHasVolcano = false
        tileHasMagicPortal = false
        seducedKnights = {}
        currentPlayerAbbot = nil
        shepherdAwaitingAction = nil
        hasBuilderAwaitingAction = false
        return nextState('next')
    elseif turnState == 'check added tile feature - hill' then
        return checkTileForHill()
    elseif turnState == 'check added tile feature - volcano' then
        return checkTileForVolcano()
    elseif turnState == 'check added tile feature - volcano - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=2.00})
    elseif turnState == 'check added tile feature - volcano - lock' then
        getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid).setLock(true)
        return nextState('next')
    elseif turnState == 'check added tile feature - magic portal' then
        return checkTileForMagicPortal()
    elseif turnState == 'check added tile feature - gold' then
        return checkTileForGold()
    elseif turnState == 'place gold on tile' then
        gameNotification("AI not implemented for expansion: The Goldmines", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return addGoldToTile(lastPlacedTileX, lastPlacedTileZ)
    elseif turnState == 'awaiting gold placement' then
        gameNotification("Choose a location to place the gold bar", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return displayGoldButtons()
    elseif turnState == 'check added tile feature extensions' then
        return checkAddedTileFeatureExtensions()
    elseif turnState == 'awaiting figure decision' then
        if highestScorePos == nil then
            gameNotification("AI decided not to place a figure.", NEUTRAL_COLOR, activePlayers[currentPlayer])
            return nextState('skip figure')
        else
            return AIMoveFigureToLocation()
        end
    elseif turnState == 'retrieve abbot' then
        return
    elseif turnState == 'retrieve abbot - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'wait for flier roll' then
        gameNotification("AI not implemented for expansion: The Fliers", NEUTRAL_COLOR, activePlayers[currentPlayer])
        --gameNotification("Roll the flier die to determine your flier's distance.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'check flier destination' then
        return checkFlierDestination()
    elseif turnState == 'awaiting flier decision' then
        gameNotification("AI not implemented for expansion: The Fliers", NEUTRAL_COLOR, activePlayers[currentPlayer])
        --gameNotification("Place the flier on the destination tile.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'initialize shepherd' then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        if controlPanelSettings['PnDDragon'] then
            return addSheepToTile(shepherd)
        else
            return addSheepToField(shepherd)
        end
    elseif turnState == 'initialize shepherd - finish' then
        shepherdAwaitingAction = nil
        return nextState('next')
    elseif turnState == 'seduce knight' then
        return returnFigures()
    elseif turnState == 'seduce knight - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'return flier' then
        return returnFigures()
    elseif turnState == 'return flier - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'post figure events' then
        seducedKnights = {}
        currentPlayerAbbot = nil
        return nextState('next')
    elseif turnState == 'post figure event - prompt shepherd' then
        return promptShepherd()
    elseif turnState == 'check added tile feature - dragon' then
        shepherdAwaitingAction = nil
        return checkTileForDragon()
    elseif turnState == 'post figure event - dragon movement' then
        if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
        if dragonMoveNumber <= 6 then
            return createDragonButtons()
        else
            return nextState('next')
        end
    elseif turnState == 'post figure event - dragon movement - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=1.00})
    elseif turnState == 'post figure event - dragon movement - lock' then
        getObjectFromGUID(expansionBags['PnD'].contents['PnDDragon'].guid).setLock(true)
        return nextState('next')
    elseif turnState == 'score features' then
        currentMiniTurn = nil
        for _, tileCoords in ipairs(dragonIllegalTiles) do
            getObjectFromGUID(tileGrid[tileCoords[1]][tileCoords[2]].tile_guid).highlightOff()
        end
        return scoreFeatures()
    elseif turnState == 'score features - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    elseif turnState == 'post scoring events' then
        return nextState('next')
    elseif turnState == 'reward gold' then
        return rewardGold()
    elseif turnState == 'replace finished wagons' then
        return replaceFinishedWagons()
    elseif turnState == 'check for extra builder turn' then
        if hasBuilderAwaitingAction then
            hasAlreadyTakenBuilderTile = true
            allGameMessage(activePlayers[currentPlayer] .."'s builder has allowed them to draw another tile. Please do so, along with the usual actions, before ending your turn.", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
            return nextState('has builder')
        else
            return nextState('no builder')
        end
    elseif turnState == 'end turn' then
        return endTurn()
    elseif turnState == 'game over' then
        return scoreFeatures()
    elseif turnState == 'game over - delay' then
        Timer.create({identifier=os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=FIGURE_RETURN_DELAY})
    end
end

function AIChooseTileLocation()
    --debugMessage(2, "AI choosing tile location...")
    lastFrameTime = os.clock()
    local newTile = nil
    local handPosition = {Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_x, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_y, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_z}
    if controlPanelSettings['StartingTileRiverII'] or controlPanelSettings['StartingTileRiver'] or controlPanelSettings['StartingTileRiverBB5'] then
        if forkTile_GUID ~= nil then
            newTile = getObjectFromGUID(forkTile_GUID)
            newTile.setPositionSmooth(handPosition)
        elseif riverBodyTiles_GUID ~= nil then
            local riverStack = getObjectFromGUID(riverBodyTiles_GUID)
            if riverStack ~= nil then
                newTile = riverStack.dealToColorWithOffset( {0,0,0}, true, handColor[activePlayers[currentPlayer]])
            end
        elseif getObjectFromGUID(tileStack_GUID) ~= nil and finalTile_GUID ~= nil then
            newTile = getObjectFromGUID(finalTile_GUID)
            newTile.setPositionSmooth(handPosition)
        elseif springTile_GUID ~= nil then
            newTile = getObjectFromGUID(springTile_GUID)
            newTile.setPositionSmooth(handPosition)
        elseif lakeTile_GUID ~= nil then
            newTile = getObjectFromGUID(lakeTile_GUID)
            newTile.setPositionSmooth(handPosition)
        end
        if newTile ~= nil then
            alreadyFound = true
        end
    end
    local tileStack = nil
    if newTile == nil then
        tileStack = getObjectFromGUID(tileStack_GUID)
        if tileStack ~= nil then
            newTile = tileStack.dealToColorWithOffset( {0,0,0}, true, handColor[activePlayers[currentPlayer]])
            --getObjectFromGUID(tileStack_GUID).dealToColor(1, getCurrentPlayerOwner())
        elseif finalTile_GUID ~= nil then
            newTile = getObjectFromGUID(finalTile_GUID)
            local handPosition = {Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_x, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_y, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_z}
            newTile.setPositionSmooth(handPosition)
        else
            allGameMessage("AI could not find the tile stack. The game is assumed to be over.", NEUTRAL_COLOR, nil)
            return 1
        end
    end

    calculationStart = os.clock()
    AICalculateBaselineScores()

    lastDrawnTile_GUID = newTile.getGUID()
    coroutine.yield(0)

    if startingTile_GUID ~= nil then
        local tileConfigurations = {}
        for x, tileColumn in pairs(tileGrid) do
            for z, tileLocation in pairs(tileColumn) do
                for side, sideDelta in pairs(SIDE_DELTA) do
                    if not tileGridOccupied(x + sideDelta.x, z + sideDelta.z) then
                        if tileConfigurations[x + sideDelta.x] == nil then
                            tileConfigurations[x + sideDelta.x] = {}
                        end
                        if tileConfigurations[x + sideDelta.x][z + sideDelta.z] == nil then
                            tileConfigurations[x + sideDelta.x][z + sideDelta.z] = true
                            for tileRotation=1, 4 do
                                if isValidTileLocation(newTile, tileRotation, x + sideDelta.x, z + sideDelta.z, false) then
                                    AICalculateLocationScore(newTile, tileRotation, x + sideDelta.x, z + sideDelta.z)
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        highestScoreX = 25
        highestScoreZ = 25
        highestScoreRot = 4
    end

    local posText = highestScorePos
    local figureText = highestScoreFigure
    if highestScorePos == nil then posText = "N/A" end
    if highestScoreFigure == nil then figureText = "None" end
    if highestScoreX ~= nil then
        --debugMessage(1, "highest score: " .. highestScore .. " at x:" .. highestScoreX .. " z:" .. highestScoreZ .. " rot:" .. highestScoreRot .. " pos:" .. posText .. " figure: " .. figureText)
        --print("Calculation complete in: " .. os.clock() - calculationStart .. " seconds.")
        AIMoveTileToLocation(newTile, highestScoreX, highestScoreZ, highestScoreRot)
    else
        allGameMessage("AI could not find a location for the tile. It will be reshuffled into the tile stack, and a new tile drawn. If you encountered this message, but there is a legal spot to put the tile, it might be a bug.", NEUTRAL_COLOR, nil)
        if tileStack ~= nil then
            tileStack.putObject(newTile)
            wait(2.0)
            tileStack.shuffle()
            wait(0.1)
            AIChooseTileLocation()
        else
            allErrorMessage("ERROR: Cannot return this tile to the tilestack. If this tile is part of a river, you will need to manually shuffle it back in and skip back to this AI player. If there is no tilestack, you will need to discard it or skip their turn. If all else fails, restart the game. If this tile is the last tile in the game, you should discard it and end the game.", activePlayers[currentPlayer])
        end
    end
    return 1
end

--initialize this so it will compile correctly
activeFigures = {}

function AICalculateBaselineScores()
    highestScore = -999
    highestScoreX = nil
    highestScoreZ = nil
    highestScoreRot = nil
    highestScorePos = nil
    highestScoreFigure = nil
    numIdenticalScore = 1

    baselineScores = {}
    baselineFollowerCounts = {}
    baselineFigures = {}
    activeFigures = {}

    for _, player in pairs(activePlayers) do
        baselineFollowerCounts[player] = 0
        baselineFigures[player] = {}
    end

    local objs = getAllObjects()
    for _, obj in ipairs(objs) do
        if table.contains(FOLLOWER_TYPES, obj.getName()) or table.contains(SPECIAL_FIGURE_TYPES, obj.getName()) then
            local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                local xPosition = (obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
                xPosition = xPosition - xIndex
                zPosition = zPosition - zIndex
                local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                local rotation = tileGrid[xIndex][zIndex].rotation
                local closestPosition = findClosestFeatureMap(xPosition, zPosition, tile, rotation)
                local featureNum = featureMap[xIndex][zIndex][closestPosition]

                if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(closestPosition * 2) + 3] ~= nil then
                    if featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'Road' and featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'River' then
                        featureNum = featureMap[xIndex][zIndex][(closestPosition * 2) + 3]
                    end
                end
                --print(obj.getGUID() .. ": pos - " .. closestPosition .. " featureNum - " .. featureNum)
                if activeFigures[featureNum] == nil then
                    activeFigures[featureNum] = {}
                    activeFigures[featureNum].specialFigures = {}
                    activeFigures[featureNum].followers = {}
                end
                if table.contains(FOLLOWER_TYPES, obj.getName()) then
                    table.insert(activeFigures[featureNum].followers, obj)
                else
                    table.insert(activeFigures[featureNum].specialFigures, obj)
                end
            elseif obj.getName() ~= 'Follower' then
                baselineFigures[obj.getDescription()][obj.getName()] = true
            else
                baselineFollowerCounts[obj.getDescription()] = baselineFollowerCounts[obj.getDescription()] + 1
            end
        end
    end

    -- for featureNum, figures in pairs(activeFigures) do
    --     local numFollowers = 0
    --     local numFigures = 0
    --     if figures.followers ~= nil then
    --         numFollowers = #figures.followers
    --     end
    --     if figures.specialFigures ~= nil then
    --         numFigures = #figures.specialFigures
    --     end
    --     print("feature " .. featureNum .. " has " .. numFollowers .. " followers, " .. numFigures .. " special figures.")
    -- end

    --since we haven't joined any features yet, the currently active figures can be used
    joinedActiveFigures = activeFigures
    tempFeatureList = featureList
    tempLinkedFeatures = linkedFeatures

    AICalculateActiveScores()
    --debugMessage(1, "baseline scores:")
    for _, player in pairs(activePlayers) do
        baselineScores[player] = activeScores[player]
        --debugMessage(1, " " .. player .. ": " .. baselineScores[player])
    end
end

function AICalculateLocationScore(newTile, tileRotation, xIndex, zIndex)
    --debugMessage(1, "AICalculateLocationScore at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
    --temporarily insert this tile into the grid
    if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
    tileGrid[xIndex][zIndex] = {}
    tileGrid[xIndex][zIndex].tile_guid = newTile.getGUID()
    tileGrid[xIndex][zIndex].rotation = tileRotation
    addTile(xIndex, zIndex, newTile, tileRotation, true)
    joinedActiveFigures = {}
    for featureNum, figureList in pairs(activeFigures) do
        if tempJoinedFeature[featureNum] ~= nil then
            featureNum = tempJoinedFeature[featureNum]
        end
        if joinedActiveFigures[featureNum] == nil then
            joinedActiveFigures[featureNum] = {}
            joinedActiveFigures[featureNum].followers = {}
            joinedActiveFigures[featureNum].specialFigures = {}
        end
        for _, follower in ipairs(figureList.followers) do
            table.insert(joinedActiveFigures[featureNum].followers, follower)
        end
        for _, figure in ipairs(figureList.specialFigures) do
            table.insert(joinedActiveFigures[featureNum].specialFigures, figure)
        end
    end
    AICalculateActiveScores(xIndex, zIndex)
    local scoreChange = {}
    local spareFollowerCounts = {}
    local moveScore = 0
    for _, player in pairs(activePlayers) do
        scoreChange[player] = activeScores[player] - baselineScores[player]
        spareFollowerCounts[player] = followerCountChange[player] + baselineFollowerCounts[player]
        --print(player .. " score of " .. baselineScores[player] .. " changed to " .. activeScores[player] .. " difference of " .. scoreChange[player])
        --print(player .. " spare followers: " .. baselineFollowerCounts[player] .. " changed to " .. spareFollowerCounts[player] .. " difference of " .. followerCountChange[player])
    end
    for _, player in pairs(activePlayers) do
        if player == activePlayers[currentPlayer] then
            moveScore = moveScore + scoreChange[player] + followerCountChange[player] * USED_FOLLOWER_PENALTY
            --print("score change of " .. scoreChange[player] .. " follower adjusted by " .. followerCountChange[player] * USED_FOLLOWER_PENALTY .. " final move score: " .. moveScore)
        elseif #activePlayers <= 2 then
            moveScore = moveScore - scoreChange[player] - followerCountChange[player] * USED_FOLLOWER_PENALTY
        elseif activeScores[activePlayers[currentPlayer]] - activeScores[player] < SCORE_THREAT_THRESHOLD then
            -- if this opponent is SCORE_THREAT_THRESHOLD points behind (after this move), then we don't care about their score change
            moveScore = moveScore - (scoreChange[player] * (SCORE_THREAT_THRESHOLD - (activeScores[activePlayers[currentPlayer]] + followerCountChange[player] * USED_FOLLOWER_PENALTY) + activeScores[player]) / SCORE_THREAT_THRESHOLD) / (#activePlayers - 1)
            --print(player .. ":subtract score of " .. scoreChange[player] * (SCORE_THREAT_THRESHOLD - (activeScores[activePlayers[currentPlayer]] + followerCountChange[player] * USED_FOLLOWER_PENALTY)) .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        end
    end

    local tilesRemaining = 0
    if getObjectFromGUID(tileStack_GUID) ~= nil then
        tilesRemaining = getObjectFromGUID(tileStack_GUID).getQuantity()
    elseif finalTile_GUID ~= nil then
        tilesRemaining = 1
    end
    local numRemainingMoves = math.floor(tilesRemaining / #activePlayers) + 1

    local highestUnusedFeature = 0

    local featureVisited = { }
    local featuresToVisit = { }

    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for i, feature in ipairs(specialFeatures) do
            if feature[3] ~= nil then
                table.insert(featuresToVisit, i+12)
            end
        end
    end
    for i=1, 12 do
        table.insert(featuresToVisit, i)
    end

    for _, i in ipairs(featuresToVisit) do
        local direction
        if i < 5 then
            direction = (3 + i + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
        elseif i < 13 then
            direction = (3 + i + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
        else
            direction = i
        end
        local featureNum = tempFeatureMap[direction]
        if featureNum == nil and i < 5 and tempFeatureMap[(direction * 2) + 3] ~= nil then
            if tempFeatureList[tempFeatureMap[(direction * 2) + 3]].nameOfFeature ~= 'Road' and tempFeatureList[tempFeatureMap[(direction * 2) + 3]].nameOfFeature ~= 'River' then
                featureNum = tempFeatureMap[(direction * 2) + 3]
            end
        end
        if featureNum ~= nil and tempJoinedFeature[featureNum] ~= nil then
            featureNum = tempJoinedFeature[featureNum]
        end

        if featureNum ~= nil and featureVisited[featureNum] ~= true then
            local featureFigures = joinedActiveFigures[featureNum]
            if featureFigures == nil then
                featureFigures = {}
                featureFigures.followers = {}
                featureFigures.specialFigures = {}
            end
            local featureScore, featureOpenings, nameOfFeature = AICalculateFeatureScore(featureNum, featureFigures)
            local spareFollowerAdjustment = (-7 * USED_FOLLOWER_PENALTY) + (spareFollowerCounts[activePlayers[currentPlayer]] * USED_FOLLOWER_PENALTY)
            local score

            if numRemainingMoves > spareFollowerCounts[activePlayers[currentPlayer]] and (featureOpenings > 0 or nameOfFeature == 'Field') then
                score = featureScore + moveScore + spareFollowerAdjustment
                if nameOfFeature ~= 'Field' and nameOfFeature ~= 'Cloister' then
                    score = score - featureOpenings * OPEN_FEATURE_PENALTY
                elseif nameOfFeature == 'Cloister' then
                    --TODO: I think cloister needs a slight penalty
                end
            else
                score = featureScore + moveScore
            end

            local usedFeature = false
            local playerHasFollower = false
            for _, follower in ipairs(featureFigures.followers) do
                if follower.getDescription() == activePlayers[currentPlayer] and (follower.getName() == 'Follower' or follower.getName() == 'Wagon' or follower.getName() == 'Abbot' or follower.getName() == 'Big Follower' or follower.getName() == 'Mayor') then
                    playerHasFollower = true
                end
            end

            if #featureFigures.followers == 0 then
                if (baselineFollowerCounts[activePlayers[currentPlayer]] > 0 or baselineFigures[activePlayers[currentPlayer]]['Big Follower']) and (numRemainingMoves <= spareFollowerCounts[activePlayers[currentPlayer]] or (featureScore + spareFollowerAdjustment > FOLLOWER_SCORE_THRESHOLD or featureOpenings == 0)) then
                    if score == highestScore then
                        --debugMessage(1, "found identical meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                        numIdenticalScore = numIdenticalScore + 1
                    end
                    if score > highestScore or (math.random(numIdenticalScore) == 1 and score == highestScore) then -- this is to lessen the bias towards one side of the play area
                        --debugMessage(1, "found new best meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                        --debugMessage(1, "moveScore:".. moveScore .. " spareFollowerAdjustment:" .. spareFollowerAdjustment .. " openFeaturePenalty:" .. featureOpenings * OPEN_FEATURE_PENALTY .. " featureScore:" .. featureScore)
                        if score > highestScore then
                            numIdenticalScore = 1
                        end
                        highestScore = score
                        highestScoreX = xIndex
                        highestScoreZ = zIndex
                        highestScoreRot = tileRotation
                        highestScorePos = i
                        print(featureNum)
                        if baselineFigures[activePlayers[currentPlayer]]['Big Follower'] and (baselineFollowerCounts[activePlayers[currentPlayer]] == 0 or nameOfFeature == 'City') then
                            highestScoreFigure = 'Big Follower'
                        else
                            highestScoreFigure = 'Follower'
                        end
                        usedFeature = true
                    end
                end
                if not usedFeature and nameOfFeature ~= 'Field' and nameOfFeature ~= 'Cloister' then
                    highestUnusedFeature = featureScore
                end
            elseif playerHasFollower and nameOfFeature == 'Field' and baselineFigures[activePlayers[currentPlayer]]['Pig'] then
                score = featureScore / 3
                if score == highestScore then
                    --debugMessage(1, "found identical pig score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                    numIdenticalScore = numIdenticalScore + 1
                end
                if score > highestScore or (math.random(numIdenticalScore) == 1 and score == highestScore) then -- this is to lessen the bias towards one side of the play area
                    --debugMessage(1, "found new best pig score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                    if score > highestScore then
                        numIdenticalScore = 1
                    end
                    highestScore = score
                    highestScoreX = xIndex
                    highestScoreZ = zIndex
                    highestScoreRot = tileRotation
                    highestScorePos = i
                    highestScoreFigure = 'Pig'
                    usedFeature = true
                end
            elseif playerHasFollower and featureOpenings > 0 and (nameOfFeature == 'City' or nameOfFeature == 'Road') and baselineFigures[activePlayers[currentPlayer]]['Builder'] then
                if moveScore == highestScore then
                    --debugMessage(1, "found identical builder score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                    numIdenticalScore = numIdenticalScore + 1
                end
                if moveScore > highestScore or (math.random(numIdenticalScore) == 1 and moveScore == highestScore) then -- this is to lessen the bias towards one side of the play area
                    --debugMessage(1, "found new best builder score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                    if score > highestScore then
                        numIdenticalScore = 1
                    end
                    highestScore = score
                    highestScoreX = xIndex
                    highestScoreZ = zIndex
                    highestScoreRot = tileRotation
                    highestScorePos = i
                    highestScoreFigure = 'Builder'
                    usedFeature = true
                end
            end
            featureVisited[featureNum] = true
        end
    end
    moveScore = moveScore - highestUnusedFeature * 0.02 -- meant to slightly disourage from building a feature for someone else to take
    if moveScore == highestScore then
        --debugMessage(1, "found identical tile score: " .. moveScore .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        numIdenticalScore = numIdenticalScore + 1
    end
    if moveScore > highestScore or (math.random(numIdenticalScore) == 1 and moveScore == highestScore) then -- this is to lessen the bias towards one side of the play area
        --debugMessage(1, "found new best tile score: " .. moveScore .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        if moveScore > highestScore then
            numIdenticalScore = 1
        end
        highestScore = moveScore
        highestScoreX = xIndex
        highestScoreZ = zIndex
        highestScoreRot = tileRotation
        highestScorePos = nil
        highestScoreFigure = nil
    end

    tileGrid[xIndex][zIndex] = nil
end

function AICalculateActiveScores(newXIndex, newZIndex)
    --debugMessage(2, "AI checking current active scores..")
    if os.clock() - lastFrameTime > FRAME_TIME then
        lastFrameTime = lastFrameTime + FRAME_TIME
        coroutine.yield(0)
    end
    activeScores = {}
    followerCountChange = {}
    for _, player in pairs(activePlayers) do
        local scoreCounter = getObjectFromGUID(score_counter_guids[player])
        if scoreCounter ~= nil then
            activeScores[player] = getObjectFromGUID(score_counter_guids[player]).Counter.getValue()
        else
            activeScores[player] = 0
        end
        followerCountChange[player] = 0
    end

    if newXIndex ~= nil and (controlPanelSettings['TnBTradeGoods'] or controlPanelSettings['TnBBuilder']) then
        local specialFeatures = {}
        local newTile = getObjectFromGUID(tileGrid[newXIndex][newZIndex].tile_guid)

        if newTile.getTable('sides')[1] ~= 'Abbey' then
            for featureNum, feature in pairs(tempFeatureList) do
                if feature.openings == 0 and feature.nameOfFeature == 'City' then
                    for _, specialFeature in ipairs(feature.specialFeatures) do
                        if table.contains(TRADE_TOKEN_TYPES, specialFeature) then
                            table.insert(specialFeatures, specialFeature)
                        end
                    end
                end
                if joinedActiveFigures[featureNum] ~= nil and (feature.nameOfFeature == 'City' or feature.nameOfFeature == 'Road') then
                    for _, specialFigure in ipairs(joinedActiveFigures[featureNum].specialFigures) do
                        if specialFigure.getDescription() == activePlayers[currentPlayer] then --do not give give sheep/extra builder tile (CAR ref 149)
                            if specialFigure.getName() == 'Shepherd' then
                                --TODO: implement
                            elseif specialFigure.getName() == 'Builder' and not hasAlreadyTakenBuilderTile then
                                activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + 1
                            end
                        end
                    end
                end
            end
        else
            local visitedFeatures = {}
            for i=1, 12 do --roads and cities
                local newX, newZ, newTilePosition
                if i < 5 then
                    local direction = (3 + i + TILE_STANDARD_ROTATION) % 4 + 1
                    newX = newXIndex + SIDE_DELTA[direction].x
                    newZ = newZIndex + SIDE_DELTA[direction].z
                    newTilePosition = (3 + i + TILE_180_ROTATION) % 4 + 1
                else
                    local direction = (3 + i + (TILE_STANDARD_ROTATION * 2)) % 8 + 5
                    newX = newXIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                    newZ = newZIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                    newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction) % 8 + 5
                end
                if featureMap[newX] ~= nil and featureMap[newX][newZ] ~= nil then
                    local featureNum = featureMap[newX][newZ][newTilePosition]
                    if not table.contains(visitedFeatures, featureNum) then
                        local feature = tempFeatureList[featureNum]
                        if feature == nil then feature = featureList[featureNum] end
                        if feature.openings == 0 and feature.nameOfFeature == 'City' then
                            for _, specialFeature in ipairs(feature.specialFeatures) do
                                if table.contains(TRADE_TOKEN_TYPES, specialFeature) then
                                    table.insert(specialFeatures, specialFeature)
                                end
                            end
                        end
                        table.insert(visitedFeatures, featureNum)
                    end
                end
            end
        end

        if controlPanelSettings['TnBTradeGoods'] then
            for _, specialFeature in ipairs(specialFeatures) do
                local highestNumTokens = 0
                local secondHighestTokens = 0
                local numRemainingTokens = TRADE_TOKEN_COUNTS[specialFeature]
                local tokenCounts = {}
                tokenCounts[activePlayers[currentPlayer]] = 0
                --find the highest count for this token
                for _, player in ipairs(activePlayers) do
                    local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                    local playerNumTokens = 0
                    for _, obj in ipairs(playerPossessions) do
                        if obj.getName() == specialFeature then
                            local quantity = obj.getQuantity()
                            if quantity == -1 then quantity = 1 end
                            if tokenCounts[player] == nil then
                                tokenCounts[player] = quantity
                            else
                                tokenCounts[player] = tokenCounts[player] + quantity
                            end
                            numRemainingTokens = numRemainingTokens - quantity
                        end
                    end
                    if tokenCounts[player] ~= nil and tokenCounts[player] >= highestNumTokens then
                        secondHighestTokens = highestNumTokens
                        highestNumTokens = tokenCounts[player]
                    end
                end
                --basically, tokens are only worth something if:
                --you are first place and second place has enough tokens to catch up
                --or you are not first place, but have enough tokens left to catch up
                if (tokenCounts[activePlayers[currentPlayer]] == highestNumTokens and highestNumTokens - secondHighestTokens <= numRemainingTokens) or
                (tokenCounts[activePlayers[currentPlayer]] ~= highestNumTokens and highestNumTokens - tokenCounts[activePlayers[currentPlayer]] <= numRemainingTokens) then
                    if #activePlayers > 1 then
                        activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + ((10 + (10 / (#activePlayers - 1))) / numRemainingTokens)
                    else
                        activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + 20
                    end
                end
            end
        end
    end
    for featureNum, featureFigures in pairs(joinedActiveFigures) do
        local score, featureOpenings, nameOfFeature = AICalculateFeatureScore(featureNum, featureFigures)
        local followerCounts = {}
        local hasHill = {}
        local hasMayor = {}
        local topWeight = -1
        --find the relative weights for the followers on this feature
        for _, follower in ipairs(featureFigures.followers) do
            if featureOpenings == 0 and nameOfFeature ~= 'Field' then
                followerCountChange[follower.getDescription()] = followerCountChange[follower.getDescription()] + 1
            end
            local weight = 0
            if follower.getName() == 'Follower' or follower.getName() == 'Wagon' or follower.getName() == 'Abbot' then weight = 1
            elseif follower.getName() == 'Big Follower' then weight = 2
            elseif follower.getName() == 'Mayor' then
                for _, specialFeature in ipairs(transversedSpecialFeatures) do
                    if specialFeature == 'Coat of Arms' then weight = weight + 1 end
                end
                hasMayor[follower.getDescription()] = true
            end
            if weight > 0 then
                local followerXIndex = math.floor((follower.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local followerZIndex = math.floor((follower.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                local specialFeatures = getObjectFromGUID(tileGrid[followerXIndex][followerZIndex].tile_guid).getTable('specialFeatures')
                if controlPanelSettings['HnSHills'] and specialFeatures ~= nil then
                    for _, specialFeature in ipairs(specialFeatures) do
                        if specialFeature[1] == "Hill" then
                            --although it would have been easier to just add 0.001 to the weight here, it would have technically violated the rules, since multiple hills are not supposed to give extra weight.
                            hasHill[follower.getDescription()] = true
                        end
                    end
                end
            end
            if followerCounts[follower.getDescription()] == nil then
                followerCounts[follower.getDescription()] = weight
            else
                followerCounts[follower.getDescription()] = followerCounts[follower.getDescription()] + weight
            end
        end
        --add hill weight if there is a hill, find top weight for the feature
        for player, value in pairs(followerCounts) do
            if hasHill[player] then
                --if the follower is on a hill, add a small value to it to break any ties
                followerCounts[player] = followerCounts[player] + 0.001
            end
            if followerCounts[player] > topWeight then topWeight = followerCounts[player] end
        end
            -- local closestFollower = fairyClosestFollower()
            -- if closestFollower == follower then
            --     allGameMessage(closestFollower.getDescription() .. " " .. closestFollower.getName() .. " scores 3 points for being next to the fairy when scoring a feature.", player_color_tints[closestFollower.getDescription()])
            --     scorePoints(closestFollower.getDescription(), 'Fairy', 3)
            -- end
            -- if follower.getName() == "Wagon" then
            --     wagonLocations[follower.getDescription()] = {}
            --     wagonLocations[follower.getDescription()].x = follower.getPosition().x
            --     wagonLocations[follower.getDescription()].z = follower.getPosition().z
            --     hasAvailableWagonFeature[follower.getDescription()] = hasIncompleteSecondaryFeature
            -- end
            -- local winner = false
        for player, value in pairs(followerCounts) do
            if (topWeight > 0 and value >= topWeight) then
                activeScores[player] = activeScores[player] + score
            end
        end
    end
end

function AICalculateFeatureScore(featureNum, figures)
    --debugMessage(3, "AICalculateFeatureScore")
    local feature = tempFeatureList[featureNum]
    if feature == nil then feature = featureList[featureNum] end

    local nameOfFeature = feature.nameOfFeature
    local specialFeatures = feature.specialFeatures
    local featureOpenings = feature.openings
    local numTiles = feature.numTiles
    if nameOfFeature == 'River' or nameOfFeature == 'Carcassonne' then
        return -1000, featureOpenings, nameOfFeature
    end

    local tilesRemaining = 0
    if getObjectFromGUID(tileStack_GUID) ~= nil then
        tilesRemaining = getObjectFromGUID(tileStack_GUID).getQuantity()
    elseif finalTile_GUID ~= nil then
        tilesRemaining = 1
    end

    local featureComplete
    if featureOpenings == 0 then
        featureComplete = true
    else
        featureComplete = false
    end

    local hasPig = {}
    --local hasBarn = false
    --local hasNewBarn = false
    for _, figure in ipairs(figures.specialFigures) do
        if figure.getName() == 'Pig' then hasPig[figure.getDescription()] = true end
        -- if figure.getName() == 'Barn' then
        --     hasBarn = true
        --     if newBarn ~= nil and figure.getGUID() == newBarn then
        --         hasNewBarn = true
        --         newBarn = nil
        --     end
        --     --recalculate "follower count" with only barns. Technically they aren't followers but it was easier in code.
        --     if #transversedFollowers == 0 then
        --         if followerCounts[figure.getDescription()] == nil then
        --             followerCounts[figure.getDescription()] = 1
        --         else
        --             followerCounts[figure.getDescription()] = followerCounts[figure.getDescription()] + 1
        --         end
        --         if followerCounts[figure.getDescription()] > topWeight then topWeight = followerCounts[figure.getDescription()] end
        --     end
        -- end
    end
    local score = 0
    local containsPigHerd = false
    if nameOfFeature == 'City' and not controlPanelSettings['BaseDisableCities'] then
        score = numTiles
        local containsCathedral = false
        for _, feature in ipairs(specialFeatures) do
            if feature == 'Coat of Arms' then
                score = score + 1
            elseif table.contains(TRADE_TOKEN_TYPES, feature) and featureOpenings > 0 then
                score = score + UNFINISHED_TRADE_TOKEN_VALUE
            end
            if feature == 'Cathedral' and controlPanelSettings['InCCathedrals'] then
                containsCathedral = true
            end
        end
        if containsCathedral then
            if featureComplete then
                --in order to get the AI to prioritize city pieces, we need to inflate the incomplete value to be partway between the complete value
                --however, this creates a lower score difference between a completed city and an incomplete one. In order to make sure that the AI still
                --tries to finish the city, we give it a small bonus (roughly equal to the complete score minus the incomplete score)
                local bonus = score * 3 - (score * 3 * tilesRemaining / END_GAME_TRANSITION)
                score = score * 3
                score = score + bonus
            else
                if tilesRemaining > END_GAME_TRANSITION then
                    score = score * 2.4
                else
                    if tilesRemaining / END_GAME_TRANSITION > 1 / (featureOpenings + 1) then
                        score = score * 3 * tilesRemaining / END_GAME_TRANSITION
                    else
                        score = score * 3 / (featureOpenings + 1)
                    end
                end
            end
        else
            if featureComplete then
                --in order to get the AI to prioritize city pieces, we need to inflate the incomplete value to be partway between the complete value
                --however, this creates a lower score difference between a completed city and an incomplete one. In order to make sure that the AI still
                --tries to finish the city, we give it a small bonus (roughly equal to the complete score minus the incomplete score)
                local bonus
                if tilesRemaining > END_GAME_TRANSITION then
                    bonus = score * 0.4
                else
                    bonus = score - (score * 0.6 * tilesRemaining / END_GAME_TRANSITION)
                end
                score = score * 2
                score = score + bonus
            else
                if tilesRemaining > END_GAME_TRANSITION then
                    score = score * 1.6
                else
                    score = score + score * 0.6 * tilesRemaining / END_GAME_TRANSITION
                end
            end
        end
        --do not nerf cities that were completed by an abbey, or incomplete cities
        if lastPlacedTileX ~= nil and getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).getTable('sides')[1] ~= 'Abbey' and
           featureComplete and controlPanelSettings['BaseNerfSmallCity'] and score == 4 then score = 2 end
    elseif nameOfFeature == 'Field' and not controlPanelSettings['BaseDisableFarms'] then
        local numCities = 0

        local linkedCities = tempLinkedFeatures['City-Field'][featureNum]
        if linkedCities == nil then linkedCities = linkedFeatures['City-Field'][featureNum] end
        if linkedCities ~= nil then
            for connectedFeatureNum, _ in pairs(linkedCities) do
                local openings
                if tempFeatureList[connectedFeatureNum] ~= nil then
                    openings = tempFeatureList[connectedFeatureNum].openings
                else
                    openings = featureList[connectedFeatureNum].openings
                end
                if openings == 0 then
                    numCities = numCities + 1
                end
            end
        end
        for _, feature in ipairs(specialFeatures) do
            -- if feature == 'Completed City' then
            --     numCities = numCities + 1
            -- end
            if feature == 'Pig-herd' and not controlPanelSettings['RIIDisablePigherd'] then
                containsPigHerd = true
            end
        end
        featureComplete = false --so that this feature won't be scored before the end of the game
        local scoreMultiplier = 3
        -- if hasBarn then
        --     if #transversedFollowers > 0 then
        --         if not hasNewBarn then
        --             scoreMultiplier = 1
        --         end
        --     else
        --         scoreMultiplier = 4
        --     end
        -- end
        if hasPig[player] ~= nil then
            scoreMultiplier = scoreMultiplier + 1
        end
        if containsPigHerd and #figures.followers > 0 then -- CAR pg 67 ref 194
            scoreMultiplier = scoreMultiplier + 1
        end
        if tilesRemaining > END_GAME_TRANSITION * 2.0 then
            scoreMultiplier = scoreMultiplier - 2.0
        else
            scoreMultiplier = scoreMultiplier - (tilesRemaining / END_GAME_TRANSITION)
        end
        score = (numCities * scoreMultiplier) - FIELD_PENALTY
    elseif nameOfFeature == 'Road' and not controlPanelSettings['BaseDisableRoads'] then
        score = numTiles
        local containsInn = false
        for _, feature in ipairs(specialFeatures) do
            if feature == 'Inn' and controlPanelSettings['InCInns'] then
                containsInn = true
            end
        end
        if containsInn then
            if featureComplete then
                score = score * 2
            else
                if tilesRemaining > END_GAME_TRANSITION then
                    score = score * 2
                else
                    if tilesRemaining / END_GAME_TRANSITION > 1 / (featureOpenings + 1) then
                        score = score * 2 * tilesRemaining / END_GAME_TRANSITION
                    else
                        score = score * 2 / (featureOpenings + 1)
                    end
                end
            end
        end
    elseif (nameOfFeature == 'Cloister' and not controlPanelSettings['BaseDisableCloisters']) or nameOfFeature == 'Abbey' or nameOfFeature == 'Shrine' then
        score = 1
        for x=-1, 1 do
            for z=-1, 1 do
                if not (x == 0 and z == 0) and tileGridOccupied(feature.featureLocation.x + x, feature.featureLocation.z + z) then
                    score = score + 1
                    if controlPanelSettings['HnSVineyards'] then
                        local specialFeatures = getObjectFromGUID(tileGrid[feature.featureLocation.x + x][feature.featureLocation.z + z].tile_guid).getTable('specialFeatures')
                        if specialFeatures ~= nil then
                            for _, feature in ipairs(specialFeatures) do
                                if feature == 'Vineyard' then
                                    if featureComplete then
                                        score = score + 3
                                    else
                                        if tilesRemaining > END_GAME_TRANSITION then
                                            score = score + 3
                                        else
                                            if tilesRemaining / END_GAME_TRANSITION > 1 / featureOpenings then
                                                score = score + 3 * tilesRemaining / END_GAME_TRANSITION
                                            else
                                                score = score + 3 / featureOpenings
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        featureOpenings = 9 - score
        -- if featureComplete then
        --     local challengerTile, challengedTile
        --     if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
        --         challengerTile = 'Cloister'
        --         challengedTile = 'Shrine'
        --     else
        --         challengerTile = 'Shrine'
        --         challengedTile = 'Cloister'
        --     end
        --     for x=-1, 1 do
        --         for z=-1, 1 do
        --             if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
        --                 local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
        --                 if specialFeatures ~= nil then
        --                     for i, feature in ipairs(specialFeatures) do
        --                         local adjacentFeature = feature[1]
        --                         if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
        --                         if adjacentFeature == challengedTile then
        --                             local numTiles = 0
        --                             for nested_x=-1, 1 do
        --                                 for nested_z=-1, 1 do
        --                                     if tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
        --                                         numTiles = numTiles + 1
        --                                     end
        --                                 end
        --                             end
        --                             if numTiles ~= 9 then
        --                                 local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
        --                                 for _, object in ipairs(objs) do
        --                                     if table.contains(FOLLOWER_TYPES, object.getName()) then
        --                                         local objectXIndex = math.floor((object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        --                                         local objectZIndex = math.floor((object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        --                                         if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
        --                                             local xPosition = (object.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x) / TILE_SPACING
        --                                             local zPosition = (object.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z) / TILE_SPACING
        --                                             xPosition = xPosition - objectXIndex
        --                                             zPosition = zPosition - objectZIndex
        --                                             local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), rotation)
        --                                             if closestFeature == i + 12 then
        --                                                 object.setLock(false)
        --                                                 object.use_gravity = false
        --                                                 object.interactable = false
        --                                                 --raise the follower in the air
        --                                                 object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)
        --                                                 table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        --                                                 allGameMessage(object.getDescription() .. " " .. object.getName() .. " has lost the Cloister/Shrine challenge.", player_color_tints[object.getDescription()])
        --                                             end
        --                                         end
        --                                     end
        --                                 end
        --                             end
        --                         end
        --                     end
        --                 end
        --             end
        --         end
        --     end
        -- end
    end
    return score, featureOpenings, nameOfFeature
end

function AIMoveTileToLocation(newTile, xIndex, zIndex, tileRotation)
    if os.clock() - calculationStart < AI_DRAW_TILE_TIME then -- wait a minimum of this many seconds to make it flow nicer
        wait(AI_DRAW_TILE_TIME - (os.clock() - calculationStart))
    end

    local x, z = rotateCoordinates(0, -3, player_possession_areas[activePlayers[currentPlayer]].rotation)

    newTile.setPosition({newTile.getPosition().x + x, newTile.getPosition().y, newTile.getPosition().z + z})
    newTile.setPositionSmooth({xIndex * TILE_SPACING + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, TABLE_SURFACE_Y, zIndex * TILE_SPACING + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z})

    if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
    tileGrid[xIndex][zIndex] = {}
    tileGrid[xIndex][zIndex].tile_guid = newTile.getGUID()
    tileGrid[xIndex][zIndex].rotation = tileRotation
    if newTile.getGUID() == finalTile_GUID then
        finalTile_GUID = nil
    end
    if newTile.getGUID() == forkTile_GUID then
        forkTile_GUID = nil
    end
    if newTile.getGUID() == springTile_GUID then
        springTile_GUID = nil
    end
    if newTile.getGUID() == lakeTile_GUID then
        lakeTile_GUID = nil
    end
    lastPlacedTileX = xIndex
    lastPlacedTileZ = zIndex

    if AUTOLOCK then
        newTile.setLock(true)
    end
    addTile(xIndex, zIndex, newTile, tileRotation, false)
    if startingTile_GUID == nil and newTile.getVar('isStartingPiece') then
        startingTile_GUID = newTile.getGUID()
    end
    if startingRiverTile_GUID == nil and newTile.getVar('isStartingPiece') then
        startingRiverTile_GUID = newTile.getGUID()
    end

    newTile.interactable = false
    newTile.setPositionSmooth({xIndex * TILE_SPACING + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, TABLE_SURFACE_Y, zIndex * TILE_SPACING + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z}, false, false)
    newTile.setRotationSmooth({0, tileRotation * 90, 0})
    Timer.create({identifier=newTile.getGUID() .. os.clock(), function_name='AILockTile', function_owner=nil, parameters={tile=newTile}, delay=2.0})
end

function AILockTile(params)
    local tile = params.tile
    tile.interactable = true
    if AUTOLOCK then
        tile.setLock(true)
    end
    return nextState('tile placed')
end

function AIMoveFigureToLocation()
    local tile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    local nameOfFeature = getFeatureName(tile, highestScorePos)
    local x, z = getFeatureLocation(highestScorePos, tile, tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation)
    for _, obj in ipairs(getAllObjects()) do
        if highestScoreFigure == obj.getName() and obj.getDescription() == activePlayers[currentPlayer] then
            local xIndex = math.floor((obj.getPosition().x - MIDDLE_LOCATION.x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z - MIDDLE_LOCATION.z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            if tileGrid[xIndex] == nil or tileGrid[xIndex][zIndex] == nil then
                local pieceRotation = 0
                if highestScorePos < 5 then pieceRotation = (highestScorePos - 1) * 90
                elseif highestScorePos < 13 then pieceRotation = math.floor((highestScorePos - 5) / 2) * 90 end
                if (obj.getName() == 'Follower' or obj.getName() == 'Big Follower') and nameOfFeature == 'Field' then
                    --lay the Follower down
                    obj.setRotationSmooth({tile.getRotation().x + 90, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                else
                    --align with the tile
                    obj.setRotationSmooth({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                end
                obj.interactable = false
                obj.setPositionSmooth({(x * TILE_SPACING) + (lastPlacedTileX * TILE_SPACING) + MIDDLE_LOCATION.x - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (lastPlacedTileZ * TILE_SPACING) + MIDDLE_LOCATION.z - MIDDLE_OFFSET.z})
                Timer.create({identifier=obj.getGUID() .. os.clock(), function_name='AILockFigure', function_owner=nil, parameters={figure=obj}, delay=2.0})
                break
            end
        end
    end
end

function AILockFigure(params)
    local figure = params.figure
    figure.interactable = true
    if AUTOLOCK then
        figure.setLock(true)
    end
    return nextState('placed figure')
end