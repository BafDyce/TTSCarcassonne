-------------------------------------------------------------------

--AI Code

-------------------------------------------------------------------

END_GAME_TRANSITION = 35 --when there are less than this number of tiles, the AI will begin abandoning difficult to complete roads with inns and cities with cathedrals
SCORE_THREAT_THRESHOLD = 50 --players that are more than this many points behind are no longer considered a threat and won't be factored into the decisions
FOLLOWER_SCORE_THRESHOLD = 0.75 --player won't use a figure to take a feature unless it is worth at least this much
USED_FOLLOWER_PENALTY = 0.45 --each follower that a player doesn't have in their supply will make it more picky of when to use a follower by this many points
OPEN_FEATURE_PENALTY = 0.30 --score penalty to apply for each open end of this feature, to provide incentive for easier features to complete
FIELD_PENALTY = 2.5 --score penalty to apply to the field, to prevent it being used too early in the game
AI_DRAW_TILE_TIME = 1.0 --time delay to allow the drawn tile to travel to the AI player's hand
AI_ANIMATIONS_ENABLED = false --will move pieces smoothly if true, otherwise the pieces will instantly move
UNFINISHED_TRADE_TOKEN_VALUE = 1.0

function AIStateHandler()
    --debugMessage(1, "AIStateHandler - " .. turnState)
    if turnState == 'awaiting tile placement' then
        gameNotification("AI player is calculating their move...", NEUTRAL_COLOR, activePlayers[currentPlayer])
        startLuaCoroutine(self, 'AIChooseTileLocation')
    elseif turnState == 'place gold on tile' then
        gameNotification("AI not implemented for expansion: The Goldmines", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return addGoldToTile(lastPlacedTileX, lastPlacedTileZ)
    elseif turnState == 'awaiting gold placement' then
        gameNotification("AI not implemented for expansion: The Goldmines", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return displayGoldButtons()
    elseif turnState == 'awaiting figure decision' then
        if highestScorePos == nil then
            gameNotification("AI decided not to place a figure.", NEUTRAL_COLOR, activePlayers[currentPlayer])
            return nextState('skip figure')
        else
            return AIMoveFigureToLocation()
        end
    elseif turnState == 'wait for flier roll' then
        gameNotification("AI not implemented for expansion: The Fliers", NEUTRAL_COLOR, activePlayers[currentPlayer])
        --gameNotification("Roll the flier die to determine your flier's distance.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'awaiting flier decision' then
        gameNotification("AI not implemented for expansion: The Fliers", NEUTRAL_COLOR, activePlayers[currentPlayer])
        --gameNotification("Place the flier on the destination tile.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'post figure event - prompt shepherd' then
        if shepherdAwaitingAction ~= nil then
            gameNotification("AI not implemented for expansion: Hills & Sheep", NEUTRAL_COLOR, activePlayers[currentPlayer])
            --return promptShepherd()
        else
            return nextState('next')
        end
    elseif turnState == 'post figure event - dragon movement' then
        gameNotification("AI not implemented for expansion: The Princess & The Dragon", NEUTRAL_COLOR, activePlayers[currentPlayer])
        --if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
        --if dragonMoveNumber <= 6 then
        --    return createDragonButtons()
        --else
        --    return nextState('next')
        --end
    --elseif turnState == 'replace finished wagons' then
    --    gameNotification("AI not implemented for expansion: The Abbey & The Mayor", NEUTRAL_COLOR, activePlayers[currentPlayer])
        --return replaceFinishedWagons()
    else
        return stateHandler()
    end
end

function AIChooseTileLocation()
    --debugMessage(2, "AI choosing tile location...")
    lastFrameTime = os.clock()
    local newTile = nil
    local handPosition = {Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_x, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_y, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_z}
    if controlPanelSettings['StartingTileRiverII'] or controlPanelSettings['StartingTileRiver'] or controlPanelSettings['StartingTileRiverBB5'] then
        if forkTile_GUID ~= nil then
            newTile = getObjectFromGUID(forkTile_GUID)
            newTile.setPositionSmooth(handPosition)
        elseif riverBodyTiles_GUID ~= nil then
            local riverStack = getObjectFromGUID(riverBodyTiles_GUID)
            if riverStack ~= nil then
                newTile = riverStack.dealToColorWithOffset( {0,0,0}, true, handColor[activePlayers[currentPlayer]])
            end
        elseif getObjectFromGUID(tileStack_GUID) ~= nil and finalTile_GUID ~= nil then
            newTile = getObjectFromGUID(finalTile_GUID)
            newTile.setPositionSmooth(handPosition)
        elseif springTile_GUID ~= nil then
            newTile = getObjectFromGUID(springTile_GUID)
            newTile.setPositionSmooth(handPosition)
        elseif lakeTile_GUID ~= nil then
            newTile = getObjectFromGUID(lakeTile_GUID)
            newTile.setPositionSmooth(handPosition)
        end
        if newTile ~= nil then
            alreadyFound = true
        end
    end
    local tileStack = nil
    if newTile == nil then
        tileStack = getObjectFromGUID(tileStack_GUID)
        if tileStack ~= nil then
            newTile = tileStack.dealToColorWithOffset( {0,0,0}, true, handColor[activePlayers[currentPlayer]])
            --getObjectFromGUID(tileStack_GUID).dealToColor(1, getCurrentPlayerOwner())
        elseif finalTile_GUID ~= nil then
            newTile = getObjectFromGUID(finalTile_GUID)
            local handPosition = {Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_x, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_y, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_z}
            newTile.setPositionSmooth(handPosition)
        else
            allGameMessage("AI could not find the tile stack. The game is assumed to be over.", NEUTRAL_COLOR, nil)
            return 1
        end
    end

    calculationStart = os.clock()
    AICalculateBaselineScores()

    lastDrawnTile_GUID = newTile.getGUID()
    coroutine.yield(0)

    if startingTile_GUID ~= nil then
        local tileConfigurations = {}
        for x, tileColumn in pairs(tileGrid) do
            for z, tileLocation in pairs(tileColumn) do
                for side, sideDelta in pairs(SIDE_DELTA) do
                    if not tileGridOccupied(x + sideDelta.x, z + sideDelta.z) then
                        if tileConfigurations[x + sideDelta.x] == nil then
                            tileConfigurations[x + sideDelta.x] = {}
                        end
                        if tileConfigurations[x + sideDelta.x][z + sideDelta.z] == nil then
                            tileConfigurations[x + sideDelta.x][z + sideDelta.z] = true
                            for tileRotation=1, 4 do
                                if isValidTileLocation(newTile, tileRotation, x + sideDelta.x, z + sideDelta.z, false) then
                                    AICalculateLocationScore(newTile, tileRotation, x + sideDelta.x, z + sideDelta.z)
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        highestScoreX = 20
        highestScoreZ = 20
        highestScoreRot = 4
    end

    local posText = highestScorePos
    local figureText = highestScoreFigure
    if highestScorePos == nil then posText = "N/A" end
    if highestScoreFigure == nil then figureText = "None" end
    if highestScoreX ~= nil then
        --debugMessage(1, "highest score: " .. highestScore .. " at x:" .. highestScoreX .. " z:" .. highestScoreZ .. " rot:" .. highestScoreRot .. " pos:" .. posText .. " figure: " .. figureText)
        --print("Calculation complete in: " .. os.clock() - calculationStart .. " seconds.")
        AIMoveTileToLocation(newTile, highestScoreX, highestScoreZ, highestScoreRot)
    else
        allGameMessage("AI could not find a location for the tile. It will be reshuffled into the tile stack, and a new tile drawn. If you encountered this message, but there is a legal spot to put the tile, it might be a bug.", NEUTRAL_COLOR, nil)
        if tileStack ~= nil then
            tileStack.putObject(newTile)
            wait(2.0)
            tileStack.shuffle()
            wait(0.1)
            AIChooseTileLocation()
        else
            allErrorMessage("ERROR: Cannot return this tile to the tilestack. If this tile is part of a river, you will need to manually shuffle it back in and skip back to this AI player. If there is no tilestack, you will need to discard it or skip their turn. If all else fails, restart the game. If this tile is the last tile in the game, you should discard it and end the game.", activePlayers[currentPlayer])
        end
    end
    return 1
end

--initialize this so it will compile correctly

function AICalculateBaselineScores()
    highestScore = -999
    highestScoreX = nil
    highestScoreZ = nil
    highestScoreRot = nil
    highestScorePos = nil
    highestScoreFigure = nil
    numIdenticalScore = 1

    getActiveFigures()

    -- for featureNum, figures in pairs(activeFigures) do
    --     local numFollowers = 0
    --     local numFigures = 0
    --     if figures.followers ~= nil then
    --         numFollowers = #figures.followers
    --     end
    --     if figures.specialFigures ~= nil then
    --         numFigures = #figures.specialFigures
    --     end
    --     print("feature " .. featureNum .. " has " .. numFollowers .. " followers, " .. numFigures .. " special figures.")
    -- end

    --since we haven't joined any features yet, the currently active figures can be used
    joinedActiveFigures = activeFigures
    tempFeatureList = featureList
    tempLinkedFeatures = linkedFeatures

    AICalculateActiveScores()

    baselineScores = {}
    --debugMessage(1, "baseline scores:")
    for _, player in pairs(activePlayers) do
        baselineScores[player] = activeScores[player]
        --debugMessage(1, " " .. player .. ": " .. baselineScores[player])
    end
end

function AICalculateLocationScore(newTile, tileRotation, xIndex, zIndex)
    --debugMessage(1, "AICalculateLocationScore at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
    --temporarily insert this tile into the grid
    if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
    tileGrid[xIndex][zIndex] = {}
    tileGrid[xIndex][zIndex].tile_guid = newTile.getGUID()
    tileGrid[xIndex][zIndex].rotation = tileRotation
    addTile(xIndex, zIndex, newTile, tileRotation, true)
    joinedActiveFigures = {}
    for featureNum, figureList in pairs(activeFigures) do
        if tempJoinedFeature[featureNum] ~= nil then
            featureNum = tempJoinedFeature[featureNum]
        end
        if joinedActiveFigures[featureNum] == nil then
            joinedActiveFigures[featureNum] = {}
            joinedActiveFigures[featureNum].followers = {}
            joinedActiveFigures[featureNum].specialFigures = {}
        end
        for _, follower in ipairs(figureList.followers) do
            table.insert(joinedActiveFigures[featureNum].followers, follower)
        end
        for _, figure in ipairs(figureList.specialFigures) do
            table.insert(joinedActiveFigures[featureNum].specialFigures, figure)
        end
    end
    AICalculateActiveScores(xIndex, zIndex)
    local scoreChange = {}
    local spareFollowerCounts = {}
    local moveScore = 0
    for _, player in pairs(activePlayers) do
        scoreChange[player] = activeScores[player] - baselineScores[player]
        spareFollowerCounts[player] = followerCountChange[player] + baselineFollowerCounts[player]
        --print(player .. " score of " .. baselineScores[player] .. " changed to " .. activeScores[player] .. " difference of " .. scoreChange[player])
        --print(player .. " spare followers: " .. baselineFollowerCounts[player] .. " changed to " .. spareFollowerCounts[player] .. " difference of " .. followerCountChange[player])
    end
    for _, player in pairs(activePlayers) do
        if player == activePlayers[currentPlayer] then
            moveScore = moveScore + scoreChange[player] + followerCountChange[player] * USED_FOLLOWER_PENALTY
            --print("score change of " .. scoreChange[player] .. " follower adjusted by " .. followerCountChange[player] * USED_FOLLOWER_PENALTY .. " final move score: " .. moveScore)
        elseif #activePlayers <= 2 then
            moveScore = moveScore - scoreChange[player] - followerCountChange[player] * USED_FOLLOWER_PENALTY
        elseif activeScores[activePlayers[currentPlayer]] - activeScores[player] < SCORE_THREAT_THRESHOLD then
            -- if this opponent is SCORE_THREAT_THRESHOLD points behind (after this move), then we don't care about their score change
            moveScore = moveScore - (scoreChange[player] * (SCORE_THREAT_THRESHOLD - (activeScores[activePlayers[currentPlayer]] + followerCountChange[player] * USED_FOLLOWER_PENALTY) + activeScores[player]) / SCORE_THREAT_THRESHOLD) / (#activePlayers - 1)
            --print(player .. ":subtract score of " .. scoreChange[player] * (SCORE_THREAT_THRESHOLD - (activeScores[activePlayers[currentPlayer]] + followerCountChange[player] * USED_FOLLOWER_PENALTY)) .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        end
    end

    local tilesRemaining = 0
    if getObjectFromGUID(tileStack_GUID) ~= nil then
        tilesRemaining = getObjectFromGUID(tileStack_GUID).getQuantity()
    elseif finalTile_GUID ~= nil then
        tilesRemaining = 1
    end
    local numRemainingMoves = math.floor(tilesRemaining / #activePlayers) + 1

    local highestUnusedFeature = 0

    local featureVisited = { }
    local featuresToVisit = { }

    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for i, feature in ipairs(specialFeatures) do
            if feature[3] ~= nil then
                table.insert(featuresToVisit, i+12)
            end
        end
    end
    for i=1, 12 do
        table.insert(featuresToVisit, i)
    end

    for _, i in ipairs(featuresToVisit) do
        local direction
        if i < 5 then
            direction = (3 + i + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
        elseif i < 13 then
            direction = (3 + i + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
        else
            direction = i
        end
        local featureNum = tempFeatureMap[direction]
        if featureNum == nil and i < 5 and tempFeatureMap[(direction * 2) + 3] ~= nil and tempFeatureMap[(direction * 2) + 3] == tempFeatureMap[(direction * 2) + 4] then
           featureNum = tempFeatureMap[(direction * 2) + 3]
        end
        if featureNum ~= nil and tempJoinedFeature[featureNum] ~= nil then
            featureNum = tempJoinedFeature[featureNum]
        end

        if featureNum ~= nil and featureVisited[featureNum] ~= true then
            local featureFigures = joinedActiveFigures[featureNum]
            if featureFigures == nil then
                featureFigures = {}
                featureFigures.followers = {}
                featureFigures.specialFigures = {}
            end
            local featureScore, featureOpenings, nameOfFeature = AICalculateFeatureScore(featureNum, featureFigures)
            local spareFollowerAdjustment = (-7 * USED_FOLLOWER_PENALTY) + (spareFollowerCounts[activePlayers[currentPlayer]] * USED_FOLLOWER_PENALTY)
            local score

            if numRemainingMoves > spareFollowerCounts[activePlayers[currentPlayer]] and (featureOpenings > 0 or nameOfFeature == 'Field') then
                score = featureScore + moveScore + spareFollowerAdjustment
                if nameOfFeature ~= 'Field' and nameOfFeature ~= 'Cloister' then
                    score = score - featureOpenings * OPEN_FEATURE_PENALTY
                elseif nameOfFeature == 'Cloister' then
                    --TODO: I think cloister needs a slight penalty
                end
            else
                score = featureScore + moveScore
            end

            local usedFeature = false
            local playerHasFollower = false
            for _, follower in ipairs(featureFigures.followers) do
                if follower.getDescription() == activePlayers[currentPlayer] and (follower.getName() == translate({'Follower'}) or follower.getName() == translate({'Wagon'}) or follower.getName() == translate({'Abbot'}) or follower.getName() == translate({'Big Follower'}) or follower.getName() == translate({'Mayor'})) then
                    playerHasFollower = true
                end
            end
            if #featureFigures.followers == 0 and
                not (nameOfFeature == 'Road' and controlPanelSettings['BaseDisableRoads']) and
                not (nameOfFeature == 'City' and controlPanelSettings['BaseDisableCities']) and
                not (nameOfFeature == 'Cloister' and controlPanelSettings['BaseDisableCloisters']) and
                not (nameOfFeature == 'Field' and controlPanelSettings['BaseDisableFarms']) then
                if (baselineFollowerCounts[activePlayers[currentPlayer]] > 0 or baselineFigures[activePlayers[currentPlayer]][translate({'Big Follower'})]) and (numRemainingMoves <= spareFollowerCounts[activePlayers[currentPlayer]] or (featureScore + spareFollowerAdjustment > FOLLOWER_SCORE_THRESHOLD or featureOpenings == 0)) then
                    if score == highestScore then
                        --debugMessage(1, "found identical meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                        numIdenticalScore = numIdenticalScore + 1
                    end
                    if score > highestScore or (math.random(numIdenticalScore) == 1 and score == highestScore) then -- this is to lessen the bias towards one side of the play area
                        --debugMessage(1, "found new best meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                        --debugMessage(1, "moveScore:".. moveScore .. " spareFollowerAdjustment:" .. spareFollowerAdjustment .. " openFeaturePenalty:" .. featureOpenings * OPEN_FEATURE_PENALTY .. " featureScore:" .. featureScore)
                        if score > highestScore then
                            numIdenticalScore = 1
                        end
                        highestScore = score
                        highestScoreX = xIndex
                        highestScoreZ = zIndex
                        highestScoreRot = tileRotation
                        highestScorePos = i
                        if baselineFigures[activePlayers[currentPlayer]][translate({'Big Follower'})] and (baselineFollowerCounts[activePlayers[currentPlayer]] == 0 or nameOfFeature == 'City') then
                            highestScoreFigure = translate({'Big Follower'})
                        else
                            highestScoreFigure = translate({'Follower'})
                        end
                        usedFeature = true
                    end
                end
                if not usedFeature and nameOfFeature ~= 'Field' and nameOfFeature ~= 'Cloister' then
                    highestUnusedFeature = featureScore
                end
            elseif playerHasFollower and nameOfFeature == 'Field' and baselineFigures[activePlayers[currentPlayer]][translate({'Pig'})] then
                score = featureScore / 3
                if score == highestScore then
                    --debugMessage(1, "found identical pig score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                    numIdenticalScore = numIdenticalScore + 1
                end
                if score > highestScore or (math.random(numIdenticalScore) == 1 and score == highestScore) then -- this is to lessen the bias towards one side of the play area
                    --debugMessage(1, "found new best pig score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                    if score > highestScore then
                        numIdenticalScore = 1
                    end
                    highestScore = score
                    highestScoreX = xIndex
                    highestScoreZ = zIndex
                    highestScoreRot = tileRotation
                    highestScorePos = i
                    highestScoreFigure = translate({'Pig'})
                    usedFeature = true
                end
            elseif playerHasFollower and featureOpenings > 0 and (nameOfFeature == 'City' or nameOfFeature == 'Road') and baselineFigures[activePlayers[currentPlayer]][translate({'Builder'})] then
                if moveScore == highestScore then
                    --debugMessage(1, "found identical builder score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                    numIdenticalScore = numIdenticalScore + 1
                end
                if moveScore > highestScore or (math.random(numIdenticalScore) == 1 and moveScore == highestScore) then -- this is to lessen the bias towards one side of the play area
                    --debugMessage(1, "found new best builder score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. i)
                    if score > highestScore then
                        numIdenticalScore = 1
                    end
                    highestScore = score
                    highestScoreX = xIndex
                    highestScoreZ = zIndex
                    highestScoreRot = tileRotation
                    highestScorePos = i
                    highestScoreFigure = translate({'Builder'})
                    usedFeature = true
                end
            end
            featureVisited[featureNum] = true
        end
    end
    moveScore = moveScore - highestUnusedFeature * 0.02 -- meant to slightly disourage from building a feature for someone else to take
    if moveScore == highestScore then
        --debugMessage(1, "found identical tile score: " .. moveScore .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        numIdenticalScore = numIdenticalScore + 1
    end
    if moveScore > highestScore or (math.random(numIdenticalScore) == 1 and moveScore == highestScore) then -- this is to lessen the bias towards one side of the play area
        --debugMessage(1, "found new best tile score: " .. moveScore .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        if moveScore > highestScore then
            numIdenticalScore = 1
        end
        highestScore = moveScore
        highestScoreX = xIndex
        highestScoreZ = zIndex
        highestScoreRot = tileRotation
        highestScorePos = nil
        highestScoreFigure = nil
    end

    tileGrid[xIndex][zIndex] = nil
end

function AICalculateActiveScores(newXIndex, newZIndex)
    --debugMessage(2, "AI checking current active scores..")
    if os.clock() - lastFrameTime > FRAME_TIME then
        lastFrameTime = lastFrameTime + FRAME_TIME
        coroutine.yield(0)
    end
    activeScores = {}
    followerCountChange = {}
    for _, player in pairs(activePlayers) do
        local scoreCounter = getObjectFromGUID(score_counter_guids[player])
        if scoreCounter ~= nil then
            activeScores[player] = getObjectFromGUID(score_counter_guids[player]).Counter.getValue()
        else
            activeScores[player] = 0
        end
        followerCountChange[player] = 0
    end

    if newXIndex ~= nil and (controlPanelSettings['TnBTradeGoods'] or controlPanelSettings['TnBBuilder']) then
        local specialFeatures = {}
        local newTile = getObjectFromGUID(tileGrid[newXIndex][newZIndex].tile_guid)

        if newTile.getTable('sides')[1] ~= 'Abbey' then
            for featureNum, feature in pairs(tempFeatureList) do
                if feature.openings == 0 and feature.nameOfFeature == 'City' then
                    for _, specialFeature in ipairs(feature.specialFeatures) do
                        if table.contains(TRADE_GOOD_TYPES, specialFeature) then
                            table.insert(specialFeatures, specialFeature)
                        end
                    end
                end
                if joinedActiveFigures[featureNum] ~= nil and (feature.nameOfFeature == 'City' or feature.nameOfFeature == 'Road') then
                    for _, specialFigure in ipairs(joinedActiveFigures[featureNum].specialFigures) do
                        if specialFigure.getDescription() == activePlayers[currentPlayer] then --do not give give sheep/extra builder tile (CAR ref 149)
                            if specialFigure.getName() == translate({'Shepherd'}) then
                                --TODO: implement
                            elseif specialFigure.getName() == translate({'Builder'}) and not hasAlreadyTakenBuilderTile then
                                activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + 1
                            end
                        end
                    end
                end
            end
        else
            local visitedFeatures = {}
            for i=1, 12 do --roads and cities
                local newX, newZ, newTilePosition
                if i < 5 then
                    local direction = (3 + i + TILE_STANDARD_ROTATION) % 4 + 1
                    newX = newXIndex + SIDE_DELTA[direction].x
                    newZ = newZIndex + SIDE_DELTA[direction].z
                    newTilePosition = (3 + i + TILE_180_ROTATION) % 4 + 1
                else
                    local direction = (3 + i + (TILE_STANDARD_ROTATION * 2)) % 8 + 5
                    newX = newXIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                    newZ = newZIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                    newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction) % 8 + 5
                end
                if featureMap[newX] ~= nil and featureMap[newX][newZ] ~= nil then
                    local featureNum = featureMap[newX][newZ][newTilePosition]
                    if not table.contains(visitedFeatures, featureNum) then
                        local feature = tempFeatureList[featureNum]
                        if feature == nil then feature = featureList[featureNum] end
                        if feature.openings == 0 and feature.nameOfFeature == 'City' then
                            for _, specialFeature in ipairs(feature.specialFeatures) do
                                if table.contains(TRADE_GOOD_TYPES, specialFeature) then
                                    table.insert(specialFeatures, specialFeature)
                                end
                            end
                        end
                        table.insert(visitedFeatures, featureNum)
                    end
                end
            end
        end

        if controlPanelSettings['TnBTradeGoods'] then
            for _, specialFeature in ipairs(specialFeatures) do
                local highestNumTokens = 0
                local secondHighestTokens = 0
                local numRemainingTokens = TRADE_TOKEN_COUNTS[specialFeature]
                local tokenCounts = {}
                tokenCounts[activePlayers[currentPlayer]] = 0
                --find the highest count for this token
                for _, player in ipairs(activePlayers) do
                    local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                    local playerNumTokens = 0
                    for _, obj in ipairs(playerPossessions) do
                        if obj.getName() == specialFeature then
                            local quantity = obj.getQuantity()
                            if quantity == -1 then quantity = 1 end
                            if tokenCounts[player] == nil then
                                tokenCounts[player] = quantity
                            else
                                tokenCounts[player] = tokenCounts[player] + quantity
                            end
                            numRemainingTokens = numRemainingTokens - quantity
                        end
                    end
                    if tokenCounts[player] ~= nil and tokenCounts[player] >= highestNumTokens then
                        secondHighestTokens = highestNumTokens
                        highestNumTokens = tokenCounts[player]
                    end
                end
                --basically, tokens are only worth something if:
                --you are first place and second place has enough tokens to catch up
                --or you are not first place, but have enough tokens left to catch up
                if (tokenCounts[activePlayers[currentPlayer]] == highestNumTokens and highestNumTokens - secondHighestTokens <= numRemainingTokens) or
                (tokenCounts[activePlayers[currentPlayer]] ~= highestNumTokens and highestNumTokens - tokenCounts[activePlayers[currentPlayer]] <= numRemainingTokens) then
                    if #activePlayers > 1 then
                        activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + ((10 + (10 / (#activePlayers - 1))) / numRemainingTokens)
                    else
                        activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + 20
                    end
                end
            end
        end
    end
    for featureNum, featureFigures in pairs(joinedActiveFigures) do
        local score, featureOpenings, nameOfFeature = AICalculateFeatureScore(featureNum, featureFigures)
        local followerCounts = {}
        local hasHill = {}
        local hasMayor = {}
        local topWeight = -1
        --find the relative weights for the followers on this feature
        for _, follower in ipairs(featureFigures.followers) do
            if featureOpenings == 0 and nameOfFeature ~= 'Field' then
                followerCountChange[follower.getDescription()] = followerCountChange[follower.getDescription()] + 1
            end
            local weight = 0
            if follower.getName() == translate({'Follower'}) or follower.getName() == translate({'Wagon'}) or follower.getName() == translate({'Abbot'}) then weight = 1
            elseif follower.getName() == translate({'Big Follower'}) then weight = 2
            elseif follower.getName() == translate({'Mayor'}) then
                for _, specialFeature in ipairs(traversedSpecialFeatures) do
                    if specialFeature == 'Coat of Arms' then weight = weight + 1 end
                end
                hasMayor[follower.getDescription()] = true
            end
            if weight > 0 then
                local followerXIndex = math.floor((follower.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local followerZIndex = math.floor((follower.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                local specialFeatures = getObjectFromGUID(tileGrid[followerXIndex][followerZIndex].tile_guid).getTable('specialFeatures')
                if controlPanelSettings['HnSHills'] and specialFeatures ~= nil then
                    for _, specialFeature in ipairs(specialFeatures) do
                        if specialFeature[1] == "Hill" then
                            --although it would have been easier to just add 0.001 to the weight here, it would have technically violated the rules, since multiple hills are not supposed to give extra weight.
                            hasHill[follower.getDescription()] = true
                        end
                    end
                end
            end
            if followerCounts[follower.getDescription()] == nil then
                followerCounts[follower.getDescription()] = weight
            else
                followerCounts[follower.getDescription()] = followerCounts[follower.getDescription()] + weight
            end
        end
        --add hill weight if there is a hill, find top weight for the feature
        for player, value in pairs(followerCounts) do
            if hasHill[player] then
                --if the follower is on a hill, add a small value to it to break any ties
                followerCounts[player] = followerCounts[player] + 0.001
            end
            if followerCounts[player] > topWeight then topWeight = followerCounts[player] end
        end
            -- local closestFollower = fairyClosestFollower()
            -- if closestFollower == follower then
            --     allGameMessage(closestFollower.getDescription() .. " " .. closestFollower.getName() .. " scores 3 points for being next to the fairy when scoring a feature.", player_color_tints[closestFollower.getDescription()])
            --     scorePoints(closestFollower.getDescription(), translate({'Fairy'}), 3)
            -- end
            -- if follower.getName() == "Wagon" then
            --     wagonLocations[follower.getDescription()] = {}
            --     wagonLocations[follower.getDescription()].x = follower.getPosition().x
            --     wagonLocations[follower.getDescription()].z = follower.getPosition().z
            --     hasAvailableWagonFeature[follower.getDescription()] = hasIncompleteSecondaryFeature
            -- end
            -- local winner = false
        for player, value in pairs(followerCounts) do
            if (topWeight > 0 and value >= topWeight) then
                activeScores[player] = activeScores[player] + score
            end
        end
    end
end

function AICalculateFeatureScore(featureNum, figures)
    --debugMessage(3, "AICalculateFeatureScore")
    local feature = tempFeatureList[featureNum]
    if feature == nil then feature = featureList[featureNum] end

    local nameOfFeature = feature.nameOfFeature
    local specialFeatures = feature.specialFeatures
    local featureOpenings = feature.openings
    local numTiles = feature.numTiles
    if nameOfFeature == 'River' or nameOfFeature == 'Carcassonne' then
        return -1000, featureOpenings, nameOfFeature
    end

    local tilesRemaining = 0
    if getObjectFromGUID(tileStack_GUID) ~= nil then
        tilesRemaining = getObjectFromGUID(tileStack_GUID).getQuantity()
    elseif finalTile_GUID ~= nil then
        tilesRemaining = 1
    end

    local featureComplete
    if featureOpenings == 0 then
        featureComplete = true
    else
        featureComplete = false
    end

    local hasPig = {}
    --local hasBarn = false
    --local hasNewBarn = false
    for _, figure in ipairs(figures.specialFigures) do
        if figure.getName() == translate({'Pig'}) then hasPig[figure.getDescription()] = true end
        -- if figure.getName() == translate({'Barn'}) then
        --     hasBarn = true
        --     if newBarn ~= nil and figure.getGUID() == newBarn then
        --         hasNewBarn = true
        --         newBarn = nil
        --     end
        --     --recalculate "follower count" with only barns. Technically they aren't followers but it was easier in code.
        --     if #traversedFollowers == 0 then
        --         if followerCounts[figure.getDescription()] == nil then
        --             followerCounts[figure.getDescription()] = 1
        --         else
        --             followerCounts[figure.getDescription()] = followerCounts[figure.getDescription()] + 1
        --         end
        --         if followerCounts[figure.getDescription()] > topWeight then topWeight = followerCounts[figure.getDescription()] end
        --     end
        -- end
    end
    local score = 0
    local containsPigHerd = false
    if nameOfFeature == 'City' and not controlPanelSettings['BaseDisableCities'] then
        score = numTiles
        local containsCathedral = false
        for _, feature in ipairs(specialFeatures) do
            if feature == 'Coat of Arms' then
                score = score + 1
            elseif table.contains(TRADE_GOOD_TYPES, feature) and featureOpenings > 0 then
                score = score + UNFINISHED_TRADE_TOKEN_VALUE
            end
            if feature == 'Cathedral' and controlPanelSettings['InCCathedrals'] then
                containsCathedral = true
            end
        end
        if containsCathedral then
            if featureComplete then
                --in order to get the AI to prioritize city pieces, we need to inflate the incomplete value to be partway between the complete value
                --however, this creates a lower score difference between a completed city and an incomplete one. In order to make sure that the AI still
                --tries to finish the city, we give it a small bonus (roughly equal to the complete score minus the incomplete score)
                local bonus = score * 3 - (score * 3 * tilesRemaining / END_GAME_TRANSITION)
                score = score * 3
                score = score + bonus
            else
                if tilesRemaining > END_GAME_TRANSITION then
                    score = score * 2.4
                else
                    if tilesRemaining / END_GAME_TRANSITION > 1 / (featureOpenings + 1) then
                        score = score * 3 * tilesRemaining / END_GAME_TRANSITION
                    else
                        score = score * 3 / (featureOpenings + 1)
                    end
                end
            end
        else
            if featureComplete then
                --in order to get the AI to prioritize city pieces, we need to inflate the incomplete value to be partway between the complete value
                --however, this creates a lower score difference between a completed city and an incomplete one. In order to make sure that the AI still
                --tries to finish the city, we give it a small bonus (roughly equal to the complete score minus the incomplete score)
                local bonus
                if tilesRemaining > END_GAME_TRANSITION then
                    bonus = score * 0.4
                else
                    bonus = score - (score * 0.6 * tilesRemaining / END_GAME_TRANSITION)
                end
                score = score * 2
                score = score + bonus
            else
                if tilesRemaining > END_GAME_TRANSITION then
                    score = score * 1.6
                else
                    score = score + score * 0.6 * tilesRemaining / END_GAME_TRANSITION
                end
            end
        end
        --do not nerf cities that were completed by an abbey, or incomplete cities
        if lastPlacedTileX ~= nil and getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).getTable('sides')[1] ~= 'Abbey' and
           featureComplete and controlPanelSettings['BaseNerfSmallCity'] and score == 4 then score = 2 end
    elseif nameOfFeature == 'Field' and not controlPanelSettings['BaseDisableFarms'] then
        local numCities = 0

        local linkedCities = tempLinkedFeatures['City-Field'][featureNum]
        if linkedCities == nil then linkedCities = linkedFeatures['City-Field'][featureNum] end
        if linkedCities ~= nil then
            for connectedFeatureNum, _ in pairs(linkedCities) do
                local openings
                if tempFeatureList[connectedFeatureNum] ~= nil then
                    openings = tempFeatureList[connectedFeatureNum].openings
                else
                    openings = featureList[connectedFeatureNum].openings
                end
                if openings == 0 then
                    numCities = numCities + 1
                end
            end
        end
        for _, feature in ipairs(specialFeatures) do
            -- if feature == 'Completed City' then
            --     numCities = numCities + 1
            -- end
            if feature == 'Pig-herd' and not controlPanelSettings['RIIDisablePigherd'] then
                containsPigHerd = true
            end
        end
        featureComplete = false --so that this feature won't be scored before the end of the game
        local scoreMultiplier = 3
        -- if hasBarn then
        --     if #traversedFollowers > 0 then
        --         if not hasNewBarn then
        --             scoreMultiplier = 1
        --         end
        --     else
        --         scoreMultiplier = 4
        --     end
        -- end
        if hasPig[player] ~= nil then
            scoreMultiplier = scoreMultiplier + 1
        end
        if containsPigHerd and #figures.followers > 0 then -- CAR pg 67 ref 194
            scoreMultiplier = scoreMultiplier + 1
        end
        if tilesRemaining > END_GAME_TRANSITION * 2.0 then
            scoreMultiplier = scoreMultiplier - 2.0
        else
            scoreMultiplier = scoreMultiplier - (tilesRemaining / END_GAME_TRANSITION)
        end
        score = (numCities * scoreMultiplier)
        if tilesRemaining > END_GAME_TRANSITION then
            score = score - FIELD_PENALTY
        end
    elseif nameOfFeature == 'Road' and not controlPanelSettings['BaseDisableRoads'] then
        score = numTiles
        local containsInn = false
        for _, feature in ipairs(specialFeatures) do
            if feature == 'Inn' and controlPanelSettings['InCInns'] then
                containsInn = true
            end
        end
        if containsInn then
            if featureComplete then
                score = score * 2
            else
                if tilesRemaining > END_GAME_TRANSITION then
                    score = score * 2
                else
                    if tilesRemaining / END_GAME_TRANSITION > 1 / (featureOpenings + 1) then
                        score = score * 2 * tilesRemaining / END_GAME_TRANSITION
                    else
                        score = score * 2 / (featureOpenings + 1)
                    end
                end
            end
        end
    elseif table.contains(CLOISTER_FEATURES, nameOfFeature) and not controlPanelSettings['BaseDisableCloisters'] then
        score = 1
        for x=-1, 1 do
            for z=-1, 1 do
                if not (x == 0 and z == 0) and tileGridOccupied(feature.featureLocation.x + x, feature.featureLocation.z + z) then
                    score = score + 1
                    if controlPanelSettings['HnSVineyards'] then
                        local specialFeatures = getObjectFromGUID(tileGrid[feature.featureLocation.x + x][feature.featureLocation.z + z].tile_guid).getTable('specialFeatures')
                        if specialFeatures ~= nil then
                            for _, feature in ipairs(specialFeatures) do
                                if feature == 'Vineyard' then
                                    if featureComplete then
                                        score = score + 3
                                    else
                                        if tilesRemaining > END_GAME_TRANSITION then
                                            score = score + 3
                                        else
                                            if tilesRemaining / END_GAME_TRANSITION > 1 / featureOpenings then
                                                score = score + 3 * tilesRemaining / END_GAME_TRANSITION
                                            else
                                                score = score + 3 / featureOpenings
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        featureOpenings = 9 - score
        -- if featureComplete then
        --     local challengerTile, challengedTile
        --     if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
        --         challengerTile = 'Cloister'
        --         challengedTile = 'Shrine'
        --     else
        --         challengerTile = 'Shrine'
        --         challengedTile = 'Cloister'
        --     end
        --     for x=-1, 1 do
        --         for z=-1, 1 do
        --             if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
        --                 local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
        --                 if specialFeatures ~= nil then
        --                     for i, feature in ipairs(specialFeatures) do
        --                         local adjacentFeature = feature[1]
        --                         if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
        --                         if adjacentFeature == challengedTile then
        --                             local numTiles = 0
        --                             for nested_x=-1, 1 do
        --                                 for nested_z=-1, 1 do
        --                                     if tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
        --                                         numTiles = numTiles + 1
        --                                     end
        --                                 end
        --                             end
        --                             if numTiles ~= 9 then
        --                                 local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
        --                                 for _, object in ipairs(objs) do
        --                                     if table.contains(FOLLOWER_TYPES, object.getName()) then
        --                                         local objectXIndex = math.floor((object.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        --                                         local objectZIndex = math.floor((object.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        --                                         if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
        --                                             local xPosition = (object.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
        --                                             local zPosition = (object.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
        --                                             xPosition = xPosition - objectXIndex
        --                                             zPosition = zPosition - objectZIndex
        --                                             local closestFeature = findClosestFeature(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), rotation)
        --                                             if closestFeature == i + 12 then
        --                                                 object.setLock(false)
        --                                                 object.use_gravity = false
        --                                                 object.interactable = false
        --                                                 --raise the follower in the air
        --                                                 object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)
        --                                                 table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        --                                                 allGameMessage(object.getDescription() .. " " .. object.getName() .. " has lost the Cloister/Shrine challenge.", player_color_tints[object.getDescription()])
        --                                             end
        --                                         end
        --                                     end
        --                                 end
        --                             end
        --                         end
        --                     end
        --                 end
        --             end
        --         end
        --     end
        -- end
    end
    return score, featureOpenings, nameOfFeature
end

HAND_SCALE_CONSTANT = 1.3 -- for some reason, a hand with {1,1,1} scale is not 1 unit wide in each dimension, but instead around 1.2.
-- Move a card from the specified player's hand to the position smoothly
-- This works by first setting the position directly in front of the hand to prevent rubber-banding, then immediately moving to the intended position
function setPositionFromHandSmooth(obj, player_color, position)
  local handTransform = Player[player_color].getHandTransform()
  local tempPosition = obj.getPosition()
  tempPosition.x = tempPosition.x + (handTransform.scale.z * HAND_SCALE_CONSTANT / 2 + obj.getBoundsNormalized().size.z / 2) * handTransform.forward.x
  tempPosition.z = tempPosition.z + (handTransform.scale.z * HAND_SCALE_CONSTANT / 2 + obj.getBoundsNormalized().size.z / 2) * handTransform.forward.z
  obj.setRotation({obj.getRotation().x, handTransform.rotation.y, obj.getRotation().z})
  obj.setPosition(tempPosition)
  obj.setPositionSmooth(position)
end

--temporary function to get around the bug of not being able to setPosition from a hand
function dealInFrontOfHand(obj, player_color, is_a_deck)
  local handTransform = Player[player_color].getHandTransform()
  local tempPosition = handTransform.position
  tempPosition.y = tempPosition.y - 1
  tempPosition.x = tempPosition.x + (handTransform.scale.z * HAND_SCALE_CONSTANT / 2 + obj.getBoundsNormalized().size.z / 2) * handTransform.forward.x
  tempPosition.z = tempPosition.z + (handTransform.scale.z * HAND_SCALE_CONSTANT / 2 + obj.getBoundsNormalized().size.z / 2) * handTransform.forward.z
  if is_a_deck then
    local params = {}
    params.position = tempPosition
    params.rotation = {obj.getRotation().x, handTransform.rotation.y, obj.getRotation().z}
    return obj.takeObject(params)
  else
    obj.setPositionSmooth(tempPosition)
    obj.setRotationSmooth({obj.getRotation().x, handTransform.rotation.y, obj.getRotation().z})
  end
end

function AIMoveTileToLocation(newTile, xIndex, zIndex, tileRotation)
    if os.clock() - calculationStart < AI_DRAW_TILE_TIME then -- wait a minimum of this many seconds to make it flow nicer
        wait(AI_DRAW_TILE_TIME - (os.clock() - calculationStart))
    end

    --if the newest tile is at the edge of the play area, then shift it if there is room
    --https://stackoverflow.com/a/1252776
    local next = next
    if xIndex == MIN_X and (tileGrid[MAX_X] == nil or next(tileGrid[MAX_X]) == nil) then
        shiftPlayArea(1, 0)
        xIndex = xIndex + 1
    end
    if xIndex == MAX_X and (tileGrid[MIN_X] == nil or next(tileGrid[MIN_X]) == nil) then
        shiftPlayArea(-1, 0)
        xIndex = xIndex - 1
    end
    if zIndex == MIN_Z and (tileGrid[MAX_Z] == nil or next(tileGrid[MAX_Z]) == nil) then
        shiftPlayArea(0, 1)
        zIndex = zIndex + 1
    end
    if zIndex == MAX_Z and (tileGrid[MIN_Z] == nil or next(tileGrid[MIN_Z]) == nil) then
        shiftPlayArea(0, -1)
        zIndex = zIndex - 1
    end
    if tileGrid[xIndex] == nil then tileGrid[xIndex] = {} end
    tileGrid[xIndex][zIndex] = {}
    tileGrid[xIndex][zIndex].tile_guid = newTile.getGUID()
    tileGrid[xIndex][zIndex].rotation = tileRotation
    if newTile.getGUID() == finalTile_GUID then
        finalTile_GUID = nil
    end
    if newTile.getGUID() == forkTile_GUID then
        forkTile_GUID = nil
    end
    if newTile.getGUID() == springTile_GUID then
        springTile_GUID = nil
    end
    if newTile.getGUID() == lakeTile_GUID then
        lakeTile_GUID = nil
    end
    lastPlacedTileX = xIndex
    lastPlacedTileZ = zIndex

    addTile(xIndex, zIndex, newTile, tileRotation, false)
    if startingTile_GUID == nil and newTile.getVar('isStartingPiece') then
        startingTile_GUID = newTile.getGUID()
    end
    if startingRiverTile_GUID == nil and newTile.getVar('isStartingPiece') then
        startingRiverTile_GUID = newTile.getGUID()
    end

    if AI_ANIMATIONS_ENABLED then
        setPositionFromHandSmooth(newTile, activePlayers[currentPlayer], {xIndex * TILE_SPACING - MIDDLE_OFFSET.x, TABLE_SURFACE_Y, zIndex * TILE_SPACING - MIDDLE_OFFSET.z})
        newTile.setRotationSmooth({0, tileRotation * 90, 0})
    else
        newTile.setPosition({xIndex * TILE_SPACING - MIDDLE_OFFSET.x, TABLE_SURFACE_Y, zIndex * TILE_SPACING - MIDDLE_OFFSET.z})
        newTile.setRotation({0, tileRotation * 90, 0})
    end

    coroutine.yield(0) -- wait one frame before setting interactable to false due to a rubber-banding bug
    newTile.interactable = false

    if AI_ANIMATIONS_ENABLED then
        Timer.create({identifier=newTile.getGUID() .. os.clock(), function_name='AILockTile', function_owner=nil, parameters={tile=newTile}, delay=2.0})
    else
        AILockTile({tile=newTile})
    end
end

function AILockTile(params)
    local tile = params.tile
    tile.interactable = true
    if AUTOLOCK then
        tile.setLock(true)
    end
    return nextState('tile placed')
end

function AIMoveFigureToLocation()
    local tile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    local nameOfFeature = getFeatureName(tile, highestScorePos)
    local x, z = getFeatureLocation(highestScorePos, tile, tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation)
    for _, obj in ipairs(getAllObjects()) do
        if highestScoreFigure == obj.getName() and obj.getDescription() == activePlayers[currentPlayer] then
            local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            if tileGrid[xIndex] == nil or tileGrid[xIndex][zIndex] == nil then
                local pieceRotation = 0
                if highestScorePos < 5 then pieceRotation = (highestScorePos - 1) * 90
                elseif highestScorePos < 13 then pieceRotation = math.floor((highestScorePos - 5) / 2) * 90 end
                if (obj.getName() == translate({'Follower'}) or obj.getName() == translate({'Big Follower'})) and nameOfFeature == 'Field' then
                    --lay the Follower down
                    if AI_ANIMATIONS_ENABLED then
                        obj.setRotationSmooth({tile.getRotation().x + 90, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                    else
                        obj.setRotation({tile.getRotation().x + 90, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                    end
                else
                    --align with the tile
                    if AI_ANIMATIONS_ENABLED then
                        obj.setRotationSmooth({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                    else
                        obj.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                    end
                end
                obj.interactable = false
                if AI_ANIMATIONS_ENABLED then
                    obj.setPositionSmooth({(x * TILE_SPACING) + (lastPlacedTileX * TILE_SPACING) - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (lastPlacedTileZ * TILE_SPACING) - MIDDLE_OFFSET.z})
                    Timer.create({identifier=obj.getGUID() .. os.clock(), function_name='AILockFigure', function_owner=nil, parameters={figure=obj}, delay=2.0})
                else
                    obj.setPosition({(x * TILE_SPACING) + (lastPlacedTileX * TILE_SPACING) - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (lastPlacedTileZ * TILE_SPACING) - MIDDLE_OFFSET.z})
                    Timer.create({identifier=obj.getGUID() .. os.clock(), function_name='AILockFigure', function_owner=nil, parameters={figure=obj}, delay=0.5})
                end
                break
            end
        end
    end
end

function AILockFigure(params)
    local figure = params.figure
    figure.interactable = true
    if AUTOLOCK then
        figure.setLock(true)
    end
    return nextState('placed figure')
end
