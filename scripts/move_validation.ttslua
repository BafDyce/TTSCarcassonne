--these functions check if the move being made is valid. This is also used by hint_markers to show legal moves

function checkFigure(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID ~= nil and getObjectFromGUID(lastDroppedObject_GUID) ~= nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
        if newFigure.held_by_color == nil then
            if not (lastPlacedTileX == nil or lastPlacedTileZ == nil) then
                local xIndex = math.floor((newFigure.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((newFigure.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                if newFigure.getVar('figureName') == 'Fairy' then
                    if tileGridOccupied(xIndex, zIndex) then
                        local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                        for _, follower in ipairs(objs) do
                            if follower.getVar('owner') == activePlayers[currentPlayer] and table.contains(FOLLOWER_TYPES, follower.getVar('figureName')) then
                                if xIndex == math.floor((follower.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
                                 zIndex == math.floor((follower.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
                                    if AUTOLOCK then
                                       newFigure.setLock(true)
                                    end
                                    return nextState('placed fairy')
                                end
                            end
                        end
                    end
                    allErrorMessage({"MESSAGE_INVALID_LOCATION_FAIRY"}, activePlayers[currentPlayer])
                    return
                end
                local tile, tileRotation
                if tileGridOccupied(xIndex, zIndex) then
                    tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    tileRotation = tileGrid[xIndex][zIndex].rotation
                else
                    --allErrorMessage("Invalid Location: Figure was not placed on a tile", activePlayers[currentPlayer])
                    return
                end
                local xPosition = (newFigure.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (newFigure.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                xPosition = xPosition - xIndex
                zPosition = zPosition - zIndex
                --debugMessage(3, "piece position: x: " .. xPosition .. " z: " .. zPosition)
                local closestPosition = findClosestPosition(xPosition, zPosition, tile, tileRotation, true)
                local direction
                if closestPosition < 5 then
                    direction = (3 + closestPosition + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
                elseif closestPosition < 13 then
                    direction = (3 + closestPosition + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                else
                    direction = closestPosition
                end
                local featureNum = featureMap[xIndex][zIndex][direction]
                if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(direction * 2) + 3] ~= nil and featureMap[xIndex][zIndex][(direction * 2) + 3] == featureMap[xIndex][zIndex][(direction * 2) + 4] then
                   featureNum = featureMap[xIndex][zIndex][(direction * 2) + 3]
                end
                if featureNum == nil then
                    allErrorMessage({"MESSAGE_INVALID_LOCATION_MIDDLE"}, activePlayers[currentPlayer])
                    return
                end
                local nameOfFeature = featureList[featureNum].nameOfFeature
                getActiveFigures()
                if isValidFigureLocation(newFigure, xIndex, zIndex, closestPosition, featureNum, true, true) then
                    if string.sub(nameOfFeature,1,6) == 'Flier-' then
                        flier = newFigure.getGUID()
                        if string.sub(nameOfFeature,7,7) == 'W' then flierDirection = 8 else flierDirection = 1 end --assumed to be Flier-NW if it is not Flier-W
                        flierDirection = flierDirection + ((tileRotation - TILE_STANDARD_ROTATION) * 2)
                        if flierDirection > 8 then flierDirection = flierDirection - 8 end
                        if flierDirection < 1 then flierDirection = flierDirection + 8 end
                        allGameMessage({"MESSAGE_FLIER_PLACED", {'{c1}', newFigure.getDescription()}, {'{f1}', newFigure.getName()}}, player_color_tints[newFigure.getVar('owner')])
                        hasAlreadyUsedFlier = true
                        return nextState('placed flier')
                    end
                    if AUTOLOCK then
                        newFigure.setLock(true)
                    end
                    if newFigure.getVar('figureName') == 'Tower' then
                        numberActiveTowers = 0
                        towerX = xIndex
                        towerZ = zIndex
                        for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
                            if obj.getVar('figureName') == 'Tower' then
                                local nestedXIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                local nestedZIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                if xIndex == nestedXIndex and zIndex == nestedZIndex then
                                    local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                                    local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                                    xPosition = xPosition - xIndex
                                    zPosition = zPosition - zIndex
                                    local nestedclosestPosition = findClosestPosition(xPosition, zPosition, tile, tileRotation, true)
                                    if closestPosition == nestedclosestPosition then
                                        numberActiveTowers = numberActiveTowers + 1
                                    end
                                end
                            end
                        end
                        if numberActiveTowers == 1 then
                            allGameMessage(({"MESSAGE_TOWER_PLACED"}), player_color_tints[activePlayers[currentPlayer]])
                        else
                            allGameMessage(({"MESSAGE_TOWER_INCREASED"}), player_color_tints[activePlayers[currentPlayer]])
                        end
                        return nextState('placed tower')
                    end
                    if nameOfFeature == 'Tower Foundation' then
                        nameOfFeature = 'a tower'
                    end
                    allGameMessage({"MESSAGE_FIGURE_PLACED", {'{c1}', newFigure.getDescription()}, {'{f1}', newFigure.getName()}, {'{s2}', translate({nameOfFeature})}}, player_color_tints[newFigure.getVar('owner')])
                    if table.contains(CLOISTER_FEATURES, nameOfFeature) then
                        local challengerTile, challengedTile
                        if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                            challengerTile = 'Cloister'
                            challengedTile = 'Shrine'
                        else
                            challengerTile = 'Shrine'
                            challengedTile = 'Cloister'
                        end
                        for x=-1, 1 do
                            for z=-1, 1 do
                                if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                    local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
                                    if specialFeatures ~= nil then
                                        for i, feature in ipairs(specialFeatures) do
                                            local adjacentFeature = feature[1]
                                            if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                            if adjacentFeature == challengedTile then
                                                local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                for _, object in ipairs(objs) do
                                                    if table.contains(FOLLOWER_TYPES, object.getVar('figureName')) then
                                                        local objectXIndex = math.floor((object.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                                        local objectZIndex = math.floor((object.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                                        if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                            local xPosition = (object.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                                                            local zPosition = (object.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                                                            xPosition = xPosition - objectXIndex
                                                            zPosition = zPosition - objectZIndex
                                                            local closestPosition = findClosestPosition(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), tileRotation, true)
                                                            if closestPosition == i + 12 then
                                                                allGameMessage({"MESSAGE_SHRINE_CHALLENGED", {'{c1}', object.getDescription()}, {'{f1}', object.getName()}, {'{s2}', translate({feature[1]})}}, player_color_tints[object.getVar('owner')])
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    local pieceRotation = 0
                    if closestPosition < 5 then pieceRotation = (closestPosition - 1) * 90
                    elseif closestPosition < 13 then pieceRotation = math.floor((closestPosition - 5) / 2) * 90 end
                    if table.contains(MEEPLE_TYPES, newFigure.getVar('figureName')) and nameOfFeature == 'Field' then
                        --lay the Follower down
                        if closestPosition < 13 then
                            newFigure.setRotation({tile.getRotation().x + 90, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        else
                            newFigure.setRotation({tile.getRotation().x + 90, newFigure.getRotation().y + pieceRotation, tile.getRotation().z})
                        end
                    else
                        --align with the tile
                        if closestPosition < 13 then
                            newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        else
                            newFigure.setRotation({tile.getRotation().x, newFigure.getRotation().y + pieceRotation, tile.getRotation().z})
                        end
                    end
                    if newFigure.getVar('figureName') == 'Barn' then
                        newBarn = newFigure.getGUID()
                    end
                    if newFigure.getVar('figureName') == 'Shepherd' then
                        shepherdAwaitingAction = newFigure.getGUID()
                        return nextState('placed shepherd')
                    else
                        if not (xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ) then
                            hasAlreadyUsedMagicPortal = true
                        end
                        return nextState('placed figure')
                    end
                end
            else
                allErrorMessage({"MESSAGE_FIGURE_PLACED_BEFORE_TILE"}, activePlayers[currentPlayer])
            end
        else
            allErrorMessage({"MESSAGE_FIGURE_PICKED_UP"}, activePlayers[currentPlayer])
        end
    end
end

--checks if this position is on a corner or 4 tiles containing nothing but fields
--assumes that the given feature has already been checked and is a field
--returns true if it is, false otherwise
function checkBarn(closestPosition, xIndex, zIndex)
    tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
    tileRotation = tileGrid[xIndex][zIndex].rotation
    --NOTE: the following equation gives the other feature location on the same corner: ((closestPosition % 2) * -2) + 1 - 5) % 8 + 5
    if closestPosition > 12 or closestPosition < 5 then return false end
    local valid = false
    local includesLastTile = false
    if xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ then includesLastTile = true end
    local links = tile.getTable('linkedOctants')
    if links == nil then return false end
    for _, link in ipairs(links) do
        --check if both sides of the corner are linked together
        if table.contains(link, closestPosition) and table.contains(link, (closestPosition + ((closestPosition % 2) * -2) + 1 - 5) % 8 + 5) then
            -- go over both neighboring tiles
            for i, position in ipairs({closestPosition, (closestPosition + ((closestPosition % 2) * -2) + 1 - 5) % 8 + 5}) do
                local newTileDirection = (3 + position + (tileRotation * 2)) % 8 + 5
                local newX = xIndex + SIDE_DELTA[math.floor((newTileDirection - 3) / 2)].x
                local newZ = zIndex + SIDE_DELTA[math.floor((newTileDirection - 3) / 2)].z
                if newX == lastPlacedTileX and newZ == lastPlacedTileZ then includesLastTile = true end
                if not tileGridOccupied(newX, newZ) then return false end
                local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                local newTileRotation = tileGrid[newX][newZ].rotation
                local newTilePosition = (((newTileDirection % 2) * 2) + TILE_180_ROTATION + newTileDirection - (newTileRotation * 2) - 4) % 8 + 5
                if getFeatureName(newTile, newTilePosition) ~= 'Field' then return false end
                links = newTile.getTable('linkedOctants')
                if links == nil then return false end
                for _, link in ipairs(links) do
                    if table.contains(link, newTilePosition) and table.contains(link, (newTilePosition + ((newTilePosition % 2) * -2) + 1 - 5) % 8 + 5) then
                        local lastTileDirection = (3 + ((newTilePosition + ((newTilePosition % 2) * -2) + 1 - 5) % 8 + 5) + (newTileRotation * 2)) % 8 + 5
                        local lastX = newX + SIDE_DELTA[math.floor((lastTileDirection - 3) / 2)].x
                        local lastZ = newZ + SIDE_DELTA[math.floor((lastTileDirection - 3) / 2)].z
                        if lastX == lastPlacedTileX and lastZ == lastPlacedTileZ then includesLastTile = true end
                        if tileGrid[lastX] == nil or tileGrid[lastX][lastZ] == nil then return false end
                        local lastTile = getObjectFromGUID(tileGrid[lastX][lastZ].tile_guid)
                        local lastTileRotation = tileGrid[lastX][lastZ].rotation
                        local lastTilePosition = (((lastTileDirection % 2) * 2) + TILE_180_ROTATION + lastTileDirection - (lastTileRotation * 2) - 4) % 8 + 5
                        if getFeatureName(lastTile, lastTilePosition) ~= 'Field' then return false end
                        --only need to check the links once
                        if i == 2 then
                            --check if both sides of the corner are linked together
                            links = lastTile.getTable('linkedOctants')
                            if links == nil then return false end
                            for _, link in ipairs(links) do
                                if table.contains(link, lastTilePosition) and table.contains(link, (lastTilePosition + ((lastTilePosition % 2) * -2) + 1 - 5) % 8 + 5) then
                                    --if it managed to get to this point, then all conditions have been met
                                    valid = true
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if not includesLastTile then
        valid = false
    end
    return valid
end

function checkWagon(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID ~= nil and getObjectFromGUID(lastDroppedObject_GUID) ~= nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
        if newFigure.getVar('figureName') ~= 'Wagon' then
            allErrorMessage({"MESSAGE_WAGON_ILLEGAL_FIGURE"}, activePlayers[currentMiniTurn])
            return
        end
        if newFigure.held_by_color == nil then
            if currentMiniTurn ~= nil then
                local xIndex = math.floor((newFigure.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((newFigure.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                local xPosition = (newFigure.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (newFigure.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local tileRotation = tileGrid[xIndex][zIndex].rotation
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    --debugMessage(1, "wagon position: x: " .. xPosition .. " z: " .. zPosition)

                    local closestPosition = findClosestPosition(xPosition, zPosition, tile, tileRotation, false)
                    local featureNum = featureMap[xIndex][zIndex][closestPosition]

                    if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(closestPosition * 2) + 3] ~= nil then
                        if featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'Road' and featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'River' then
                            featureNum = featureMap[xIndex][zIndex][(closestPosition * 2) + 3]
                        end
                    end
                    if featureNum ~= nil and isValidWagonLocation(newFigure, featureNum, true) then
                        if AUTOLOCK then
                            newFigure.setLock(true)
                        end
                        local nameOfFeature = featureList[featureNum].nameOfFeature
                        clearArbitraryButtons()
                        allGameMessage({"MESSAGE_FIGURE_PLACED", {'{c1}', newFigure.getDescription()}, {'{f1}', newFigure.getName()}, {'{s2}', translate({nameOfFeature})}}, player_color_tints[newFigure.getVar('owner')])
                        local pieceRotation = 0
                        if closestPosition < 5 then pieceRotation = (closestPosition - 1) * 90
                        elseif closestPosition < 13 then pieceRotation = math.floor((closestPosition - 5) / 2) * 90 end
                        newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        wagonFeatures[activePlayers[currentMiniTurn]] = nil
                        return nextState('placed figure')
                    end
                else
                    --allErrorMessage("Invalid Location: Figure was not placed on a tile", activePlayers[currentPlayer])
                end
            end
        else
            allErrorMessage({"MESSAGE_FIGURE_PICKED_UP"}, activePlayers[currentMiniTurn])
        end
    end
end

function checkFlier(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID ~= nil and getObjectFromGUID(lastDroppedObject_GUID) ~= nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        if flier == lastDroppedObject_GUID then
            local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
            if newFigure.held_by_color == nil then
                local xIndex = math.floor((newFigure.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((newFigure.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)

                local tile, tileRotation
                if tileGridOccupied(xIndex, zIndex) then
                    tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    tileRotation = tileGrid[xIndex][zIndex].rotation
                else
                    --allErrorMessage("Invalid Location: Figure was not placed on a tile", activePlayers[currentPlayer])
                    return
                end

                if (xIndex == lastPlacedTileX + flierOffset.x and zIndex == lastPlacedTileZ + flierOffset.z) then
                    local xPosition = (newFigure.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local zPosition = (newFigure.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    --debugMessage(3, "piece position: x: " .. xPosition .. " z: " .. zPosition)
                    local closestPosition = findClosestPosition(xPosition, zPosition, tile, tileRotation, true)
                    local nameOfFeature = getFeatureName(tile, closestPosition)
                    local featureOpenings
                    if closestPosition < 5 then
                        if nameOfFeature == 'Road' then
                            --only using traversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                            featureOpenings = getFeatureComponents(xIndex, zIndex, closestPosition, 1, true)
                        else
                            --check to make sure both octants in this quadrant are linked, then choose one arbitrary octant and check
                            local links = tile.getTable('linkedOctants')
                            local hasLink = false
                            for _, link in ipairs(links) do
                                if not hasLink and table.contains(link, (closestPosition * 2) + 3) and table.contains(link, (closestPosition * 2) + 4) then
                                    --only using traversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                                    featureOpenings = getFeatureComponents(xIndex, zIndex, (closestPosition * 2) + 3, 1, true)
                                    hasLink = true
                                end
                            end
                            if not hasLink then
                                allErrorMessage({"MESSAGE_INVALID_LOCATION_FLIER_MIDDLE"}, activePlayers[currentPlayer])
                                return
                            end
                        end
                    else
                        --only using traversal level of 1, since we only need to know about the direct feature we're trying to place the figure on
                        featureOpenings = getFeatureComponents(xIndex, zIndex, closestPosition, 1, true)
                    end
                    if isValidFlierLocation(newFigure, xIndex, zIndex, closestPosition, nameOfFeature, featureOpenings, true) then
                        if AUTOLOCK then
                            newFigure.setLock(true)
                        end
                        allGameMessage({"MESSAGE_FIGURE_PLACED", {'{c1}', newFigure.getDescription()}, {'{f1}', newFigure.getName()}, {'{s2}', translate({nameOfFeature})}}, player_color_tints[newFigure.getVar('owner')])
                        if table.contains(CLOISTER_FEATURES, nameOfFeature) then
                            local challengerTile, challengedTile
                            if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                                challengerTile = 'Cloister'
                                challengedTile = 'Shrine'
                            else
                                challengerTile = 'Shrine'
                                challengedTile = 'Cloister'
                            end
                            for x=-1, 1 do
                                for z=-1, 1 do
                                    if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                        local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
                                        if specialFeatures ~= nil then
                                            for i, feature in ipairs(specialFeatures) do
                                                local adjacentFeature = feature[1]
                                                if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                if adjacentFeature == challengedTile then
                                                    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                    for _, object in ipairs(objs) do
                                                        if table.contains(FOLLOWER_TYPES, object.getVar('figureName')) then
                                                            local objectXIndex = math.floor((object.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                                            local objectZIndex = math.floor((object.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                                            if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                                local xPosition = (object.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                                                                local zPosition = (object.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                                                                xPosition = xPosition - objectXIndex
                                                                zPosition = zPosition - objectZIndex
                                                                local closestPosition = findClosestPosition(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), tileRotation, true)
                                                                if closestPosition == i + 12 then
                                                                    allGameMessage({"MESSAGE_SHRINE_CHALLENGED", {'{c1}', object.getDescription()}, {'{f1}', object.getName()}, {'{s2}', translate({feature[1]})}}, player_color_tints[object.getVar('owner')])
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        local pieceRotation = 0
                        if closestPosition < 5 then pieceRotation = (closestPosition - 1) * 90
                        elseif closestPosition < 13 then pieceRotation = math.floor((closestPosition - 5) / 2) * 90 end
                        --align with the tile
                        newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                        return nextState('placed flier')
                    end
                else
                    allErrorMessage({"MESSAGE_INVALID_LOCATION_FLIER_WRONG_TILE"}, activePlayers[currentPlayer])
                end
            else
                allErrorMessage({"MESSAGE_FIGURE_PICKED_UP"}, activePlayers[currentPlayer])
            end
        else
            allErrorMessage({"MESSAGE_FLIER_WRONG_FIGURE"}, activePlayers[currentPlayer])
        end
    end
end

function checkPhantom(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID ~= nil and getObjectFromGUID(lastDroppedObject_GUID) ~= nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
        if newFigure.getVar('figureName') ~= 'Phantom' then
            allErrorMessage({"Error: You are only allowed to place the phantom at this time."}, activePlayers[currentPlayer])
            return
        end
        return checkFigure(params)
    end
end

function checkToCoC(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID ~= nil then --makes sure object still exists
        local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
        if newFigure.held_by_color == nil then
            local xIndex = math.floor((newFigure.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((newFigure.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            local tile, tileRotation
            if tileGridOccupied(xIndex, zIndex) then
                tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                tileRotation = tileGrid[xIndex][zIndex].rotation
            else
                return
            end
            local xPosition = (newFigure.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
            local zPosition = (newFigure.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
            xPosition = xPosition - xIndex
            zPosition = zPosition - zIndex
            local closestPosition = findClosestPosition(xPosition, zPosition, tile, tileRotation, true)
            local direction
            if closestPosition < 5 then
                direction = (3 + closestPosition + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
            elseif closestPosition < 13 then
                direction = (3 + closestPosition + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
            else
                direction = closestPosition
            end
            local featureNum = featureMap[xIndex][zIndex][direction]
            if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(direction * 2) + 3] ~= nil and featureMap[xIndex][zIndex][(direction * 2) + 3] == featureMap[xIndex][zIndex][(direction * 2) + 4] then
               featureNum = featureMap[xIndex][zIndex][(direction * 2) + 3]
            end
            if featureNum ~= nil and isValidCoCLocation(newFigure, xIndex, zIndex, closestPosition, featureNum, true, true) then
                if AUTOLOCK then
                    newFigure.setLock(true)
                end
                local nameOfFeature = featureList[featureNum].nameOfFeature
                if newFigure.getVar('figureName') == 'Count' then
                    allGameMessage({"MESSAGE_COUNT_PLACED", {'{f1}', newFigure.getName()}, {'{s2}', translate({nameOfFeature})}}, newFigure.getColorTint())
                else
                    allGameMessage({"MESSAGE_FIGURE_PLACED", {'{c1}', newFigure.getDescription()}, {'{f1}', newFigure.getName()}, {'{s2}', translate({nameOfFeature})}}, player_color_tints[newFigure.getVar('owner')])
                end
                local pieceRotation = 0
                if closestPosition < 5 then pieceRotation = (closestPosition - 1) * 90
                elseif closestPosition < 13 then pieceRotation = math.floor((closestPosition - 5) / 2) * 90 end
                --align with the tile
                newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                return nextState('placed figure')
            end
        else
            allErrorMessage({"MESSAGE_FIGURE_PICKED_UP"}, activePlayers[currentPlayer])
        end
    end
end

function checkFromCoC(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID ~= nil then --makes sure object still exists
        local newFigure = getObjectFromGUID(lastDroppedObject_GUID)
        if newFigure.held_by_color == nil then
            local xIndex = math.floor((newFigure.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((newFigure.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            local tile, tileRotation
            if tileGridOccupied(xIndex, zIndex) then
                tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                tileRotation = tileGrid[xIndex][zIndex].rotation
            else
                return
            end
            local xPosition = (newFigure.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
            local zPosition = (newFigure.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
            xPosition = xPosition - xIndex
            zPosition = zPosition - zIndex
            local closestPosition = findClosestPosition(xPosition, zPosition, tile, tileRotation, true)
            local direction
            if closestPosition < 5 then
                direction = (3 + closestPosition + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
            elseif closestPosition < 13 then
                direction = (3 + closestPosition + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
            else
                direction = closestPosition
            end
            local featureNum = featureMap[xIndex][zIndex][direction]
            if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(direction * 2) + 3] ~= nil and featureMap[xIndex][zIndex][(direction * 2) + 3] == featureMap[xIndex][zIndex][(direction * 2) + 4] then
               featureNum = featureMap[xIndex][zIndex][(direction * 2) + 3]
            end
            if featureNum ~= nil and isValidLocationFromCoC(newFigure, featureNum, true, true) then
                if AUTOLOCK then
                    newFigure.setLock(true)
                end
                local nameOfFeature = featureList[featureNum].nameOfFeature
                allGameMessage({"MESSAGE_FIGURE_PLACED", {'{c1}', newFigure.getDescription()}, {'{f1}', newFigure.getName()}, {'{s2}', translate({nameOfFeature})}}, player_color_tints[newFigure.getVar('owner')])
                local pieceRotation = 0
                if closestPosition < 5 then pieceRotation = (closestPosition - 1) * 90
                elseif closestPosition < 13 then pieceRotation = math.floor((closestPosition - 5) / 2) * 90 end
                if table.contains(MEEPLE_TYPES, newFigure.getVar('figureName')) and nameOfFeature == 'Field' then
                    --lay the Follower down
                    newFigure.setRotation({tile.getRotation().x + 90, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                else
                    --align with the tile
                    newFigure.setRotation({tile.getRotation().x, tile.getRotation().y + pieceRotation, tile.getRotation().z})
                end
                carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] = nil
                newFigure.highlightOff()
                for follower_guid, quarter in pairs(carcassonneFigures[activePlayers[currentMiniTurn]]) do
                    getObjectFromGUID(follower_guid).highlightOff()
                    getObjectFromGUID(follower_guid).setLock(true)
                end
                if gameover then
                    currentMiniTurn = currentMiniTurn + 1
                end
                return nextState('placed figure')
            end
        else
            allErrorMessage({"MESSAGE_FIGURE_PICKED_UP"}, activePlayers[currentPlayer])
        end
    end
end

--ensure this tile is valid for this location
function checkTile(params)
    if params.time ~= lastDroppedTime then return end
    dropLock = false
    if lastDroppedObject_GUID ~= nil then --makes sure object still exists
        --for some reason it is possible to get into a state where the lastDroppedObject is never resting. it therefore will go into an infinite loop waiting for this state
        --if lastDroppedObject.resting then
        local newTile = getObjectFromGUID(lastDroppedObject_GUID)
        if newTile ~= nil and newTile.held_by_color == nil then
            if newTile.getTable('sides') == nil then
                allErrorMessage({"MESSAGE_ERROR_NO_SCRIPT_DATA"})
                return
            end
            local xPosition = (newTile.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
            local zPosition = (newTile.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
            local yRotation = newTile.getRotation().y / 90
            --debugMessage(3, "piece rotation: " .. yRotation .. " piece position: x: " .. xPosition .. " z: " .. zPosition)
            if isWithinErrorMargin(xPosition, math.floor(xPosition + TILE_PLACEMENT_MARGIN * TILE_SPACING), TILE_PLACEMENT_MARGIN * TILE_SPACING) and
            isWithinErrorMargin(zPosition, math.floor(zPosition + TILE_PLACEMENT_MARGIN * TILE_SPACING), TILE_PLACEMENT_MARGIN * TILE_SPACING) and
            isWithinErrorMargin(yRotation, math.floor(yRotation + TILE_PLACEMENT_MARGIN), TILE_PLACEMENT_MARGIN) and
            (isWithinErrorMargin(0, newTile.getRotation().x, TILE_PLACEMENT_MARGIN * 90) or
            isWithinErrorMargin(360, newTile.getRotation().x, TILE_PLACEMENT_MARGIN * 90)) and
            (isWithinErrorMargin(0, newTile.getRotation().z, TILE_PLACEMENT_MARGIN * 90) or
            isWithinErrorMargin(360, newTile.getRotation().z, TILE_PLACEMENT_MARGIN * 90)) then
                local xIndex = math.floor(xPosition + TILE_PLACEMENT_MARGIN * TILE_SPACING)
                local zIndex = math.floor(zPosition + TILE_PLACEMENT_MARGIN * TILE_SPACING)
                --by adding 0.5, getting the floor will round to the nearest whole number
                local tileRotation = math.floor(yRotation + 0.5)
                if tileRotation == 0 then tileRotation = 4 end
                --debugMessage(2, "piece rotation: " .. tileRotation .. " piece indexes: x: " .. xIndex .. " z: " .. zIndex)
                if isValidTileLocation(newTile, tileRotation, xIndex, zIndex, true) then
                    newTile.setPosition({xIndex * TILE_SPACING - MIDDLE_OFFSET.x, TABLE_SURFACE_Y, zIndex * TILE_SPACING - MIDDLE_OFFSET.z})
                    newTile.setRotation({0, tileRotation * 90, 0})

                    if AUTOLOCK then
                        newTile.setLock(true)
                    end
                    addTile(xIndex, zIndex, newTile, tileRotation, false)
                    return nextState('tile placed')
                end
            else
                allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_NOT_ALIGNED"}, activePlayers[currentPlayer])
            end
        else
            allErrorMessage({"MESSAGE_TILE_PICKED_UP"}, activePlayers[currentPlayer])
        end
    end
end

function isValidTileLocation(tile, tileRotation, xIndex, zIndex, verbose)
    local isStartingPiece = tile.getVar('isStartingPiece')
    if not tileGridOccupied(xIndex, zIndex) then
        if (startingTile_GUID == nil and isStartingPiece) or
        tileGridOccupied(xIndex + 1, zIndex) or tileGridOccupied(xIndex - 1, zIndex) or
        tileGridOccupied(xIndex, zIndex + 1) or tileGridOccupied(xIndex, zIndex - 1) then
            if (xIndex >= MIN_X and xIndex <= MAX_X and zIndex >= MIN_Z and zIndex <= MAX_Z) then
                if ((not tileGridOccupied(xIndex + 1, zIndex) or tileConnectsToSide(tile, tileRotation, 4, getObjectFromGUID(tileGrid[xIndex + 1][zIndex].tile_guid), tileGrid[xIndex + 1][zIndex].rotation)) and
                (not tileGridOccupied(xIndex - 1, zIndex) or tileConnectsToSide(tile, tileRotation, 2, getObjectFromGUID(tileGrid[xIndex - 1][zIndex].tile_guid), tileGrid[xIndex - 1][zIndex].rotation)) and
                (not tileGridOccupied(xIndex, zIndex + 1) or tileConnectsToSide(tile, tileRotation, 3, getObjectFromGUID(tileGrid[xIndex][zIndex + 1].tile_guid), tileGrid[xIndex][zIndex + 1].rotation)) and
                (not tileGridOccupied(xIndex, zIndex - 1) or tileConnectsToSide(tile, tileRotation, 1, getObjectFromGUID(tileGrid[xIndex][zIndex - 1].tile_guid), tileGrid[xIndex][zIndex - 1].rotation))) then
                    if tile.getTable('sides')[1] == 'Abbey' and
                    ((not tileGridOccupied(xIndex + 1, zIndex)) or (not tileGridOccupied(xIndex - 1, zIndex)) or (not tileGridOccupied(xIndex, zIndex + 1)) or (not tileGridOccupied(xIndex, zIndex - 1))) then
                        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_ABBEY"}, activePlayers[currentPlayer]) end
                        return false
                    end
                    if controlPanelSettings['CultTiles'] then
                        local challengerTile = nil
                        local challengedTile = nil
                        local specialFeatures = tile.getTable('specialFeatures')
                        if specialFeatures ~= nil then
                            for _, feature in ipairs(specialFeatures) do
                                if feature[1] == 'Cloister' or feature[1] == 'Shrine' then challengerTile = feature[1] end
                                if feature[1] == 'Abbey' then challengerTile = 'Cloister' end
                            end
                        end
                        if challengerTile ~= nil then
                            if challengerTile == 'Cloister' then
                                challengedTile = 'Shrine'
                            else
                                challengedTile = 'Cloister'
                            end
                            local numChallenger = 1
                            local numChallenged = 0
                            for x=-1, 1 do
                                for z=-1, 1 do
                                    if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                        local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
                                        if specialFeatures ~= nil then
                                            for _, feature in ipairs(specialFeatures) do
                                                local adjacentFeature = feature[1]
                                                if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                if adjacentFeature == challengedTile then
                                                    numChallenged = numChallenged + 1
                                                    for nested_x=-1, 1 do
                                                        for nested_z=-1, 1 do
                                                            if not (nested_x == 0 and nested_z == 0) and tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
                                                                local nestedSpecialFeatures = getObjectFromGUID(tileGrid[xIndex + x + nested_x][zIndex + z + nested_z].tile_guid).getTable('specialFeatures')
                                                                if nestedSpecialFeatures ~= nil then
                                                                    for _, nestedFeature in ipairs(nestedSpecialFeatures) do
                                                                        local nestedAdjacentFeature = nestedFeature[1]
                                                                        if nestedAdjacentFeature == 'Abbey' then nestedAdjacentFeature = 'Cloister' end
                                                                        if nestedAdjacentFeature == challengerTile then
                                                                            numChallenger = numChallenger + 1
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            if numChallenged > 1 or numChallenger > 1 then
                                if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_SHRINE_CLOISTER"}, activePlayers[currentPlayer]) end
                                return false
                            end
                        end
                    end
                    --validate river piece
                    if isStartingPiece then
                        local hasRiver = false
                        local riverHasConnection = false
                        for i=1, 4 do
                            if tile.getTable('sides')[(3 + i - tileRotation) % 4 + 1] == 'River' then
                                hasRiver = true
                                local diff = 0
                                local x = xIndex
                                local z = zIndex
                                if i > 2 then diff = 1 else diff = -1 end
                                if i % 2 == 0 then x = x + diff else z = z + diff end
                                --if it has a river, then the following must be true for at least one of the sides
                                if tileGridOccupied(x, z) and tileConnectsToSide(tile, tileRotation, i, getObjectFromGUID(tileGrid[x][z].tile_guid), tileGrid[x][z].rotation) then
                                    riverHasConnection = true
                                    --the following checks to see if this tile would create a "U-turn" such that the river folds back on itself
                                    --this is illegal and can easily lead to issues
                                    --Though technically illegal, it is possible to still make a river that folds back on itself.
                                    --TODO: In the future, consider checking n number of tiles in the direction of the new rivers direction (with a width of 3 tiles) to see if there are any pieces in the way
                                    if ((tile.getTable('sides')[(3 + i + 1 - tileRotation) % 4 + 1] == 'River' and getObjectFromGUID(tileGrid[x][z].tile_guid).getTable('sides')[(3 + i + 1 - tileGrid[x][z].rotation) % 4 + 1] == 'River') or
                                    (tile.getTable('sides')[(3 + i + 3 - tileRotation) % 4 + 1] == 'River' and getObjectFromGUID(tileGrid[x][z].tile_guid).getTable('sides')[(3 + i + 3 - tileGrid[x][z].rotation) % 4 + 1] == 'River')) then
                                        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_RIVER_U_TURN"}, activePlayers[currentPlayer]) end
                                        return false
                                    end
                                end
                            end
                        end
                        if hasRiver and startingRiverTile_GUID ~= nil and hasOpenRiver() and not riverHasConnection then
                            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_RIVER"}, activePlayers[currentPlayer]) end
                            return false
                        end
                    end
                    return true
                else
                    if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_FEATURES_DONT_MATCH"}, activePlayers[currentPlayer]) end
                end
            else
                if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_OUT_OF_BOUNDS"}, activePlayers[currentPlayer]) end
            end
        else
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_NOT_ADJACENT"}, activePlayers[currentPlayer]) end
        end
    else
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TILE_LOCATION_TAKEN"}, activePlayers[currentPlayer]) end
    end
    return false
end

function isValidFigureLocation(newFigure, xIndex, zIndex, position, featureNum, newFigureInTranversal, verbose)
    local nameOfFeature = featureList[featureNum].nameOfFeature
    local featureOpenings = featureList[featureNum].openings
    if not (
        (xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ) or
        (tileHasMagicPortal and not hasAlreadyUsedMagicPortal and table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName'))) or
        newFigure.getVar('figureName') == 'Barn' or nameOfFeature == 'Tower Foundation' or string.sub(nameOfFeature,1,6) == 'Crown-'
        ) then
        if tileHasMagicPortal and hasAlreadyUsedMagicPortal and table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName')) then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_MAGIC_PORTAL_USAGE_EXCEEDED"}, activePlayers[currentPlayer]) end
            return
        else
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FIGURE_WRONG_TILE"}, activePlayers[currentPlayer]) end
            return
        end
    end
    local dragon = getObjectFromGUID(dragon_GUID)
    if controlPanelSettings['PnDDragon'] and dragon ~= nil and newFigure.getVar('figureName') ~= 'Barn' and (table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, newFigure.getVar('figureName'))) then
        if xIndex == math.floor((dragon.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
           zIndex == math.floor((dragon.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FIGURE_ON_DRAGON"}, activePlayers[currentPlayer]) end
            return false
        end
    end
    if nameOfFeature == 'River' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FIGURE_ON_RIVER"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Carcassonne' or string.sub(nameOfFeature,1,8) == 'Quarter-' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_NOT_ALLOWED"}, activePlayers[currentPlayer]) end
        return false
    end
    if string.sub(nameOfFeature,1,6) == 'Flier-' then
        if controlPanelSettings['FlierFlier'] then
            if hasAlreadyUsedFlier then
                if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FLIER_USAGE_EXCEEDED"}, activePlayers[currentPlayer]) end
                return false
            elseif table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName')) then
                return true
            else
                if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FLIER_ILLEGAL_FIGURE"}, activePlayers[currentPlayer]) end
                return false
            end
        else
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FLIER_DISABLED"}, activePlayers[currentPlayer]) end
            return false
        end
    end
    if nameOfFeature == 'Tower Foundation' then
        if not table.contains(MEEPLE_TYPES, newFigure.getVar('figureName')) and newFigure.getVar('figureName') ~= 'Tower' then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TOWER_ILLEGAL_FIGURE"}, activePlayers[currentPlayer]) end
            return false
        else
            local hasTower = false
            for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
                local nestedXIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local nestedZIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                if xIndex == nestedXIndex and zIndex == nestedZIndex then
                    local tile, rotation
                    if tileGridOccupied(xIndex, zIndex) then
                        tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                        rotation = tileGrid[xIndex][zIndex].rotation
                    else
                        allErrorMessage("ERROR: Something went very wrong.", activePlayers[currentPlayer])
                        return false
                    end
                    local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    local closestPosition = findClosestPosition(xPosition, zPosition, tile, rotation, true)
                    if closestPosition == position and obj.getGUID() ~= newFigure.getGUID() then
                        if table.contains(MEEPLE_TYPES, obj.getVar('figureName')) then
                            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TOWER_ALREADY_OCCUPIED"}, activePlayers[currentPlayer]) end
                            return false
                        elseif obj.getVar('figureName') == 'Tower' then
                            hasTower = true
                        elseif tostring(obj) == 'Card(Clone) (LuaGameObjectScript)' then
                            --it's the tile, we can ignore it
                        elseif obj.getVar('figureName') ~= GOLD_BAR_NAME then
                            if verbose then allErrorMessage("ERROR: There is an illegal piece in this tower location: " .. obj.getName(), activePlayers[currentPlayer]) end
                            return false
                        end
                    end
                end
            end
            if table.contains(MEEPLE_TYPES, newFigure.getVar('figureName')) and not hasTower then
                if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_TOWER_FIGURE_BEFORE_TOWER"}, activePlayers[currentPlayer]) end
                return false
            end
            return true
        end
    end
    if string.sub(nameOfFeature,1,6) == 'Crown-' and not table.contains(MEEPLE_TYPES, newFigure.getVar('figureName')) then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_WHEEL_CROWN"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Shepherd' and nameOfFeature ~= 'Field' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_SHEPHERD"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Abbot' and not (nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey') then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_ABBOT"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') ~= 'Abbot' and nameOfFeature == 'Garden' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_GARDEN"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Builder' and nameOfFeature ~= 'Road' and nameOfFeature ~= 'City' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_BUILDER"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Pig' and nameOfFeature ~= 'Field' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_PIG"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Mayor' and nameOfFeature ~= 'City' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_MAYOR"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Wagon' and nameOfFeature == 'Field' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_WAGON"}, activePlayers[currentPlayer]) end
        return false
    end
    if (nameOfFeature == 'Road' and controlPanelSettings['BaseDisableRoads']) or
        (nameOfFeature == 'City' and controlPanelSettings['BaseDisableCities']) or
        (nameOfFeature == 'Cloister' and controlPanelSettings['BaseDisableCloisters']) or
        (nameOfFeature == 'Field' and newFigure.getVar('figureName') ~= 'Shepherd' and controlPanelSettings['BaseDisableFarms']) then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FEATURE_DISABLED", {'{s1}', translate({nameOfFeature})}}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Barn' then
        if nameOfFeature ~= 'Field' or not checkBarn(position, xIndex, zIndex) then
            if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_BARN"}, activePlayers[currentPlayer]) end
            return false
        end
    end
    if featureOpenings == 0 and not (xIndex == lastPlacedTileX and zIndex == lastPlacedTileZ) and not string.sub(nameOfFeature,1,6) == 'Crown-' and newFigure.getVar('figureName') ~= 'Barn' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_MAGIC_PORTAL"}, activePlayers[currentPlayer]) end
        return false
    end

    local numFollowers = 0
    local numCurrentPlayerFollowers = 0
    local numShepherds = 0
    local numBarns = 0

    if activeFigures[featureNum] ~= nil then
        for _, obj in ipairs(activeFigures[featureNum].followers) do
            if obj ~= newFigure then
                if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) then
                    numFollowers = numFollowers + 1
                    if obj.getVar('owner') == activePlayers[currentPlayer] then
                        numCurrentPlayerFollowers = numCurrentPlayerFollowers + 1
                    end
                end
            end
        end
        for _, obj in ipairs(activeFigures[featureNum].specialFigures) do
            if obj ~= newFigure then
                if obj.getVar('figureName') == 'Shepherd' then
                    numShepherds = numShepherds + 1
                elseif obj.getVar('figureName') == 'Barn' then
                    numBarns = numBarns + 1
                end
            end
        end
    end
    if newFigure.getVar('figureName') == 'Builder' and numCurrentPlayerFollowers == 0 then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_BUILDER_NO_PARENT"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Pig' and numCurrentPlayerFollowers == 0 then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_PIG_NO_PARENT"}, activePlayers[currentPlayer]) end
        return false
    end
    if (table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName')) and numFollowers == 0 and numBarns == 0) or
        (newFigure.getVar('figureName') == 'Shepherd' and numShepherds == 0) or
        (newFigure.getVar('figureName') == 'Barn' and numBarns == 0) or
         newFigure.getVar('figureName') == 'Builder' or newFigure.getVar('figureName') == 'Pig' then
        return true
    else
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FEATURE_ALREADY_OCCUPIED"}, activePlayers[currentPlayer]) end
    end
    return false
end

function isValidWagonLocation(newFigure, featureNum, verbose)
    local nameOfFeature = featureList[featureNum].nameOfFeature
    local featureOpenings = featureList[featureNum].openings
    if nameOfFeature == 'River' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FIGURE_ON_RIVER"}, activePlayers[currentMiniTurn]) end
        return false
    end
    if nameOfFeature == 'Carcassonne' or string.sub(nameOfFeature,1,8) == 'Quarter-' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_NOT_ALLOWED"}, activePlayers[currentMiniTurn]) end
        return false
    end
    if nameOfFeature == 'Field' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_WAGON"}, activePlayers[currentMiniTurn]) end
        return false
    end
    if nameOfFeature == 'Road' and controlPanelSettings['BaseDisableRoads'] then
        if verbose then allErrorMessage({"Invalid Location: Roads are disabled via the house rules."}, activePlayers[currentMiniTurn]) end
        return false
    end
    if nameOfFeature == 'City' and controlPanelSettings['BaseDisableCities'] then
        if verbose then allErrorMessage({"Invalid Location: Cities are disabled via the house rules."}, activePlayers[currentMiniTurn]) end
        return false
    end
    if nameOfFeature == 'Cloister' and controlPanelSettings['BaseDisableCloisters'] then
        if verbose then allErrorMessage({"Invalid Location: Cloisters are disabled via the house rules."}, activePlayers[currentMiniTurn]) end
        return false
    end

    local wagonFeatureNum = wagonFeatures[activePlayers[currentMiniTurn]]
    if linkedFeatures['Road Intersection'][wagonFeatureNum] == nil or linkedFeatures['Road Intersection'][wagonFeatureNum][featureNum] ~= true then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_WAGON_NOT_CONNECTED"}, activePlayers[currentMiniTurn]) end
        return false
    end

    if featureOpenings > 0 then
        for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
            if obj ~= newFigure and table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) then
                local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                    local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local rotation = tileGrid[xIndex][zIndex].rotation
                    local closestPosition = findClosestPosition(xPosition, zPosition, tile, rotation, false)
                    local followerFeatureNum = featureMap[xIndex][zIndex][closestPosition]

                    if followerFeatureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(closestPosition * 2) + 3] ~= nil then
                        if featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'Road' and featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'River' then
                            followerFeatureNum = featureMap[xIndex][zIndex][(closestPosition * 2) + 3]
                        end
                    end

                    if followerFeatureNum == featureNum then
                        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FEATURE_ALREADY_OCCUPIED"}, activePlayers[currentMiniTurn]) end
                        return false
                    end
                end
            end
        end
        return true
    end
    if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_WAGON_ALREADY_COMPLETE"}, activePlayers[currentMiniTurn]) end
    return false
end

function isValidFlierLocation(newFigure, xIndex, zIndex, position, nameOfFeature, featureOpenings, verbose)
    if newFigure.getVar('figureName') == 'Abbot' and nameOfFeature ~= 'Garden' and nameOfFeature ~= 'Cloister' and nameOfFeature ~= 'Abbey' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_ABBOT"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Mayor' and nameOfFeature ~= 'City' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_MAYOR"}, activePlayers[currentPlayer]) end
        return
    end
    if nameOfFeature ~= 'City' and nameOfFeature ~= 'Road' and nameOfFeature ~= 'Cloister' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FLIER"}, activePlayers[currentPlayer]) end
        return
    end
    if featureOpenings == 0 then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_FLIER_ALREADY_COMPLETE"}, activePlayers[currentPlayer]) end
        return false
    end
    return true
end

function isValidCoCLocation(newFigure, xIndex, zIndex, position, featureNum, newFigureInTranversal, verbose)
    local nameOfFeature = featureList[featureNum].nameOfFeature

    if not (table.contains(FOLLOWER_TYPES, newFigure.getVar('figureName')) or newFigure.getVar('figureName') == 'Count') then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_ILLEGAL_FIGURE"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Carcassonne' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_NOT_A_QUARTER"}, activePlayers[currentPlayer]) end
        return false
    end
    if string.sub(nameOfFeature,1,8) ~= 'Quarter-' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Abbot' and nameOfFeature ~= 'Quarter-Cathedral' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_ABBOT"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Mayor' and nameOfFeature ~= 'Quarter-Castle' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_MAYOR"}, activePlayers[currentPlayer]) end
        return false
    end
    if newFigure.getVar('figureName') == 'Wagon' and nameOfFeature == 'Quarter-Market' then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_WAGON"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Quarter-Blacksmith' and controlPanelSettings['BaseDisableRoads'] then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_ROADS_DISABLED"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Quarter-Castle' and controlPanelSettings['BaseDisableCities'] then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_CITIES_DISABLED"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Quarter-Market' and controlPanelSettings['BaseDisableFields'] then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_FIELDS_DISABLED"}, activePlayers[currentPlayer]) end
        return false
    end
    if nameOfFeature == 'Quarter-Cathedral' and controlPanelSettings['BaseDisableCloisters'] then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_CLOISTERS_DISABLED"}, activePlayers[currentPlayer]) end
        return false
    end
    return true
end

function isValidLocationFromCoC(newFigure, featureNum, newFigureInTranversal, verbose)
    local nameOfFeature = featureList[featureNum].nameOfFeature
    local openings = featureList[featureNum].openings
    if carcassonneFigures[newFigure.getVar('owner')] == nil or carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == nil then
        if verbose then allErrorMessage({"MESSAGE_COC_FROM_CITY_ILLEGAL_FIGURE"}, activePlayers[currentMiniTurn]) end
        return false
    end

    local validFeature
    if carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == 'Blacksmith' then
        validFeature = 'Road'
    elseif carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == 'Castle' then
        validFeature = 'City'
    elseif carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == 'Cathedral' then
        validFeature = 'Cloister'
    elseif carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] == 'Market' then
        validFeature = 'Field'
    else
        if verbose then allErrorMessage("Error: Unrecognized feature: " .. carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] .. " Please tell the dev.", activePlayers[currentMiniTurn]) end
        return false
    end

    if nameOfFeature == 'Abbey' or nameOfFeature == 'Shrine' then
        nameOfFeature = 'Cloister'
    end

    if nameOfFeature ~= validFeature then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_FROM_WRONG_QUARTER", {'{f1}', carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()]}, {'{s1}', validFeature}}, activePlayers[currentMiniTurn]) end
        return false
    end

    if openings ~= 0 and carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] ~= 'Market' and not gameover then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_COMPLETED_ONLY"}, activePlayers[currentMiniTurn]) end
        return false
    end
    if openings == 0 and carcassonneFigures[newFigure.getVar('owner')][newFigure.getGUID()] ~= 'Market' and gameover then
        if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_INCOMPLETE_END_GAME_ONLY"}, activePlayers[currentMiniTurn]) end
        return false
    end

    if gameover then return true end

    local tile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    local tileRotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation

    if tile.getTable('sides')[1] ~= 'Abbey' then
        local positionsToVisit = {}

        local specialFeatures = tile.getTable('specialFeatures')
        if specialFeatures ~= nil then
            for i, feature in ipairs(specialFeatures) do
                if feature[3] ~= nil and feature[1] ~= 'Tower Foundation' then
                    table.insert(positionsToVisit, i+12)
                end
            end
        end
        for i=1, 12 do
            table.insert(positionsToVisit, i)
        end
        for _, i in ipairs(positionsToVisit) do
            local direction
            if i < 5 then
                direction = (3 + i + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
            elseif i < 13 then
                direction = (3 + i + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
            else
                direction = i
            end
            local nestedFeatureNum = featureMap[lastPlacedTileX][lastPlacedTileZ][direction]
            if nestedFeatureNum == nil and i < 5 and featureMap[lastPlacedTileX][lastPlacedTileZ][(direction * 2) + 3] ~= nil and featureMap[lastPlacedTileX][lastPlacedTileZ][(direction * 2) + 3] == featureMap[lastPlacedTileX][lastPlacedTileZ][(direction * 2) + 4] then
               nestedFeatureNum = featureMap[lastPlacedTileX][lastPlacedTileZ][(direction * 2) + 3]
            end
            if nameOfFeature == 'Field' and table.contains(barnFeatureNumbers, featureNum) then
                return true
            elseif nameOfFeature ~= 'Field' and featureNum == nestedFeatureNum then
                return true
            end
        end
    else --if an abbey was used, then we cannot simply traverse it's features like above in order to find completed features. instead, we traverse the surrounding features
        for i=1, 12 do
            if i < 5 and controlPanelSettings['KnRBRobber'] then
                local direction = (3 + i + tileRotation) % 4 + 1
                local newX = lastPlacedTileX + SIDE_DELTA[direction].x
                local newZ = lastPlacedTileZ + SIDE_DELTA[direction].z
                if tileGridOccupied(newX, newZ) then
                    local adjacentTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                    local adjacentTileRotation = tileGrid[newX][newZ].rotation
                    local adjacentTilePosition
                    if direction < 5 then
                        adjacentTilePosition = (3 + direction + adjacentTileRotation + TILE_STANDARD_ROTATION) % 4 + 1
                    elseif direction < 13 then
                        adjacentTilePosition = (3 + direction + ((adjacentTileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                    else
                        adjacentTilePosition = direction
                    end
                    local nestedFeatureNum = featureMap[newX][newZ][adjacentTilePosition]
                    if nestedFeatureNum == nil and direction < 5 and featureMap[newX][newZ][(adjacentTilePosition * 2) + 3] ~= nil and featureMap[newX][newZ][(adjacentTilePosition * 2) + 3] == featureMap[newX][newZ][(adjacentTilePosition * 2) + 4] then
                       nestedFeatureNum = featureMap[newX][newZ][(adjacentTilePosition * 2) + 3]
                    end
                    if nameOfFeature ~= 'Field' and featureNum == nestedFeatureNum then
                        return true
                    end
                end
            end
        end
    end

    if nameOfFeature == 'Cloister' then
        for _, offset in ipairs(DIAGONAL_DELTA) do
            local neighborX = lastPlacedTileX + offset.x
            local neighborZ = lastPlacedTileZ + offset.z
            if tileGridOccupied(neighborX, neighborZ) then
                for _, neighborFeatureNum in pairs(featureMap[neighborX][neighborZ]) do
                    if featureNum == neighborFeatureNum then
                        return true
                    end
                end
            end
        end
    end

    if verbose then allErrorMessage({"MESSAGE_INVALID_LOCATION_COC_LAST_TILE_ONLY"}, activePlayers[currentMiniTurn]) end
    return false
end
