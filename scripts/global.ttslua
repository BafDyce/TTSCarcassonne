-- Carcassonne and all expansions w/ automated scripting
-- Scripting by Sancho
-- The rules are based on the contents of Carcassonne Annotated Rules (CAR) v7.4.

--Tile Script Info
-- Each tile should have a script including variables needed to represent the information on the tile. The data format is as follows:
-- *In all examples, the "starting piece" is used*
-- *It should be noted that the "top" and "topleft" is from the perspective of the white player. All of the tiles are, in actuality, rotated by 180 degrees, which is taken into account in code with TILE_STANDARD_ROTATION
-- Data Format:
--  sides - table of strings ( ie. {'City', 'Road', 'Field', 'Road'} ) Specifies the feature on each side of the tile, starting from the "top" clockwise (top is arbitrary, but must be consistent amoung pieces)
--             features: 'City', 'Road', 'Field', 'River', 'Abbey'
--  (optional) linkedQuadrants - table of tables of ints ( ie. {{2, 4}} ) Each table specifies which features are linked together, starting from the "top" at 1 and increasing clockwise.
--             This only applies for features that take the middle of the side (ie. roads, rivers)
--             In the example, the right side is linked to the left side (the road)
--  (optional) linkedOctants - table of tables of ints ( ie. {{5, 6}, {7, 12}, {8, 9, 10, 11}} ) Each table specifies which half of each quadrant is linked to others, starting from the "topleft" at 5 and increasing clockwise.
--             This is necessary for fields and cities, in particular, since both halves of a quadrant aren't always linked to each other.
--             Also, this specifies how the fields on each half of a road feature are linked to other fields. Therefore, each road quadrant may also have 2 corresponding octants specified for that same side.
--             In the example, the topleft and topright octants are linked
--                             the righttop and lefttop octants are linked (This is the field on the top half of the road)
--                             the rightbottom, bottomright, bottomleft, and leftbottom octants are linked (this is the field on the bottom half of the road)
--  (optional) specialFeatures - table of tables containing a string (which specifies the feature), (optional) table of ints, and (optional) table of exactly 2 floats ( ie. {{'City-Field', {5, 6, 7, 12}, nil}} )
--             The table of ints specifies what quadrants or octants this feature is linked to (if any).
--             The table of floats specifies the relative x and z coordinates of the feature on this piece (if a figure can be placed on the feature).
--             features:
--                  Base features ('City', 'Road', 'Field', 'Abbey') - this allows for additional locations for specifying the base features.
--                       this is useful for defining additional snap points, as well as allowing features which aren't connected to any quadrant or octant (there are a few fields like this).
--                  'Cloister' = cloister - specifies the location of a cloister. Links are not used for this feature.
--                  'City-Field' = city-field link - if the cities specified are completed, they score points to the specified fields. Multiple different cities and fields specified
--                             are NOT linked to each other, only fields are linked to cities (and vice versa, in the case of using old rules (TODO: implement later?). Coordinates are not used for this feature.
--                  'Road Intersection' = links roads to each other or other features. This is used for wagons.
--                  Linked Features with no coordinates: 'Pennant', 'Inn', 'Cathedral', 'Princess'
--                  Unlinked Features of the tile: 'Volcano', 'Dragon', 'Hill'
--                  'Garden' - specifies the location of a garden. Links are not used for this feature.


DEBUG_BUTTONS = false
debugLevel = 0
--debugLogTabIndex = -1

AUTOLOCK = true

TILE_PLACEMENT_MARGIN = 0.30 --30%
TILE_SPACING = 1.59 --how far apart tiles are spaced (should be the same as the tile grid setting)
TILE_THICKNESS = 0.005 --about how much thicker each tile makes a stack when added (keep in mind this is probably not as thick as the tile actually is on its own)
TILE_STANDARD_ROTATION = 2 --every tile is rotated this much so that the perceived rotation of the tiles matches the actual rotation in the code
TILE_180_ROTATION = 2

SPAM_DELAY = 2 --amount of time after an error message before another will be printed

MAX_X = 33
MIN_X = 1
MAX_Z = 33
MIN_Z = 1
--HACK: TTS cannot save table variables with negative indexes. Adding this arbitrary value to offset the middle ensures that all grid positions are positive (unless another table is used)
--Note to self: if you change these values, you'll need to prevent tileGrid from loading and getting overwritten
MIDDLE_X_OFFSET = 17
MIDDLE_Z_OFFSET = 17
MIDDLE_OFFSET = {x = MIDDLE_X_OFFSET * TILE_SPACING, z = MIDDLE_Z_OFFSET * TILE_SPACING}
TABLE_SURFACE_Y = 1.03171348571777

SIDE_DELTA = {{x=0,z=-1},{x=-1,z=0},{x=0,z=1},{x=1,z=0}}
DIAGONAL_DELTA = {{x=-1,z=1},{x=0,z=1},{x=1,z=1},{x=1,z=0},{x=1,z=-1},{x=0,z=-1},{x=-1,z=-1},{x=-1,z=0}}

NEUTRAL_ITEMS_LOCATION = {x = 15.5, y = 1.5, z = 28.0}

--The following figure definitions were specified in the CAR (Carcassonne Annoted Rules).
--Although not all figures have the same properties, their relative similarities may simpify code
FOLLOWER_TYPES = {'Follower', 'Big Follower', 'Phantom', 'Abbot', 'Mayor', 'Wagon'}
SPECIAL_FIGURE_TYPES = {'Shepherd', 'Builder', 'Pig', 'Barn'}
NEUTRAL_FIGURE_TYPES = {'Count', 'Dragon', 'Fairy', 'Tower'}
PROXIMITY_FEATURES = {'Cloister', 'Abbey', 'Shrine', 'Garden', "Baba Yaga's Hut"} --features that change based on the actions of surrounding tiles
CLOISTER_FEATURES = {'Cloister', 'Abbey', 'Shrine'} --features that are essentially cloisters in many aspects of the rules
NUM_TOWERS_PER_PLAYER = {[1] = 10, [2] = 10, [3] = 9, [4] = 7, [5] = 6, [6] = 5}
TOWER_HEIGHT = 0.28 --How tall each Tower piece is
GOLD_BAR_NAME = 'Gold Bar'
SHEEP_TOKEN_TYPES = {'Sheep', 'Wolf'}
TRADE_TOKEN_TYPES = {'Wine Token', 'Wheat Token', 'Cloth Token'}
TRADE_TOKEN_COUNTS = {
    ['Wine'] = 9,
    ['Wheat'] = 6,
    ['Cloth'] = 5
}
TRADE_GOOD_TYPES = {'Wine', 'Wheat', 'Cloth'}

PLAYER_COLORS = {'Green', 'Purple', 'White', 'Blue', 'Red', 'Pink'}

arbitraryButtonAnchors = {}

FLOATING_BUTTON_HEIGHT = 2.0
FLOATING_BUTTON_HEIGHT_LOW = 1.0

FIGURE_DISTANCE_FROM_EDGE = 0.1 --percentage distance from the edge that each quadrant/octant exists

FIGURE_RETURN_DELAY = 0.5 --seconds to wait while returning a figure in order to prevent double-scoring
FIGURE_PRAISE_DELAY = 2.5 --seconds to wait while figure is spinning before it is returned
FIGURE_CAPTURE_DELAY = 2.0 --seconds to wait after capturing a figure before it is locked

FRAME_TIME = 0.01667 --time that coroutine can run before it should yield to the main thread. Approx 60FPS

PLAY_AREA_SCRIPTING_ZONE_GUID = '799064'
CONTROL_PANEL_GUID = '45460c'
BUTTON_ANCHOR_GUID = '07fd9a'
SOUNDBOARD_GUID = '9c8d01'
EXPANSION_TABLE_GUID = 'f01594'

CURRENT_PLAYER_MARKER = "âž¡ " -- symbol(s) that should be printed on the scoreboard before the current player

tileStack_GUID = '16d9db'
startingTile_GUID = 'c107f0'
startingRiverTile_GUID = nil
forkTile_GUID = nil
springTile_GUID = nil
lakeTile_GUID = nil
riverBodyTiles_GUID = nil
finalTile_GUID = nil

fairy_GUID = nil
dragon_GUID = nil
flierDie_GUID = nil

score_counter_guids = {
    ['Green'] = '28bdff',
    ['Pink'] = '7ef326',
    ['Purple'] = 'f206e4',
    ['Blue'] = '9d1e70',
    ['Red'] = '4e3519',
    ['White'] = '1ecf3f'
}

figurepad_GUIDs = {
    ['Green'] = 'cee9ef',
    ['Purple'] = '7b6639',
    ['White'] = 'b013fc',
    ['Blue'] = '37df2f',
    ['Red'] = '4a5985',
    ['Pink'] = '7ed1bb'
}

--The corresponding hand color for this player color (can use a custom color)
handColor = {
    ['Green'] = 'Green',
    ['Purple'] = 'Purple',
    ['White'] = 'White',
    ['Blue'] = 'Blue',
    ['Red'] = 'Red',
    ['Pink'] = 'Pink'
}

playerName = {}

player_color_tints = {}

figurePositions = {}

activeFigures = {}

player_possession_areas = {
    ['Green'] = {x=28.35, z=12.1, rotation=3},
    ['Purple'] = {x=28.35, z=-12.1, rotation=3},
    ['White'] = {x=12.1, z=-28.35, rotation=2},
    ['Blue'] = {x=-12.1, z=-28.35, rotation=2},
    ['Red'] = {x=-28.35, z=-12.1, rotation=1},
    ['Pink'] = {x=-28.35, z=12.1, rotation=1}
}
playerPossessionScriptingZones = {}

PLAYER_POSSESSION_ZONE_HEIGHT = 2.5
PLAYER_POSSESSION_ZONE_DEPTH = 3.9
PLAYER_POSSESSION_ZONE_WIDTH = 24.0
PLAYER_POSSESSION_POSITIONS =
{
    ['KnRBRobber'] = {x=8.4, z=0.5},
    ['KnRBKing'] = {x=10.4, z=0.5},
    ['Cloth'] = {x=5.9, z=1.0},
    ['Wine'] = {x=5.9, z=0.0},
    ['Wheat'] = {x=6.9, z=1.0},
    ['CapturedFollower'] = {x=10.9, z=-1.5},
    ['Gold'] = {x=10.9, z=-0.75}
}
PLAYER_POSSESSION_SPACING = 1.0 --spacing for multiple objects of the same type

-- Guid for object we will put button on
BUTTON_BOARD_GUID = '2b44bf'

showMarkers = 'Both'
showMarkersButtonParam = {
    index = 0, click_function = 'showMarkersToggleButton',
    position = {-0.8,0.1,0.0}, width = 750, height=600, font_size = 150, function_owner = nil
}

endGameButtonParam = {
    index = 1, click_function = 'gameToggleButton',
    position = {1.0, 0.1, 0.0}, width = 750, height=600, font_size = 150, function_owner = nil
}

skipTurnButtonParam = {
   index = 2, click_function = 'skipTurnButton',
   position = {2.8, 0.1, 0.0}, width = 750, height=600, font_size = 150, function_owner = nil
}

debugButtonParam = {
   index = 3, label = 'Debug mode:\n' .. debugLevel, click_function = 'switchDebugLevel',
   position = {-0.8, 0.1, 1.6}, width = 1000, height=500, font_size = 150, function_owner = nil
}

showTraversalParam = {
   index = 4, label = 'Show\nTraversal', click_function = 'debugShowTraversal',
   position = {1.5, 0.1, 1.6}, width = 1000, height=500, font_size = 150, function_owner = nil
}

showFeatureMapParam = {
   index = 5, label = 'Show\nFeature\nMap', click_function = 'debugShowFeatureMap',
   position = {3.8, 0.1, 1.6}, width = 1000, height=500, font_size = 150, function_owner = nil
}

showTileOddsParam = {
   index = 6, label = 'Show\nConnection\nOdds', click_function = 'debugShowTileOdds',
   position = {6.1, 0.1, 1.6}, width = 1000, height=500, font_size = 150, function_owner = nil
}

expansionBags = {
    ['InC'] = {guid = '95eb56', contents = {
        ['InCTiles'] = {guid = '122dff'}
        -- ['InCBigFollower'] = {guid = 'e5ec48', contents =
        --     {['Green'] = {guid = 'd9ab61'}, ['Purple'] = {guid = '62c526'}, ['White'] = {guid = '85ef73'}, ['Blue'] = {guid = 'f741b3'}, ['Red'] = {guid = 'ac3616'}, ['Yellow'] = {guid = '2456df'}}
        -- }
    }},
    ['TnB'] = {guid = '09fab1', contents = {
        ['TnBTiles'] = {guid = 'a88997'},
        -- ['TnBBuilder'] = {guid = 'a3aea6', contents =
        --     {['Green'] = {guid = '61cb95'}, ['Purple'] = {guid = '4ea21e'}, ['White'] = {guid = 'e11ef8'}, ['Blue'] = {guid = '128a06'}, ['Red'] = {guid = 'b12bcc'}, ['Yellow'] = {guid = '967ed5'}}
        -- },
        -- ['TnBPig'] = {guid = 'a3aea6', contents =
        --     {['Green'] = {guid = 'a180e1'}, ['Purple'] = {guid = '3f96a3'}, ['White'] = {guid = '2eb691'}, ['Blue'] = {guid = '8f7df7'}, ['Red'] = {guid = 'cc6164'}, ['Yellow'] = {guid = '26c485'}}
        -- },
        ['TnBClothTokenStack'] = {guid = 'ebd019'},
        ['TnBWineTokenStack'] = {guid = '55a94f'},
        ['TnBWheatTokenStack'] = {guid = '7a829b'}
    }},
    ['PnD'] = {guid = '564958', contents = {
        ['PnDTiles'] = {guid = '89bb59'},
        ['PnDDragon'] = {guid = 'e191ec'},
        ['PnDFairy'] = {guid = '46278a'}
    }},
    ['Tower'] = {guid = 'd59a8b', contents = {}},
    ['AnM'] = {guid = '9295b3', contents = {
        ['AnMTiles'] = {guid = '44e318'},
        ['AnMAbbey'] = {guid = '7e2126'},
        ['AnMMayor'] = {guid = '3cee76'},
        ['AnMWagon'] = {guid = 'e0467b'},
        ['AnMBarn'] = {guid = '306ca2'}
    }},
    ['CoC'] = {guid = 'd3189b', contents = {
        ['CoCCount'] = {guid = 'fba388'},
        ['CoCStartingTiles'] = {guid = 'af8d39', contents = {
            [1] = {guid = '9c4fe7'},
            [2] = {guid = 'a6ff3c'},
            [3] = {guid = '9fd64f'},
            [4] = {guid = 'b0410c'},
            [5] = {guid = '78d5ee'},
            [6] = {guid = '8a1ed2'},
            [7] = {guid = 'a0ef6a'},
            [8] = {guid = '31cbd2'},
            [9] = {guid = '49a323'},
            [10] = {guid = '78a086'},
            [11] = {guid = '5cc6c2'},
            [12] = {guid = '233a1a'},
        }}
    }},
    ['KnRB'] = {guid = '927621', contents = {
        ['KnRBTiles'] = {guid = 'f5773a'},
        ['KnRBKing'] = {guid = 'c3021c'},
        ['KnRBRobber'] = {guid = '26c11d'}
    }},
    ['Cult'] = {guid = 'da553b', contents = {
        ['CultTiles'] = {guid = '96ff26'},
        ['CultBonusTile'] = {guid = '754953'}
    }},
    ['Catapult'] = {guid = 'e6d35f', contents = {
        ['CatapultTiles'] = {guid = '686f5b'},
        ['CatapultKnockOut'] = {guid = '158e59'},
        ['CatapultSeduction'] = {guid = 'b0bb3a'},
        ['CatapultTarget'] = {guid = '61b65e'},
        ['CatapultCatch'] = {guid = '075ec5'}
    }},
    ['BCnB'] = {guid = '59c769', contents = {
        ['BCnBTiles'] = {guid = '10f82c'},
        ['BCnBBridges'] = {guid = '16090d'},
        ['BCnBCastles'] = {guid = 'ee8c46'}
    }},
    ['Flier'] = {guid = 'a50c26', contents = {
        ['FlierTiles'] = {guid = 'f006d5'},
        ['FlierDie'] = {guid = 'dc7bf3'}
    }},
    ['GamesQuarterly'] = {guid = 'c97cee', contents = {
        ['GamesQuarterlyTiles'] = {guid = '235648'},
        ['RiverSpringTile'] = {guid = '873113'},
        ['RiverBodyTiles'] = {guid = '2d5d36'}
    }},
    ['Goldmines'] = {guid = '080d67', contents = {
        ['GoldminesTiles'] = {guid = 'bc8fac'},
        ['GoldminesGold'] = {guid = 'd013b9'}
    }},
    ['HnS'] = {guid = 'a50c27', contents = {
        ['HnSTiles'] = {guid = '3fb950'},
        ['HnSSheepBag'] = {guid = '12bf5b'}
    }},
    ['River'] = {guid = '51fd29', contents = {
        ['RiverSpringTile'] = {guid = 'bec44f'},
        ['RiverLakeTile'] = {guid = 'f85830'},
        ['RiverBodyTiles'] = {guid = 'd5e587'},
    }},
    ['RiverII'] = {guid = '5a29f0', contents = {
        ['RiverForkTile'] = {guid = '5a8213'},
        ['RiverSpringTile'] = {guid = '0e6627'},
        ['RiverLakeTile'] = {guid = 'a423e8'},
        ['RiverBodyTiles'] = {guid = 'c6344e'},
    }},
    ['RiverBB5'] = {guid = '592f3a', contents = {
        ['RiverSpringTile'] = {guid = '553392'},
        ['RiverLakeTile'] = {guid = 'b9de5a'},
        ['RiverBodyTiles'] = {guid = 'e9d3b0'},
    }},
    ['RussianPromo'] = {guid = 'bdeb95', contents = {
        ['RussianPromoTiles'] = {guid = 'd47ccc'}
    }},
    ['SpielPromo'] = {guid = '1e48bf', contents = {
        ['SpielPromoTiles'] = {guid = '9129b0'}
    }},
    ['Tower'] = {guid = 'd59a8b', contents = {
        ['TowerTiles'] = {guid = '15a27f'}
    }},
    ['WoF'] = {guid = '6feb10', contents = {
        ['WoFTiles'] = {guid = '71aa80'},
        ['WoFWheelTiles'] = {guid = 'ee3e97'},
        ['WoFStartingTiles'] = {guid = '6a31db', contents = {
            [1] = {guid = 'c7bc6d'},
            [2] = {guid = 'c391bc'},
            [3] = {guid = '7e508f'},
            [4] = {guid = '01f705'},
            [5] = {guid = '983022'},
            [6] = {guid = 'a39cb0'},
            [7] = {guid = 'f28f77'},
            [8] = {guid = '744e80'},
            [9] = {guid = '79956d'},
            [10] = {guid = '466a78'},
            [11] = {guid = '1d5025'},
            [12] = {guid = '2faa15'},
            [13] = {guid = '21cc72'},
            [14] = {guid = '8e2c6f'},
            [15] = {guid = '2c3d25'},
            [16] = {guid = '9dc2d2'},
        }},
        ['WoFWheel'] = {guid = 'ef0143'},
        ['WoFPig'] = {guid = '97e9dc'}
    }}
}

controlPanelSettings = {
--pg 1
    --Hotseat or AI control settings (nil means default color control)
    ['GreenControl'] = nil,
    ['PurpleControl'] = nil,
    ['WhiteControl'] = nil,
    ['BlueControl'] = nil,
    ['RedControl'] = nil,
    ['PinkControl'] = nil,
    --Starting tiles
    ['StartingTileBase'] = true,
    ['StartingTileRiver'] = false,
    ['StartingTileRiverII'] = false,
    ['StartingTileRiverBB5'] = false,
    ['StartingTileCoC'] = false,
    ['StartingTileWoF'] = false,
    ['StartingTileSchool'] = false,
    ['StartingTileWindRoses'] = false,
--pg 2
    --Base + Major expansions
    ['BaseTiles'] = true,
    ['BaseFollower'] = true,
    ['BaseNumFollowers'] = 7,
    ['InCTiles'] = false,
    ['InCBigFollower'] = false,
    ['InCInns'] = false,
    ['InCCathedrals'] = false,
    ['TnBTiles'] = false,
    ['TnBBuilder'] = false,
    ['TnBPig'] = false,
    ['TnBTradeGoods'] = false,
    ['PnDTiles'] = false,
    ['PnDDragon'] = false,
    ['PnDFairy'] = false,
    ['PnDMagicPortal'] = false,
    ['PnDPrincess'] = false,
    ['TowerTiles'] = false,
    ['TowerTowers'] = false,
    ['TowerNumTowers'] = 10,
--pg 3
    ['AnMTiles'] = false,
    ['AnMAbbey'] = false,
    ['AnMMayor'] = false,
    ['AnMWagon'] = false,
    ['AnMBarn'] = false,
    ['KnRBTiles'] = false,
    ['KnRBKing'] = false,
    ['KnRBRobber'] = false,
    ['CultTiles'] = false,
    ['CatapultTiles'] = false,
    ['BCnBTiles'] = false,
    ['BCnBBazaars'] = false,
    ['BCnBBridges'] = false,
    ['BCnBCastles'] = false,
    ['HnSTiles'] = false,
    ['HnSShepherd'] = false,
    ['HnSHills'] = false,
    ['HnSVineyards'] = false,
--pg 4
    ['WoFTiles'] = false,
    ['WoFWheelTiles'] = false,
    ['WoFCrowns'] = false,
    ['WoFFortune'] = false,
    ['WoFTaxes'] = false,
    ['WoFFamine'] = false,
    ['WoFStorm'] = false,
    ['WoFInquisition'] = false,
    ['WoFPlague'] = false,
    --Mini expansions
    ['FlierTiles'] = false,
    ['FlierFlier'] = false,
    ['GoldminesTiles'] = false,
    ['GoldminesGold'] = false,
--pg 5
    --Micro expansions
    ['GamesQuarterlyTiles'] = false,
    ['SpielPromoTiles'] = false,
    ['RussianPromoTiles'] = false,
--pg 6
    --House rules
    ['BaseDisableRoads'] = false,
    ['BaseDisableCities'] = false,
    ['BaseDisableCloisters'] = false,
    ['BaseDisableFarms'] = false,
    ['BaseNerfSmallCity'] = false,
    ['TowerNerfTowers'] = false,
    ['RiverMixAll'] = false,
    ['RIIDisablePigherd'] = false,
    ['CoCNoCount'] = false,
}

tileGrid = {[MIDDLE_X_OFFSET]={[MIDDLE_Z_OFFSET]={tile_guid=startingTile_GUID, rotation=2}}}
lastPlacedTileX = nil
lastPlacedTileZ = nil

featureMap = {}
featureIndex = 1
featureList = {}

droplock = false
spamLock = false
scoring = false
gameover = true

wagonFeatures = {}

currentMiniTurn = nil --used when the player order must be iterated within someone's turn

traversedGrid = {}
traversedFeaturePositions = {}
traversedTileCoords = {}
traversedOpeningCoords = {}
traversedSpecialFeatures = {}
traversedFollowers = {}
traversedSpecialFigures = {}
traversedSheepTokens = {}
traversedGoldBars = {}

followersScored = {}
earnedPointsThisTile = {}
removedFigures = {}
featureMarkers = {}
scoringRewards = {}

largestCity = 0
longestRoad = 0
scoreSummary = {}
activePlayers = {}
currentPlayer = nil

lastPlacedPlayerTiles = {}

shepherdAwaitingAction = nil
newBarn = nil
hasBuilderAwaitingAction = false
hasAlreadyTakenBuilderTile = false
hasRansomedPrisoner = false
buriedTile = nil
dragonHasAwaken = false
dragonMoveNumber = 1
dragonIllegalTiles = {}
tileHasVolcano = false
tileHasMagicPortal = false
flier = nil
flierOffset = nil
seducedKnights = {}
carcassonneFigures = nil
barnFeatureNumbers = nil
wofPigPosition = 1

turnState = nil

currentLanguage = 'en-us'
--currentLanguage = 'zh-tw'

#include !\TTSCarcassonne\scripts\localization

#include !\TTSCarcassonne\scripts\state_machine

#include !\TTSCarcassonne\scripts\save_game

#include !\TTSCarcassonne\scripts\setup_game

#include !\TTSCarcassonne\scripts\tts_events

--checks if the person pressing the control panel buttons is an admin, and that the game is not already running
function checkControlPanelPrivileges(player)
    if not gameover then
        broadcastToColor('Game has already started', player.sColor, NEUTRAL_COLOR)
        return false
    end
    local PPlayer = Player[player.sColor]
    if PPlayer ~= nil then
        if PPlayer.admin then
            return true
        else
            broadcastToColor('Only promoted players can use the control panel', player.sColor, ERROR_COLOR)
        end
    end
    return false
end

--checks if the person pressing the button is an admin
function checkAdminPrivileges(player)
    local PPlayer = Player[player]
    if PPlayer ~= nil then
        if PPlayer.admin then
            return true
        else
            broadcastToColor('Only promoted players can use this button', player, ERROR_COLOR)
        end
    end
    return false
end

--checks if the person pressing the button is the current player, a hotseat's owner, or an admin
function checkGameButtonPrivileges(player)
    local PPlayer = Player[player]
    if PPlayer ~= nil then
        if PPlayer.admin or
        (currentMiniTurn ~= nil and (player == activePlayers[currentMiniTurn] or player == getCurrentPlayerOwner())) or
        (currentMiniTurn == nil and (player == activePlayers[currentPlayer] or player == getCurrentPlayerOwner())) then
            return true
        else
            broadcastToColor('Only the current player or promoted players can use this button', player, ERROR_COLOR)
        end
    end
    return false
end

--this function will allow object scripts (specifically the control panels) to get control panel settings
function getControlPanelState(p)
    return controlPanelSettings[p.key]
end

--this function will allow object scripts (specifically the control panels) to set control panel settings
function setControlPanelState(p)
    controlPanelSettings[p.key] = p.value
end

--skip the rest of the turn and move to the next player
function skipTurnButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        endTurn()
    end
end

function endTurn()
    for _, object in ipairs(getAllObjects()) do
        if tostring(object) == 'Card(Clone) (LuaGameObjectScript)' or table.contains(FOLLOWER_TYPES, object.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, object.getVar('figureName')) then
            --hasRansomedPrisoner
            object.highlightOff()
            object.clearButtons()
        end
    end
    if not gameover then
        --the following will detect that the game has finished and will not go to the next turn
        --local tileStack = getObjectFromGUID(tileStack_GUID)
        --if tileStack == nil and finalTile_GUID == nil then
        --    allGameMessage("The game is over. Calculate the final score by pressing the End Game button. (If this was unexpected, it could be because the tile stack was taken apart or manually stacked wrong)", NEUTRAL_COLOR)
        --else
            if lastPlacedTileX == nil or not (controlPanelSettings['PnDDragon'] and tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid == expansionBags['RiverII'].contents['RiverLakeTile'].guid) then
                currentPlayer = currentPlayer + 1
                if currentPlayer > #activePlayers then
                    currentPlayer = 1
                end
                if controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] == nil then
                    allGameMessage({"-----------It is now {c1}'s turn-----------", {'{c1}', getPlayerOwnerName(activePlayers[currentPlayer])}}, player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
                else
                    allGameMessage({"-----------It is now {c1}'s turn-----------", {'{c1}', activePlayers[currentPlayer]}}, player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
                    allGameMessage({"-------{c1} is controlled by {c2}------", {'{c1}', activePlayers[currentPlayer]}, {'{c2}', getPlayerOwnerName(activePlayers[currentPlayer]) .. stringToBracketedHex(activePlayers[currentPlayer])}}, player_color_tints[activePlayers[currentPlayer]], nil)
                end
            else
                allGameMessage({"{c1} gets another turn for laying down the volcano lake tile.", {'{c1}', activePlayers[currentPlayer]}}, player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
            end
            turnState = 'begin turn' --in case skip turn was pressed, go to the beginning from every state
            if controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] ~= nil and controlPanelSettings[activePlayers[currentPlayer] .. 'Control']:sub(1,2) == 'AI' then
                return AIStateHandler()
            else
                return stateHandler()
            end
        --end
    end
end

--if the current player is a hotseat player, return the owner
function getCurrentPlayerOwner()
    if currentPlayer == nil then return nil end
    local player
    if currentMiniTurn ~= nil and controlPanelSettings[activePlayers[currentMiniTurn] .. 'Control'] ~= nil then
        player = controlPanelSettings[activePlayers[currentMiniTurn] .. 'Control']
    end
    if currentMiniTurn == nil and controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] ~= nil then
        player = controlPanelSettings[activePlayers[currentPlayer] .. 'Control']
    end
    return player
end

--gets the owner of this seat or hotseat
function getPlayerOwner(player)
    if player == nil then return nil end
    local owner = player
    if currentMiniTurn ~= nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    if currentMiniTurn == nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    return owner
end

--gets the steam name of the person controlling this player
function getPlayerOwnerName(player)
    if player == nil then return nil end
    local owner = player
    if currentMiniTurn ~= nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    if currentMiniTurn == nil and controlPanelSettings[player .. 'Control'] ~= nil then
        owner = controlPanelSettings[player .. 'Control']
    end
    if owner:sub(1,2) == 'AI' then
        return owner
    elseif Player[owner].steam_name == nil then
        return owner
    else
        return Player[owner].steam_name
    end
end

-- Activates when button is pressed
function showMarkersToggleButton(object, sPlayer)
    if checkAdminPrivileges(sPlayer) then
        -- Toggles between different showMarker modes
        if showMarkers == 'Scoring' then showMarkers = 'Hints'
        elseif showMarkers == 'Hints' then showMarkers = 'Both'
        elseif showMarkers == 'Both' then showMarkers = 'None'
        elseif showMarkers == 'None' then showMarkers = 'Scoring'
        end
        showMarkersButtonParam.label = translate({'Show\nMarkers:\n'}) .. translate({showMarkers})
        buttonBoard.editButton(showMarkersButtonParam)
    end
end

--starts the game if the game has not yet started. Ends the game if the game is already running
function gameToggleButton(object, sPlayer)
    if checkAdminPrivileges(sPlayer) then
        if gameover then
            local hasStartingTiles = false
            for controlPanelSetting, settingOn in pairs(controlPanelSettings) do
                if settingOn and table.contains({'StartingTileBase', 'StartingTileRiver', 'StartingTileRiverII', 'StartingTileRiverBB5', 'StartingTileCoC', 'StartingTileWoF', 'StartingTileSchool', 'StartingTileWindRoses'}, controlPanelSetting) then
                    hasStartingTiles = true
                end
            end
            if not hasStartingTiles then
                allErrorMessage({"Cannot start a game without a starting tileset."}, sPlayer)
                return
            end
            local hasTileStack = false
            for controlPanelSetting, settingOn in pairs(controlPanelSettings) do
                if settingOn and table.contains({'BaseTiles','InCTiles','TnBTiles','PnDTiles','TowerTiles','AnMTiles','KnRBTiles','CultTiles','CatapultTiles','BCnBTiles','HnSTiles','WoFTiles','WoFWheelTiles','FlierTiles','GoldminesTiles'}, controlPanelSetting) then
                    hasTileStack = true
                end
            end
            if not hasTileStack then
                allErrorMessage({"Cannot start a game without tiles."}, sPlayer)
                return
            end
            for _, player_color in ipairs(PLAYER_COLORS) do
                if controlPanelSettings[player_color .. 'Control'] ~= nil and controlPanelSettings[player_color .. 'Control']:sub(1,2) == 'AI' then
                    local illegalExpansion = false
                    local illegalExpansionList = ""
                    for controlPanelSetting, settingOn in pairs(controlPanelSettings) do
                        if settingOn and table.contains({'StartingTileCoC', 'PnDDragon', 'TowerTowers', 'AnMAbbey', 'AnMWagon', 'WoFPlague', 'FlierFlier', 'GoldminesGold'}, controlPanelSetting) then
                            illegalExpansion = true
                            illegalExpansionList = illegalExpansionList .. controlPanelSetting .. ", "
                        end
                    end
                    if illegalExpansion then
                        illegalExpansionList = illegalExpansionList:sub(1, -3) --get rid of the last comma and space
                        allErrorMessage({"Cannot start an AI game with incompatible expansions: {s1}.", {'{s1}', illegalExpansionList}}, sPlayer)
                        return
                    end
                    break
                end
            end
        endGameButtonParam.label = translate({'End game\n(score\npoints)'})
            startLuaCoroutine(self, 'startGame')
        else
        endGameButtonParam.label = translate({'Score\nSummary'})
            endGameButtonParam.click_function = 'printScoreSummary'
            endGame()
        end
        buttonBoard.editButton(endGameButtonParam)
    end
end

function endGame()
    gameover = true
  	clearArbitraryButtons(true)
    if scoring ~= true then
        turnState = 'game over - prompt moving from carcassonne'
        if controlPanelSettings[activePlayers[currentPlayer] .. 'Control'] ~= nil and controlPanelSettings[activePlayers[currentPlayer] .. 'Control']:sub(1,2) == 'AI' then
            return AIStateHandler()
        else
            return stateHandler()
        end
    end
end

-- Activates when button is pressed
function switchDebugLevel()
    -- switches between debug mode levels. Updates button's label to match
    debugLevel = debugLevel + 1
    if debugLevel > 3 then debugLevel = 0 end
    debugButtonParam.label = 'Debug mode:\n' .. debugLevel
    buttonBoard.editButton(debugButtonParam)
end

function initializeScoreSummary()
    for _, player_color in ipairs(activePlayers) do
        scoreSummary[player_color] = {}
        scoreSummary[player_color]['City'] = 0
        scoreSummary[player_color]['Road'] = 0
        scoreSummary[player_color]['Field'] = 0
        scoreSummary[player_color]['Cloister'] = 0
        if controlPanelSettings['TnBTradeGoods'] then
            scoreSummary[player_color]['Trade Goods'] = 0
        end
        if controlPanelSettings['HnSShepherd'] then
            scoreSummary[player_color]['Shepherd'] = 0
        end
        if controlPanelSettings['PnDFairy'] then
            scoreSummary[player_color]['Fairy'] = 0
        end
        if controlPanelSettings['KnRBKing'] or controlPanelSettings['KnRBRobber'] then
            scoreSummary[player_color]['King/Robber Tokens'] = 0
        end
        if controlPanelSettings['GoldminesGold'] then
            scoreSummary[player_color]['Gold'] = 0
        end
        if controlPanelSettings['TowerTowers'] then
            scoreSummary[player_color]['Ransom'] = 0
        end
        if pigIsEnabled() then
            scoreSummary[player_color]['Wheel'] = 0
        end
    end
end

function scorePoints(player, feature, points)
    if feature == 'Abbey' or feature == 'Shrine' or feature == 'Garden' or feature == "Baba Yaga's Hut" then feature = 'Cloister' end --these don't really need a seperate category
    if scoreSummary[player][feature] == nil then
        allErrorMessage("ERROR: " .. feature .. " is not valid. Please remove this figure.")
        return
    end
    if earnedPointsThisTile[player] == nil then earnedPointsThisTile[player] = 0 end
    earnedPointsThisTile[player] = earnedPointsThisTile[player] + points
    scoreSummary[player][feature] = scoreSummary[player][feature] + points
    local scoreCounter = getObjectFromGUID(score_counter_guids[player])
    if scoreCounter ~= nil then
        scoreCounter.Counter.setValue(scoreCounter.Counter.getValue() + points)
    else
        allErrorMessage("Error adding score to " .. figure.getVar('owner') .. "'s counter")
    end
    printScoreToNotes()
end

function printScoreToNotes()
    local scoreBoard = ""
    printedPlayers = {}
    local playerNum = 1
    local rank = 1
    local lastHighscore = 0
    while true do
        local highscore = -999
        local playerNum = nil
        local color = nil
        for playerIndex, player in ipairs(activePlayers) do
            local scoreCounter = getObjectFromGUID(score_counter_guids[player])
            if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                if scoreCounter.Counter.getValue() > highscore then
                    highscore = scoreCounter.Counter.getValue()
                    playerNum = playerIndex
                    color = player
                end
            end
        end
        if highscore > -999 then
            if highscore < lastHighscore then rank = playerNum end
            local steam_name = ""
            if getPlayerOwner(color):sub(1,2) == 'AI' then
                steam_name = getPlayerOwner(color)
            elseif controlPanelSettings[color .. 'Control'] ~= nil then
                if Player[controlPanelSettings[color .. 'Control']].steam_name ~= nil then steam_name = Player[controlPanelSettings[color .. 'Control']].steam_name end
            else
                if Player[color].steam_name ~= nil then steam_name = Player[color].steam_name end
            end
            local currentPlayerMarker = ""
            if not gameover and playerNum == currentPlayer then
                currentPlayerMarker = CURRENT_PLAYER_MARKER
            end
            scoreBoard = scoreBoard .. stringToBracketedHex(color) .. currentPlayerMarker .. translate({"{n1} points - {p1}", {'{n1}', highscore}, {'{p1}', steam_name}}) .. "\n"
        else
            break
        end
        table.insert(printedPlayers, color)
        playerNum = playerNum + 1
        lastHighscore = highscore
    end
    setNotes(scoreBoard)
end

function printScoreSummary(object, sPlayer)
    printedPlayers = {}
    local playerNum = 1
    local rank = 1
    local lastHighscore = 0
    while true do
        local highscore = 0
        local color = nil
        for _, player in ipairs(activePlayers) do
            local scoreCounter = getObjectFromGUID(score_counter_guids[player])
            if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                if scoreCounter.Counter.getValue() > highscore then
                    highscore = scoreCounter.Counter.getValue()
                    color = player
                end
            end
        end
        if highscore > 0 then
            if highscore < lastHighscore then rank = playerNum end
            local steam_name = ""
            if getPlayerOwner(color):sub(1,2) == 'AI' then
                steam_name = getPlayerOwner(color)
            elseif controlPanelSettings[color .. 'Control'] ~= nil then
                if Player[controlPanelSettings[color .. 'Control']].steam_name ~= nil then steam_name = Player[controlPanelSettings[color .. 'Control']].steam_name end
            else
                if Player[color].steam_name ~= nil then steam_name = Player[color].steam_name end
            end
            printToColor(translate({"#{n1} - {n2} points - {c1} - {p1}", {'{n1}', rank}, {'{n2}', highscore}, {'{c1}', color}, {'{p1}', steam_name}}), sPlayer, player_color_tints[color])
            local accountedPoints = 0
            for key, score in pairs(scoreSummary[color]) do
                local featureName = key
                if key == 'Field' then featureName = 'Farms'
                elseif key == 'Road' then featureName = 'Roads'
                elseif key == 'City' then featureName = 'Cities'
                elseif key == 'Cloister' then featureName = 'Cloisters'
                end
                printToColor("  " .. translate({featureName}) .. ": " .. score, sPlayer, player_color_tints[color])
                accountedPoints = accountedPoints + score
            end
            if accountedPoints ~= highscore then
                printToColor("  unaccounted points: " .. highscore - accountedPoints, sPlayer, player_color_tints[color])
            end
        else
            break
        end
        table.insert(printedPlayers, color)
        playerNum = playerNum + 1
        lastHighscore = highscore
    end
end

-- sets the scores to 0
function clearCounters()
    --Clear all victory point counters
    for _, scoreCounter_GUID in pairs(score_counter_guids) do
        local scoreCounter = getObjectFromGUID(scoreCounter_GUID)
        if scoreCounter ~= nil then
            scoreCounter.Counter.clear()
        end
    end
end

function getActiveFigures()
    baselineFollowerCounts = {}
    baselineFigures = {}
    activeFigures = {}

    for _, player in ipairs(activePlayers) do
        baselineFollowerCounts[player] = 0
        baselineFigures[player] = {}
    end
    for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
        if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, obj.getVar('figureName')) then
            local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                xPosition = xPosition - xIndex
                zPosition = zPosition - zIndex
                local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                local rotation = tileGrid[xIndex][zIndex].rotation
                local closestPosition = findClosestPosition(xPosition, zPosition, tile, rotation, false)
                local featureNum = featureMap[xIndex][zIndex][closestPosition]

                if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(closestPosition * 2) + 3] ~= nil then
                    if featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'Road' and featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'River' then
                        featureNum = featureMap[xIndex][zIndex][(closestPosition * 2) + 3]
                    end
                end
                --print(obj.getGUID() .. ": pos - " .. closestPosition .. " featureNum - " .. featureNum)
                if activeFigures[featureNum] == nil then
                    activeFigures[featureNum] = {}
                    activeFigures[featureNum].specialFigures = {}
                    activeFigures[featureNum].followers = {}
                end
                if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) then
                    table.insert(activeFigures[featureNum].followers, obj)
                else
                    table.insert(activeFigures[featureNum].specialFigures, obj)
                end
            elseif obj.getVar('figureName') ~= 'Follower' then
                baselineFigures[obj.getVar('owner')][obj.getVar('figureName')] = true
            else
                baselineFollowerCounts[obj.getVar('owner')] = baselineFollowerCounts[obj.getVar('owner')] + 1
            end
        end
    end
end

-- function getActiveNeutralFigures()
--     activeNeutralFigures = {}
--
--     for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
--         if obj.getVar('figureName') == GOLD_BAR_NAME then
--             local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
--             local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
--             if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
--                 local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
--                 local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
--                 xPosition = xPosition - xIndex
--                 zPosition = zPosition - zIndex
--                 local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
--                 local rotation = tileGrid[xIndex][zIndex].rotation
--                 local closestPosition = findClosestPosition(xPosition, zPosition, tile, rotation, false)
--                 local featureNum = featureMap[xIndex][zIndex][closestPosition]
--
--                 if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(closestPosition * 2) + 3] ~= nil then
--                     if featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'Road' and featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'River' then
--                         featureNum = featureMap[xIndex][zIndex][(closestPosition * 2) + 3]
--                     end
--                 end
--                 --print(obj.getGUID() .. ": pos - " .. closestPosition .. " featureNum - " .. featureNum)
--                 if activeNeutralFigures[featureNum] == nil then
--                     activeNeutralFigures[featureNum] = {}
--                     activeNeutralFigures[featureNum].goldBars = {}
--                 end
--                 if obj.getVar('figureName') == GOLD_BAR_NAME then
--                     print("added gold bar at x:" .. xIndex .. " z:" .. zIndex)
--                     table.insert(activeNeutralFigures[featureNum].goldBars, obj)
--                 end
--             end
--         end
--     end
-- end

#include !\TTSCarcassonne\scripts\hint_markers

#include !\TTSCarcassonne\scripts\move_validation

#include !\TTSCarcassonne\scripts\feature_map_management

--tileConnectsToSide
-- params:
--  obj: tile 1
--  int: rotation 1 (rotation of the tile)
--  int: which side of the first tile is being checked
--  obj: tile 2
--  int: rotation 2
-- returns:
--  bool: true if they match
function tileConnectsToSide(t1, r1, n1, t2, r2)
    s1 = t1.getTable('sides')[(3 + n1 - r1) % 4 + 1]
    s2 = t2.getTable('sides')[(3 + n1 - r2 + TILE_180_ROTATION) % 4 + 1]
    --debugMessage(2, "s1(" .. (3 + n1 - r1) % 4 + 1 .. "): " .. s1 .. " s2(" .. (3 + n1 - r2 + TILE_180_ROTATION) % 4 + 1 .. "): " .. s2)
    if s1 == 'Abbey' or s2 == 'Abbey' then return true end

    local splits1 = string.split(s1, "/")
    if #splits1 == 1 then
        if s1 == s2 then return true else return false end
    else
        local splits2 = string.split(s2, "/")
        if #splits2 == 1 then return false end
        if splits1[1] == splits2[2] and splits1[2] == splits2[1] then return true else return false end
    end
end

--tileGridOccupied
-- params:
--  int: x
--  int: z
-- returns:
--  bool: true if occupied
function tileGridOccupied(x, z)
    if tileGrid[x] == nil or tileGrid[x][z] == nil then return false else return true end
end

--check for features that have been added to, including:
--shepherds on fields, builders in cities or on roads
function checkAddedTileSpecialFigureExtensions()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)

    resetTraversal()

    for i=1, 12 do
        if newTile.getTable('sides')[1] ~= 'Abbey' then
            getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, false)
        end
    end

    getFigureComponents()
    for _, figure in ipairs(traversedSpecialFigures) do
        if activePlayers[currentPlayer] ~= nil and figure.getVar('owner') == activePlayers[currentPlayer] and
           newTile.getTable('sides')[1] ~= 'Abbey' then --do not give give sheep/extra builder tile (CAR ref 149)
            if figure.getVar('figureName') == 'Shepherd' then
                shepherdAwaitingAction = figure.getGUID()
            elseif figure.getVar('figureName') == 'Builder' and not hasAlreadyTakenBuilderTile then
                hasBuilderAwaitingAction = true
            end
        end
    end
    return nextState('next')
end

function checkTileForHill()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if controlPanelSettings['HnSHills'] and specialFeature[1] == "Hill" then
                local buriedTile_obj = nil
                if buriedTile == nil then
                    local drawPile = getObjectFromGUID(tileStack_GUID)
                    if drawPile ~= nil then
                        local params = {}
                        params.position = {newTile.getPosition().x, newTile.getPosition().y + 1, newTile.getPosition().z}
                        params.rotation = {0, 180, 180}
                        buriedTile_obj = drawPile.takeObject(params)
                        buriedTile = buriedTile_obj.getGUID()
                    elseif finalTile_GUID ~= nil then
                        buriedTile = finalTile_GUID
                        buriedTile_obj = getObjectFromGUID(buriedTile)
                        local position = {newTile.getPosition().x, newTile.getPosition().y + 1, newTile.getPosition().z}
                        buriedTile_obj.setPositionSmooth(position)
                        finalTile_GUID = nil
                    else
                        allErrorMessage("Warning: Hill drawn but draw pile not found.")
                        allErrorMessage("This could be because the draw pile has only 1 tile left or none.")
                        allErrorMessage("If there is 1 tile left, it must be manually placed underneath the hill")
                        return nextState('next')
                    end
                else
                    buriedTile_obj = getObjectFromGUID(buriedTile)
                end

                buriedTile_obj.interactable = false
                newTile.use_gravity = false
                newTile.interactable = false
                newTile.setPositionSmooth({newTile.getPosition().x, newTile.getPosition().y + 2, newTile.getPosition().z}, false, false)
                Timer.create({identifier=newTile.getGUID() .. os.clock(), function_name='freezeFloatingHillTile', function_owner=nil, parameters={tile=newTile, buriedTile=buriedTile_obj}, delay=0.8})
                return
            end
        end
    end
    return nextState('next')
end

--the next 3 functions use Timers to create a sequence to allow for a tile to be buried underneath

--locks the tile for a moment to wait for the tile to be buried
function freezeFloatingHillTile(param)
    local tile = param.tile
    local buriedTile = param.buriedTile
    tile.setLock(true)
    Timer.create({identifier=tile.getGUID() .. os.clock(), function_name='unfreezeFloatingHillTile', function_owner=nil, parameters={tile=tile, buriedTile=buriedTile}, delay=0.5})
end

--unlock the tile and wait for it to fall back down
function unfreezeFloatingHillTile(param)
    local tile = param.tile
    local buriedTile = param.buriedTile
    tile.use_gravity = true
    tile.setLock(false)
    Timer.create({identifier=tile.getGUID() .. os.clock(), function_name='finishHillTile', function_owner=nil, parameters={tile=tile, buriedTile=buriedTile}, delay=0.8})
end

--lock the tile and other post tile actions
function finishHillTile(param)
    local tile = param.tile
    local buriedTile = param.buriedTile
    tile.interactable = true
    buriedTile.interactable = true
    if AUTOLOCK then
        buriedTile.setLock(true)
        tile.setLock(true)
    end
    return nextState('next')
end

ANIMATION_PIG_ACCEL_DEGREES = 30
ANIMATION_PIG_ACCEL_TIME = 0.5
-- using equation d = vi t + (a t * t) / 2
ANIMATION_PIG_ACCEL = ANIMATION_PIG_ACCEL_DEGREES * 2 / (ANIMATION_PIG_ACCEL_TIME * ANIMATION_PIG_ACCEL_TIME)
-- using equation d = (vi + vf) / 2 * t
ANIMATION_PIG_MAX_VELOCITY = ANIMATION_PIG_ACCEL_DEGREES * 2 / ANIMATION_PIG_ACCEL_TIME
-- 60 degrees per space
ANIMATION_PIG_TIME_PER_SPACE = 60 / ANIMATION_PIG_MAX_VELOCITY

function checkTileForWheel()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if pigIsEnabled() and string.sub(specialFeature[1],1,6) == 'Wheel-' then
                local pos_moved = string.sub(specialFeature[1],7,7)
                startAnimation({type='WoFPig', start_time=os.clock(), start_position=wofPigPosition, num_positions_moved=pos_moved})
                wofPigPosition = wofPigPosition + pos_moved
                if wofPigPosition > 6 then wofPigPosition = wofPigPosition - 6 end
                Timer.create({identifier=newTile.getGUID() .. os.clock(), function_name='resolveWheel', function_owner=nil, parameters={}, delay=ANIMATION_PIG_ACCEL_TIME * 2 + (pos_moved - 1) * ANIMATION_PIG_TIME_PER_SPACE + 0.5}) --0.5 is an arbitrary delay
                return
            end
        end
    end
    return nextState('next')
end

WHEEL_POSITIONS = {'Fortune', 'Taxes', 'Famine', 'Storm', 'Inquisition', 'Plague'}

function resolveWheel()
    getActiveFigures()
    if WHEEL_POSITIONS[wofPigPosition] == 'Fortune' then
        if controlPanelSettings['WoFFortune'] then
            allGameMessage({"The pig landed on the Fortune event. The current player will be awarded 3 points."}, NEUTRAL_COLOR)
            allGameMessage({"{c1} scores 3 points for landing on the Fortune event.", {'{c1}', activePlayers[currentPlayer]}}, player_color_tints[activePlayers[currentPlayer]])
            scorePoints(activePlayers[currentPlayer], 'Wheel', 3)
        else
            allGameMessage({"The {s1} event is currently disabled. Nothing happens.", {'{s1}', WHEEL_POSITIONS[wofPigPosition]}}, NEUTRAL_COLOR)
        end
    elseif WHEEL_POSITIONS[wofPigPosition] == 'Taxes' then
        if controlPanelSettings['WoFTaxes'] then
            allGameMessage({"The pig landed on the Taxes event. Each knight will score 1 point for every knight (included itself) and pennant in their city."}, NEUTRAL_COLOR)
            for featureNum, figures in pairs(activeFigures) do
                if featureList[featureNum].nameOfFeature == 'City' then
                    local num_pennants = 0
                    for _, specialFeature in ipairs(featureList[featureNum].specialFeatures) do
                        if specialFeature == 'Pennant' then
                            num_pennants = num_pennants + 1
                        end
                    end
                    for _, follower in ipairs(figures.followers) do
                        num_points = num_pennants
                        for _, nestedFollower in ipairs(figures.followers) do
                            if follower.getVar('owner') == nestedFollower.getVar('owner') then
                                num_points = num_points + 1
                            end
                        end
                        allGameMessage({"{c1}'s follower scores {n1} points for the Taxes event.", {'{c1}', follower.getVar('owner')}, {'{n1}', num_points}}, player_color_tints[follower.getVar('owner')])
                        scorePoints(follower.getVar('owner'), 'Wheel', num_points)
                    end
                end
            end
        else
            allGameMessage({"The {s1} event is currently disabled. Nothing happens.", {'{s1}', WHEEL_POSITIONS[wofPigPosition]}}, NEUTRAL_COLOR)
        end
    elseif WHEEL_POSITIONS[wofPigPosition] == 'Famine' then
        if controlPanelSettings['WoFFamine'] then
            allGameMessage({"The pig landed on the Famine event. Each farmer will score 1 point per completed city touching their field (bonuses count)."}, NEUTRAL_COLOR)
            for featureNum, figures in pairs(activeFigures) do
                if featureList[featureNum].nameOfFeature == 'Field' then
                    local num_cities = 0
                    for linkedFeatureNum, _ in pairs(linkedFeatures['City-Field'][featureNum]) do
                        if (featureList[linkedFeatureNum].nameOfFeature == 'City' or featureList[linkedFeatureNum].nameOfFeature == 'Carcassonne') and featureList[linkedFeatureNum].openings == 0 then
                            num_cities = num_cities + 1
                        end
                    end
                    -- CAR pg 111 ref 333
                    local containsPigHerd = false
                    for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                        if feature == 'Pig-herd' and not controlPanelSettings['RIIDisablePigherd'] then
                            containsPigHerd = true
                        end
                    end
                    local hasPig = {}
                    for _, figure in ipairs(figures.specialFigures) do
                        if figure.getVar('figureName') == 'Pig' then
                            hasPig[figure.getVar('owner')] = true
                        end
                    end
                    if num_cities > 0 then
                        for _, follower in ipairs(figures.followers) do
                            local scoreMultiplier = 1
                            if hasPig[follower.getVar('owner')] ~= nil then
                                scoreMultiplier = scoreMultiplier + 1
                            end
                            if containsPigHerd then
                                scoreMultiplier = scoreMultiplier + 1
                            end
                            local playerScore = num_cities * scoreMultiplier
                            allGameMessage({"{c1}'s follower scores {n1} points for the Famine event.", {'{c1}', follower.getVar('owner')}, {'{n1}', playerScore}}, player_color_tints[follower.getVar('owner')])
                            scorePoints(follower.getVar('owner'), 'Wheel', playerScore)
                        end
                    end
                end
            end
        else
            allGameMessage({"The {s1} event is currently disabled. Nothing happens.", {'{s1}', WHEEL_POSITIONS[wofPigPosition]}}, NEUTRAL_COLOR)
        end
    elseif WHEEL_POSITIONS[wofPigPosition] == 'Storm' then
        if controlPanelSettings['WoFStorm'] then
            allGameMessage({"The pig landed on the Storm event. Every player will be awarded 1 point for each unused follower in their supply."}, NEUTRAL_COLOR)
            for playerColor, num_followers in pairs(baselineFollowerCounts) do
                allGameMessage({"{c1} scores {n1} points for the Storm event.", {'{c1}', playerColor}, {'{n1}', num_followers}}, player_color_tints[playerColor])
                scorePoints(playerColor, 'Wheel', num_followers)
            end
        else
            allGameMessage({"The {s1} event is currently disabled. Nothing happens.", {'{s1}', WHEEL_POSITIONS[wofPigPosition]}}, NEUTRAL_COLOR)
        end
    elseif WHEEL_POSITIONS[wofPigPosition] == 'Inquisition' then
        if controlPanelSettings['WoFInquisition'] then
            allGameMessage({"The pig landed on the Inquisition event. Every player will receive 2 points per monk."}, NEUTRAL_COLOR)
            for featureNum, figures in pairs(activeFigures) do
                if table.contains(CLOISTER_FEATURES, featureList[featureNum].nameOfFeature) then
                    for _, follower in ipairs(figures.followers) do
                        allGameMessage({"{c1}'s follower scores 2 points for the Inquisition event.", {'{c1}', follower.getVar('owner')}}, player_color_tints[follower.getVar('owner')])
                        scorePoints(follower.getVar('owner'), 'Wheel', 2)
                    end
                end
            end
        else
            allGameMessage({"The {s1} event is currently disabled. Nothing happens.", {'{s1}', WHEEL_POSITIONS[wofPigPosition]}}, NEUTRAL_COLOR)
        end
    else--if WHEEL_POSITIONS[wofPigPosition == 'Plague'] then
        if controlPanelSettings['WoFPlague'] then
            allGameMessage({"The pig landed on the Plague event. Each player must return 1 follower from a land tile."}, NEUTRAL_COLOR)
            return nextState('plague')
        else
            allGameMessage({"The {s1} event is currently disabled. Nothing happens.", {'{s1}', WHEEL_POSITIONS[wofPigPosition]}}, NEUTRAL_COLOR)
        end
    end
    return nextState('crown')
end

function resolvePlague()
    getActiveFigures()
    while true do
        if currentMiniTurn == nil then
            currentMiniTurn = currentPlayer
        else
            currentMiniTurn = currentMiniTurn + 1
            if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
            if currentMiniTurn == currentPlayer then break end
        end
        local removableFigures = {}
        for featureNum, figures in pairs(activeFigures) do
            if string.sub(featureList[featureNum].nameOfFeature,1,6) ~= 'Crown-' and string.sub(featureList[featureNum].nameOfFeature,1,8) ~= 'Quarter-' then
                for _, follower in ipairs(figures.followers) do
                    if follower.getVar('owner') == activePlayers[currentMiniTurn] then
                        table.insert(removableFigures, follower)
                    end
                end
            end
        end
        if #removableFigures == 0 then
            allGameMessage(activePlayers[currentMiniTurn] .. " did not have any followers in play for the Plague event and was skipped.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
        elseif #removableFigures == 1 then
            allGameMessage(activePlayers[currentMiniTurn] .. " only had 1 follower in play for the Plague event. It was removed.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
            table.insert(removedFigures, {guid=removableFigures[1].getGUID(), winner=false})
            removeDependentFigures(removableFigures[1])
            return returnFigures()
        else
            allGameMessage(activePlayers[currentMiniTurn] .. " must choose a follower to remove for the Plague event.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
            for _, follower in ipairs(removableFigures) do
                local plaguedFollowerButtonParam = {
                   index = 1, label = 'Return\nfollower', click_function = 'plaguedFollowerButton',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0}, width = 1700, height=600, font_size = 200, function_owner = nil
                }
                createNormalizedButton(follower, plaguedFollowerButtonParam, true)
            end
            return
        end
    end
    currentMiniTurn = nil
    return nextState('next')
end

function plaguedFollowerButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        --although we later remove these buttons, there is a slight delay during the figure removal, so we remove them now
        clearArbitraryButtons()

        table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. " was chosen to be removed by the plague.", player_color_tints[object.getVar('owner')])
        removeDependentFigures(object)
        return returnFigures()
    end
end

--Reward points for followers on Wheel of Fortune Crown spaces when the pig lands on it
function rewardCrownSpaces()
    if controlPanelSettings['WoFCrowns'] then
        local crownFollowers = {}
        for featureNum, figures in pairs(activeFigures) do
            if featureList[featureNum] == nil then --FIXME: can remove this debug code if no one complains after a while
                print("ERROR: feature " .. featureNum .. " doesn't exist. This should not happen. Please save the game and send the save file to the dev, thanks!")
                return nextState('next')
            end
            if featureList[featureNum].nameOfFeature == 'Crown-' .. WHEEL_POSITIONS[wofPigPosition] then
                for _, follower in ipairs(figures.followers) do
                    table.insert(crownFollowers, follower)
                end
            end
        end
        if #crownFollowers > 0 then
            local points = 6
            if #crownFollowers > 1 or table.contains({'Fortune', 'Famine', 'Inquisition'}, WHEEL_POSITIONS[wofPigPosition]) then points = 3 end
            for i, follower in ipairs(crownFollowers) do
                allGameMessage({"{c1}'s follower scores {n1} points on the {s1} Crown.", {'{c1}', follower.getVar('owner')}, {'{n1}', points}, {'{s1}', WHEEL_POSITIONS[wofPigPosition]}}, player_color_tints[follower.getVar('owner')])
                scorePoints(follower.getVar('owner'), 'Wheel', points)

                if showMarkers == 'Both' or showMarkers == 'Scoring' then
                    local xIndex = math.floor((follower.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                    local zIndex = math.floor((follower.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                    local xPosition = (follower.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local zPosition = (follower.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local tileRotation = tileGrid[xIndex][zIndex].rotation
                    local closestPosition = findClosestPosition(xPosition, zPosition, tile, tileRotation, true)
                    getFeatureComponents(xIndex, zIndex, closestPosition, 2, i == 1)
                end

                table.insert(removedFigures, {guid=follower.getGUID(), winner=true})
                follower.setLock(false)
                follower.use_gravity = false
                follower.interactable = false
                --raise the follower in the air
                follower.setPositionSmooth({follower.getPosition().x, follower.getPosition().y + 2.5, follower.getPosition().z}, false, false)
            end
            if showMarkers == 'Both' or showMarkers == 'Scoring' then
                Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
            else
                returnFigures()
            end
            return
        end
    end
    return nextState('next')
end

function checkTileForVolcano()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if controlPanelSettings['PnDDragon'] and specialFeature[1] == "Volcano" then
                tileHasVolcano = true
                if not dragonHasAwaken then
                    dragonHasAwaken = true
                    gameNotification({"The dragon has awaken!"}, NEUTRAL_COLOR, activePlayers[currentPlayer])
                end
                return moveDragonToTile(lastPlacedTileX, lastPlacedTileZ)
            end
        end
    end
    return nextState('next')
end

function checkTileForDragon()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if controlPanelSettings['PnDDragon'] and specialFeature[1] == "Dragon" then
                if dragonHasAwaken then
                    dragonMoveNumber = 1
                    dragonIllegalTiles = {}
                    currentMiniTurn = currentPlayer
                    local forbiddenZones = {dragon_GUID}
                    if controlPanelSettings['PnDFairy'] then
                        table.insert(forbiddenZones, fairy_GUID)
                    end
                    if controlPanelSettings['StartingTileCoC'] then
                        table.insert(forbiddenZones, expansionBags['CoC'].contents['CoCStartingTiles'].contents[6].guid)
                        table.insert(forbiddenZones, expansionBags['CoC'].contents['CoCStartingTiles'].contents[7].guid)
                    end
                    if controlPanelSettings['StartingTileWoF'] then
                        table.insert(forbiddenZones, expansionBags['WoF'].contents['WoFStartingTiles'].contents[6].guid)
                        table.insert(forbiddenZones, expansionBags['WoF'].contents['WoFStartingTiles'].contents[7].guid)
                        table.insert(forbiddenZones, expansionBags['WoF'].contents['WoFStartingTiles'].contents[10].guid)
                        table.insert(forbiddenZones, expansionBags['WoF'].contents['WoFStartingTiles'].contents[11].guid)
                    end
                    for _, forbiddenZone_GUID in ipairs(forbiddenZones) do
                        forbiddenZone = getObjectFromGUID(forbiddenZone_GUID)
                        if forbiddenZone ~= nil then
                            local xIndex = math.floor((forbiddenZone.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                            local zIndex = math.floor((forbiddenZone.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                            if tileGridOccupied(xIndex, zIndex) then
                                table.insert(dragonIllegalTiles, {xIndex, zIndex})
                            end
                        end
                    end
                    allGameMessage("The dragon is on the move!", NEUTRAL_COLOR)
                    return nextState('has dragon')
                else
                    allGameMessage("Dragon tile played, but the dragon has not yet awaken.", NEUTRAL_COLOR)
                end
            end
        end
    end
    return nextState('no dragon')
end

function createDragonButtons()
    local dragon = getObjectFromGUID(dragon_GUID)
    local xIndex = math.floor((dragon.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local zIndex = math.floor((dragon.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local hasValidMove = false
    for i=1, 4 do
        local newX = xIndex + SIDE_DELTA[i].x
        local newZ = zIndex + SIDE_DELTA[i].z
        if tileGridOccupied(newX, newZ) and not table.contains(dragonIllegalTiles, {newX, newZ}) then
            hasValidMove = true
            local label
            local click_function
            local font_size = 200
            if i == 1 then
                label = 'V'
                click_function = 'moveDragonDownButton'
                font_size = 120
            elseif i == 2 then
                label = '<'
                click_function = 'moveDragonLeftButton'
            elseif i == 3 then
                label = '^'
                click_function = 'moveDragonUpButton'
            elseif i == 4 then
                label = '>'
                click_function = 'moveDragonRightButton'
            end
            local moveDragonButtonParam = {
               index = i, label = label, click_function = click_function,
               position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=0}, width = 800, height=600, font_size = font_size, function_owner = nil
            }
            createNormalizedArbitraryButton({x=-newX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y + TILE_THICKNESS / 2, z=newZ * TILE_SPACING - MIDDLE_OFFSET.z}, moveDragonButtonParam, false)
        end
    end

    if hasValidMove then
        allGameMessage("Dragon move # " .. dragonMoveNumber .. ". " .. activePlayers[currentMiniTurn] .. "'s turn to move.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
    else
        allGameMessage("Dragon has no valid places to move to. Ending dragon movement.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
        return nextState('next')
    end
end

function moveDragonDownButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        moveDragonDirection(1)
    end
end

function moveDragonLeftButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        moveDragonDirection(2)
    end
end

function moveDragonUpButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        moveDragonDirection(3)
    end
end

function moveDragonRightButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        moveDragonDirection(4)
    end
end

function moveDragonDirection(i)
    clearArbitraryButtons()

    local dragon = getObjectFromGUID(dragon_GUID)
    local dragonXIndex = math.floor((dragon.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local dragonZIndex = math.floor((dragon.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)

    local xIndex = dragonXIndex + SIDE_DELTA[i].x
    local zIndex = dragonZIndex + SIDE_DELTA[i].z

    dragonMoveNumber = dragonMoveNumber + 1
    currentMiniTurn = currentMiniTurn + 1
    table.insert(dragonIllegalTiles, {xIndex, zIndex})
    getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).highlightOn({1,0,0})

    moveDragonToTile(xIndex, zIndex)
end

function moveDragonToTile(xIndex, zIndex)
    local dragon = getObjectFromGUID(dragon_GUID)
    local xDestination = (xIndex * TILE_SPACING) - MIDDLE_OFFSET.x
    local zDestination = (zIndex * TILE_SPACING) - MIDDLE_OFFSET.z

    local dragonTravelAngle = math.deg(math.atan2(dragon.getPosition().x - xDestination, dragon.getPosition().z - zDestination)) + 90
    if dragonTravelAngle > 360 then dragonTravelAngle = dragonTravelAngle - 360 end
    dragon.setLock(false)
    dragon.setRotationSmooth({0, dragonTravelAngle, 0})
    dragon.setPositionSmooth({xDestination, 1.5, zDestination})
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for _, object in ipairs(objs) do
        if object.getVar('figureName') ~= 'Barn' and (table.contains(FOLLOWER_TYPES, object.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, object.getVar('figureName')) or table.contains(SHEEP_TOKEN_TYPES, object.getVar('tokenName'))) then
            if xIndex == math.floor((object.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
               zIndex == math.floor((object.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
               if table.contains(SHEEP_TOKEN_TYPES, object.getVar('tokenName')) then
                   local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
                   if sheepTileBag ~= nil then
                       allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. " have been eaten by the dragon! Om nom nom!", NEUTRAL_COLOR)
                       sheepTileBag.putObject(object)
                   else
                       allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to return sheep tokens")
                   end
               else
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local tileRotation = tileGrid[xIndex][zIndex].rotation
                    local xPosition = (object.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local zPosition = (object.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                    xPosition = xPosition - xIndex
                    zPosition = zPosition - zIndex
                    local closestPosition = findClosestPosition(xPosition, zPosition, tile, tileRotation, true)
                    local nameOfFeature = getFeatureName(tile, closestPosition)
                    if string.sub(nameOfFeature,1,8) ~= 'Quarter-' and nameOfFeature ~= 'Carcassonne' and string.sub(nameOfFeature,1,6) ~= 'Crown-' then
                        --an assumption is made here that there won't be more than 1 figure on the same tile that the figures are dependent on.
                        --It is possible for more than 1 figure from the same player to be on the same tile through use of the magic portal, but not on the same feature.
                        --Therefore, I think the assumption is safe unless there is interference from the players
                        table.insert(removedFigures, {guid=object.getGUID(), winner=false})
                        allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. " has been eaten by the dragon! Om nom nom!", player_color_tints[object.getVar('owner')])
                        removeDependentFigures(object)
                    else
                        allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. " is protected from the dragon in the City of Carcassonne.", player_color_tints[object.getVar('owner')])
                    end
                end
            end
        end
    end
    if #removedFigures > 0 then
        returnFigures()
    else
        nextState('dragon moved')
    end
end

function checkTileForPrincess()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    local tileRotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation
    local specialFeatures = newTile.getTable('specialFeatures')
    if controlPanelSettings['PnDPrincess'] and specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if specialFeature[1] == "Princess" then
                getActiveFigures()
                for _, i in ipairs(specialFeature[2]) do
                    local direction
                    if i < 5 then
                        direction = (3 + i + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
                    elseif i < 13 then
                        direction = (3 + i + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                    else
                        direction = i
                    end
                    local featureNum = featureMap[lastPlacedTileX][lastPlacedTileZ][direction]
                    if activeFigures[featureNum] ~= nil then
                        for _, obj in ipairs(activeFigures[featureNum].followers) do
                            table.insert(seducedKnights, obj.getGUID())
                        end
                    end
                end
            end
        end
    end
    return nextState('next')
end

function checkTileForMagicPortal()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if controlPanelSettings['PnDMagicPortal'] and specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if specialFeature[1] == "Magic Portal" then
                tileHasMagicPortal = true
            end
        end
    end
    return nextState('next')
end

function checkTileForGold()
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    --put another tile underneath it
    local specialFeatures = newTile.getTable('specialFeatures')
    if controlPanelSettings['GoldminesGold'] and specialFeatures ~= nil then
        for _, specialFeature in ipairs(specialFeatures) do
            if specialFeature[1] == "Gold" then
                return nextState('has gold')
            end
        end
    end
    return nextState('next')
end

function addGoldToTile(xIndex, zIndex)
    local goldbag = getObjectFromGUID(expansionBags['Goldmines'].contents['GoldminesGold'].guid)
    if goldbag ~= nil then
        local xDestination = (xIndex * TILE_SPACING) - MIDDLE_OFFSET.x
        local zDestination = (zIndex * TILE_SPACING) - MIDDLE_OFFSET.z

        local params = {}
        params.position = {xDestination, 1.5, zDestination}
        goldbag.takeObject(params)
    else

    end
    nextState('next')
end

function displayGoldButtons()
    for i, offset in ipairs(DIAGONAL_DELTA) do
        local newX = lastPlacedTileX + offset.x
        local newZ = lastPlacedTileZ + offset.z
        if tileGridOccupied(newX, newZ) then
            local placeGoldButtonParam = {
               index = i, label = "Place\nGold", click_function = 'placeGoldButton' .. i,
               position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=0}, width = 800, height=600, font_size = 200, function_owner = nil
            }
            createNormalizedArbitraryButton({x=-newX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y + TILE_THICKNESS / 2, z=newZ * TILE_SPACING - MIDDLE_OFFSET.z}, placeGoldButtonParam, false)
        end
    end
end

function placeGoldButton1(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        placeGold(1)
    end
end

function placeGoldButton2(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        placeGold(2)
    end
end

function placeGoldButton3(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        placeGold(3)
    end
end

function placeGoldButton4(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        placeGold(4)
    end
end

function placeGoldButton5(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        placeGold(5)
    end
end

function placeGoldButton6(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        placeGold(6)
    end
end

function placeGoldButton7(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        placeGold(7)
    end
end

function placeGoldButton8(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        placeGold(8)
    end
end

function placeGold(i)
    clearArbitraryButtons()

    local xIndex = lastPlacedTileX + DIAGONAL_DELTA[i].x
    local zIndex = lastPlacedTileZ + DIAGONAL_DELTA[i].z
    addGoldToTile(xIndex, zIndex)
end

--check for special actions to take when the latest tile has added to or finished a feature
function checkAddedTileFeatureExtensions()
    --check if the new tile has completed the biggest city/longest road and award token
    --Note: you might think that this traversal could be combined with the below traversal, but it didn't work out
    --due to the way that i coded traversedTileCoords. It's a long story, but basically I would have to loop through the entire
    --table for each position on every tile. Had I coded it as an indexable table, I wouldn't be able to use the # operator
    --in order to see how many elements it traversed. Perhaps there is a better solution, but I'm hoping this won't cause any huge performance hits
    local longestNewRoad = 0
    local largestNewCity = 0
    local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
    if newTile.getTable('sides')[1] ~= 'Abbey' then
        local specialFeatures = newTile.getTable('specialFeatures')
        for i=1, 12 do --roads and cities
            -- local direction
            -- if closestPosition < 5 then
            --     direction = (3 + closestPosition + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
            -- elseif closestPosition < 13 then
            --     direction = (3 + closestPosition + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
            -- else
            --     direction = closestPosition
            -- end
            -- local featureNum = featureMap[xIndex][zIndex][direction]
            -- if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(direction * 2) + 3] ~= nil and featureMap[xIndex][zIndex][(direction * 2) + 3] == featureMap[xIndex][zIndex][(direction * 2) + 4] then
            --    featureNum = featureMap[xIndex][zIndex][(direction * 2) + 3]
            -- end
            if (controlPanelSettings['KnRBRobber'] and getFeatureName(newTile, i) == 'Road') or (i >= 5 and controlPanelSettings['KnRBKing'] and getFeatureName(newTile, i) == 'City') then
                if getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, true) == 0 then
                    --since there is a chance of the player breaking the new city or road record twice, wait until afterwards to award the token
                    if getFeatureName(newTile, i) == 'Road' and #traversedTileCoords > longestNewRoad then
                        longestNewRoad = #traversedTileCoords
                    elseif getFeatureName(newTile, i) == 'City' and #traversedTileCoords > largestNewCity then
                        largestNewCity = #traversedTileCoords
                    end
                end
            end
        end
    else --if an abbey was used, then we cannot simply traverse it's features like above in order to find completed features. instead, we traverse the surrounding features
        for i=1, 12 do --roads and cities
            local tile = newTile
            local rotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation
            if i < 5 and controlPanelSettings['KnRBRobber'] then
                local direction = (3 + i + rotation) % 4 + 1
                local newX = lastPlacedTileX + SIDE_DELTA[direction].x
                local newZ = lastPlacedTileZ + SIDE_DELTA[direction].z
                if tileGridOccupied(newX, newZ) then
                    local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                    local newTileRotation = tileGrid[newX][newZ].rotation
                    local newTilePosition = (3 + i + rotation - newTileRotation + TILE_180_ROTATION) % 4 + 1
                    if getFeatureName(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), newTilePosition) == 'Road' then
                        if getFeatureComponents(newX, newZ, newTilePosition, 1, true) == 0 then
                            --since there is a chance of the player breaking the new city or road record twice, wait until afterwards to award the token
                            if #traversedTileCoords > longestNewRoad then
                                longestNewRoad = #traversedTileCoords
                            end
                        end
                    end
                end
            elseif i >= 5 and controlPanelSettings['KnRBKing'] then
                local direction = (3 + i + (rotation * 2)) % 8 + 5
                local newX = lastPlacedTileX + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                local newZ = lastPlacedTileZ + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                if tileGridOccupied(newX, newZ) then
                    local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                    local newTileRotation = tileGrid[newX][newZ].rotation
                    local newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (newTileRotation * 2) - 4) % 8 + 5
                    if getFeatureName(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), newTilePosition) == 'City' then
                        if getFeatureComponents(newX, newZ, newTilePosition, 1, true) == 0 then
                            --since there is a chance of the player breaking the new city record twice, wait until afterwards to award the token
                            if #traversedTileCoords > largestNewCity then
                                largestNewCity = #traversedTileCoords
                            end
                        end
                    end
                end
            end
        end
    end
    if controlPanelSettings['KnRBRobber'] and longestNewRoad > longestRoad then
        longestRoad = longestNewRoad
        local awardToken = getObjectFromGUID(expansionBags['KnRB'].contents['KnRBRobber'].guid)
        local x, z = rotateCoordinates(PLAYER_POSSESSION_POSITIONS['KnRBRobber'].x, PLAYER_POSSESSION_POSITIONS['KnRBRobber'].z, player_possession_areas[activePlayers[currentPlayer]].rotation)
        if awardToken ~= nil then
            awardToken.setPositionSmooth({player_possession_areas[activePlayers[currentPlayer]].x + x, 2, player_possession_areas[activePlayers[currentPlayer]].z + z})
            awardToken.setRotationSmooth({0,  player_possession_areas[activePlayers[currentPlayer]].rotation * -90, 0})
            awardToken.setDescription(longestRoad .. " tiles")
            allGameMessage(activePlayers[currentPlayer] .. " has been awarded the Robber Baron token for completing the longest road (" .. longestRoad .. " tiles)", player_color_tints[activePlayers[currentPlayer]])
        else
            allErrorMessage("Error: Robber Baron token missing! The token needs to remain out in order to awarded")
        end
    end
    if controlPanelSettings['KnRBKing'] and largestNewCity > largestCity then
        largestCity = largestNewCity
        local awardToken = getObjectFromGUID(expansionBags['KnRB'].contents['KnRBKing'].guid)
        local x, z = rotateCoordinates(PLAYER_POSSESSION_POSITIONS['KnRBKing'].x, PLAYER_POSSESSION_POSITIONS['KnRBKing'].z, player_possession_areas[activePlayers[currentPlayer]].rotation)
        if awardToken ~= nil then
            awardToken.setPositionSmooth({player_possession_areas[activePlayers[currentPlayer]].x + x, 2, player_possession_areas[activePlayers[currentPlayer]].z + z})
            awardToken.setRotationSmooth({0,  player_possession_areas[activePlayers[currentPlayer]].rotation * -90, 0})
            awardToken.setDescription(largestCity .. " tiles")
            allGameMessage(activePlayers[currentPlayer] .. " has been awarded the King token for completing the biggest city (" .. largestCity .. " tiles)", player_color_tints[activePlayers[currentPlayer]])
        else
            allErrorMessage("Error: King token missing! The token needs to remain out in order to awarded")
        end
    end

    resetTraversal()
    local specialFeatures = {}

    --check for various completed features, as well as features that have been added to, including:
    --shepherds on fields, builders in cities or on roads, trade tokens in cities that were just completed
    --i can't think of any reason that special features (13+) would need to be checked (yet)

    --need to do cities first, otherwise fields will mark them as visited
    --the above is no longer true after I added traversal levels to getFeatureComponents. I'll leave the code as it is since it doesn't hurt
    --roads and cities
    if newTile.getTable('sides')[1] ~= 'Abbey' then
        for i=1, 12 do
            if getFeatureName(newTile, i) == 'Road' or (i >= 5 and getFeatureName(newTile, i) == 'City') then --not really sure why the i >= 5 check is necessary, but keeping just to be sure
                if getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, false) == 0 then
                    for _, traversedSpecialFeature in ipairs(traversedSpecialFeatures) do
                        table.insert(specialFeatures, traversedSpecialFeature)
                    end
                end
                traversedSpecialFeatures = {}
            end
        end
    else
        for i=1, 12 do
            local tile = newTile
            local rotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation
            local direction, newX, newZ, newTilePosition
            if i < 5 then
                direction = (3 + i + rotation) % 4 + 1
                newX = lastPlacedTileX + SIDE_DELTA[direction].x
                newZ = lastPlacedTileZ + SIDE_DELTA[direction].z
            else
                direction = (3 + i + (rotation * 2)) % 8 + 5
                newX = lastPlacedTileX + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                newZ = lastPlacedTileZ + SIDE_DELTA[math.floor((direction - 3) / 2)].z
            end
            if tileGridOccupied(newX, newZ) then
                local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                local newTileRotation = tileGrid[newX][newZ].rotation

                if direction < 5 then
                    newTilePosition = (3 + i + rotation - newTileRotation + TILE_180_ROTATION) % 4 + 1
                else
                    newTilePosition  = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (newTileRotation * 2) - 4) % 8 + 5
                end

                if getFeatureName(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), newTilePosition) == 'Road' or (i >= 5 and getFeatureName(getObjectFromGUID(tileGrid[newX][newZ].tile_guid), newTilePosition) == 'City') then
                    if getFeatureComponents(newX, newZ, newTilePosition, 1, false) == 0 then
                        for _, traversedSpecialFeature in ipairs(traversedSpecialFeatures) do
                            table.insert(specialFeatures, traversedSpecialFeature)
                        end
                    end
                    traversedSpecialFeatures = {}
                end
            end
        end
    end

    -- currently there is no reason to check fields, since I moved the shepherd/builder check to another part of the state machine
    -- there technically isn't a need to check roads either, but it shouldn't hurt too much so I'll leave it in
    -- for i=5, 12 do --fields
    --     if getFeatureName(newTile, i) ~= 'City' then
    --         getFeatureComponents(lastPlacedTileX, lastPlacedTileZ, i, 1, false)
    --     end
    -- end

    if controlPanelSettings['TnBTradeGoods'] then
        for _, specialFeature in ipairs(specialFeatures) do
            local tradeGoodPile
            local x, z

            if specialFeature == 'Cloth' then
                tradeGoodPile = getObjectFromGUID(expansionBags['TnB'].contents['TnBClothTokenStack'].guid)
                x, z = rotateCoordinates(PLAYER_POSSESSION_POSITIONS['Cloth'].x, PLAYER_POSSESSION_POSITIONS['Cloth'].z, player_possession_areas[activePlayers[currentPlayer]].rotation)
            elseif specialFeature == 'Wine' then
                tradeGoodPile = getObjectFromGUID(expansionBags['TnB'].contents['TnBWineTokenStack'].guid)
                x, z = rotateCoordinates(PLAYER_POSSESSION_POSITIONS['Wine'].x, PLAYER_POSSESSION_POSITIONS['Wine'].z, player_possession_areas[activePlayers[currentPlayer]].rotation)
            elseif specialFeature == 'Wheat' then
                tradeGoodPile = getObjectFromGUID(expansionBags['TnB'].contents['TnBWheatTokenStack'].guid)
                x, z = rotateCoordinates(PLAYER_POSSESSION_POSITIONS['Wheat'].x, PLAYER_POSSESSION_POSITIONS['Wheat'].z, player_possession_areas[activePlayers[currentPlayer]].rotation)
            end

            if table.contains(TRADE_GOOD_TYPES, specialFeature) then
                if tradeGoodPile ~= nil then
                    local params = {}
                    params.position = {player_possession_areas[activePlayers[currentPlayer]].x + x, 2, player_possession_areas[activePlayers[currentPlayer]].z + z}
                    params.rotation = {0,  player_possession_areas[activePlayers[currentPlayer]].rotation * -90, 0}
                    tradeGoodPile.takeObject(params)
                    allGameMessage(activePlayers[currentPlayer] .. " has been awarded a " .. specialFeature .. " for completing the city", player_color_tints[activePlayers[currentPlayer]])
                else
                    allErrorMessage("Error: " .. specialFeature .. " pile missing! The pile needs to remain out in order to draw trade goods")
                end
            end
        end
    end
    return nextState('next')
end

--events that should occur after placing a valid tile
function displayFigureButtons()
    local labelButtonParam = {
       index = 1, label = 'Place a figure\nOR', click_function = 'doNothing',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=1.8}, width = 0, height=0, font_size = 200, function_owner = nil
    }
    createNormalizedArbitraryButton({x=-lastPlacedTileX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y + TILE_THICKNESS / 2, z=lastPlacedTileZ * TILE_SPACING - MIDDLE_OFFSET.z}, labelButtonParam, true)
    local skipFigureButtonParam = {
       index = 2, label = 'Skip placing\nfigure', click_function = 'skipFigureButton',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=2.5}, width = 1400, height=600, font_size = 200, function_owner = nil
    }
    createNormalizedArbitraryButton({x=-lastPlacedTileX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y + TILE_THICKNESS / 2, z=lastPlacedTileZ * TILE_SPACING - MIDDLE_OFFSET.z}, skipFigureButtonParam, true)
    for _, knight in ipairs(seducedKnights) do
        local seduceKnightButtonParam = {
           index = 1, label = 'Seduce\nknight', click_function = 'seduceKnightButton',
           position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0}, width = 1700, height=600, font_size = 200, function_owner = nil
        }
        createNormalizedButton(getObjectFromGUID(knight), seduceKnightButtonParam, true)
    end
    for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
        if obj.getVar('figureName') == 'Abbot' and obj.getVar('owner') == activePlayers[currentPlayer] then
            local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            if tileGridOccupied(xIndex, zIndex) then
                local retrieveAbbotButtonParam = {
                   index = 1, label = 'Retrieve\nabbot', click_function = 'retrieveAbbotButton',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0}, width = 1400, height=600, font_size = 200, function_owner = nil
                }
                createNormalizedButton(obj, retrieveAbbotButtonParam, true)
                currentPlayerAbbot = obj.getGUID()
                return --there shouldn't be multiple abbots for each player, but stop just in case
            end
        end
    end
end

--creates a button, which is rotated according to the object's current rotation, so that the buttons always face up and towards the active player
function createNormalizedButton(obj, params, rotateToPlayer, customRotation)
    local player = activePlayers[currentPlayer]
    if currentMiniTurn ~= nil then
        player = activePlayers[currentMiniTurn]
    end
    if controlPanelSettings[player .. 'Control'] ~= nil then
        player = controlPanelSettings[player .. 'Control']
    end
    --default rotation is 180 degrees
    local playerRotation = 2
    local x, z
    if customRotation ~= nil then
        playerRotation = customRotation
        x, z = rotateCoordinates(params.position.x, params.position.z, customRotation)
    else
        if rotateToPlayer then
            playerRotation = player_possession_areas[player].rotation
        end
        x, z = rotateCoordinates(params.position.x, params.position.z, ((-playerRotation + 7) % 4) + 1)
    end
    params.position = {x=x, y=params.position.y, z=z}
    local pos = obj.getPosition()
    pos.x = pos.x + params.position.x
    pos.y = pos.y + params.position.y
    pos.z = pos.z + params.position.z
    pos = obj.positionToLocal(pos)
    params.position = {x=-pos.x, y=pos.y, z=pos.z}
    params.scale = {x=1/obj.getScale().x / 2, y=1/obj.getScale().y, z=1/obj.getScale().z / 2}

    local rotation = -obj.getRotation().y - (playerRotation * 90)
    --this method is currently bugged(?)
    --local rotation = (obj.getRotation().y * -1) + (Player[player].getPointerRotation())
    while rotation < 0 do rotation = rotation + 360 end
    params.rotation = {x=obj.getRotation().x, y=rotation, z=-obj.getRotation().z}
    obj.createButton(params)
end

function createNormalizedArbitraryButton(pivot_point, params, rotateToPlayer)
    local player = activePlayers[currentPlayer]
    if currentMiniTurn ~= nil then
        player = activePlayers[currentMiniTurn]
    end
    if controlPanelSettings[player .. 'Control'] ~= nil then
        player = controlPanelSettings[player .. 'Control']
    end
    --default rotation is 180 degrees
    local playerRotation = 2
    if rotateToPlayer then
        playerRotation = player_possession_areas[player].rotation
    end
    local x, z = rotateCoordinates(params.position.x, params.position.z, ((-playerRotation + 7) % 4) + 1)
    --params.position = {x=x, y=params.position.y, z=z}
    params.position = {x=x + pivot_point.x, y=params.position.y + pivot_point.y, z=z + pivot_point.z}

    local rotation = -(playerRotation * 90)
    --this method is currently bugged(?)
    --local rotation = (obj.getRotation().y * -1) + (Player[player].getPointerRotation())
    while rotation < 0 do rotation = rotation + 360 end
    params.rotation = {x=0, y=rotation, z=0}
    params.scale = {x=0.5, y=1.0, z=0.5}

    getObjectFromGUID(BUTTON_ANCHOR_GUID).createButton(params)
end

--dummy function for dummy button
function doNothing()
end

function skipFigureButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        return nextState('skip figure')
    end
end

function seduceKnightButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        --although we later remove these buttons, there is a slight delay during the figure removal, so we remove them now
        clearArbitraryButtons()

        table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        if object.getVar('figureName') == 'Wagon' then
            allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. " has been seduced by the princess! Well not the wagon but the wagon crew... all of them... wow. Let's move on and forget this.", player_color_tints[object.getVar('owner')])
        else
            allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. " has been seduced by the princess! bow chicka wow wow~", player_color_tints[object.getVar('owner')])
        end
        removeDependentFigures(object)
        return nextState('seduce knight')
    end
end

function retrieveAbbotButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local xIndex = math.floor((object.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((object.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
            local xPosition = (object.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
            local zPosition = (object.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
            xPosition = xPosition - xIndex
            zPosition = zPosition - zIndex
            local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
            local rotation = tileGrid[xIndex][zIndex].rotation
            local closestPosition = findClosestPosition(xPosition, zPosition, tile, rotation, true)
            local nameOfFeature = getFeatureName(tile, closestPosition)
            getFeatureComponents(xIndex, zIndex, closestPosition, 2, true)
            if nameOfFeature == 'Garden' or nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                score = #traversedTileCoords
                allGameMessage(object.getVar('owner') .. " retrieves their abbot back for " .. score .. " points on " .. nameOfFeature, player_color_tints[object.getVar('owner')]) -- .. " with a strength of " .. value .. " followers", player_color_tints[player])
                scorePoints(object.getVar('owner'), nameOfFeature, score)
                table.insert(removedFigures, {guid=object.getGUID(), winner=true})
                object.setLock(false)
                object.use_gravity = false
                object.interactable = false
                --raise the follower in the air
                object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)

                if showMarkers == 'Both' or showMarkers == 'Scoring' then
                    Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                else
                    returnFigures()
                end
                clearFigureOptions()
                return nextState('retrieve abbot')
            end
        end
    end
    allErrorMessage("Error: The abbot is currently on an invalid feature. Abbots can only be placed on gardens and cloisters.", activePlayers[currentPlayer])
end

function promptTowerCapture()
	local towerRange = numberActiveTowers
    if controlPanelSettings['TowersNerfTower'] then
		towerRange = numberActiveTowers - 1
	end
    getObjectFromGUID(tileGrid[towerX][towerZ].tile_guid).highlightOn({1,0,0})
	if towerRange > 0 then
		for i=1, towerRange do
			for side, sideDelta in pairs(SIDE_DELTA) do
				if tileGridOccupied(towerX + sideDelta.x * i, towerZ + sideDelta.z * i) then
					getObjectFromGUID(tileGrid[towerX + sideDelta.x * i][towerZ + sideDelta.z * i].tile_guid).highlightOn({1,0,0})
				end
			end
		end
	end
    local hasFollower = false
    capturableFollowers = {}
    for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
        if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) then
            local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
			if tileGridOccupied(xIndex, zIndex) then
                if (xIndex == towerX and zIndex <= towerZ + towerRange and zIndex >= towerZ - towerRange) or (zIndex == towerZ and xIndex <= towerX + towerRange and xIndex >= towerX - towerRange) then
                    local captureFollowerButtonParam = {
                       index = 1, label = 'Capture\n' .. obj.getName(), click_function = 'captureFollowerButton',
                       position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0}, width = 1100, height=600, font_size = 200, function_owner = nil
                    }
                    table.insert(capturableFollowers, obj.getGUID())
                    createNormalizedButton(obj, captureFollowerButtonParam, true)
                    hasFollower = true
                end
            end
        end
    end
    if hasFollower then
        local skipCaptureButtonParam = {
           index = 2, label = 'Skip capturing\nfollower', click_function = 'skipCaptureButton',
           position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=1.5}, width = 1400, height=600, font_size = 200, function_owner = nil
        }
        createNormalizedArbitraryButton({x=-towerX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y + TILE_THICKNESS / 2, z=towerZ * TILE_SPACING - MIDDLE_OFFSET.z}, skipCaptureButtonParam, true)
    else
        return nextState('skip capture')
    end
end

function captureFollowerButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        --although we later remove these buttons, there is a slight delay during the figure removal, so we remove them now
        clearArbitraryButtons(true)
        for _, follower in ipairs(capturableFollowers) do
            getObjectFromGUID(follower).clearButtons()
        end

        removeDependentFigures(object)
        if object.getVar('owner') == activePlayers[currentPlayer] then
            table.insert(removedFigures, {guid=object.getGUID(), winner=false})
            allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. " was captured by its owner and returned to supply.", player_color_tints[object.getVar('owner')])
            return nextState('return follower')
        else
            local x, z = rotateCoordinates(PLAYER_POSSESSION_POSITIONS['CapturedFollower'].x, PLAYER_POSSESSION_POSITIONS['CapturedFollower'].z, player_possession_areas[activePlayers[currentPlayer]].rotation)
            x = player_possession_areas[activePlayers[currentPlayer]].x + x
            z = player_possession_areas[activePlayers[currentPlayer]].z + z
            local prisoners = getPrisoners()
            for i=1, 6 do
                local prisonerInThisSpot = false
                for _, prisoner in ipairs(prisoners[activePlayers[currentPlayer]]) do
                    local vPos = prisoner.getPosition()
                    local vPosX = vPos.x
                    local vPosZ = vPos.z
                    local dX = x - vPosX
                    local dZ = z - vPosZ
                    if dX<0.5 and dX>-0.5 and dZ<0.5 and dZ>-0.5 then
                        prisonerInThisSpot = true
                    end
                end
                if not prisonerInThisSpot then break end
                x = x + PLAYER_POSSESSION_SPACING
            end
            object.setLock(false)
            object.setPositionSmooth({x, 2, z})
            object.setRotationSmooth({0,  player_possession_areas[activePlayers[currentPlayer]].rotation * -90, 0})
            allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. RGBToBracketedHex(NEUTRAL_COLOR) .. " has been captured by " .. RGBToBracketedHex(player_color_tints[activePlayers[currentPlayer]]) .. activePlayers[currentPlayer], player_color_tints[object.getVar('owner')])
            return nextState('capture follower')
        end
    end
end

function skipCaptureButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        return nextState('skip capture')
    end
end

function createRansomButtons()
    allPrisoners = getPrisoners()
    for player, prisoners in pairs(allPrisoners) do
        for _, prisoner in ipairs(prisoners) do
            if prisoner.getVar('owner') == activePlayers[currentPlayer] then
                local ransomFollowerButtonParam = {
                   index = 1, label = 'Ransom\n' .. prisoner.getName(), click_function = 'ransomFollowerButton',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0}, width = 1100, height=600, font_size = 200, function_owner = nil
                }
                local rotation = player_possession_areas[player].rotation + 2
                if rotation > 3 then rotation = rotation - 4 end
                createNormalizedButton(prisoner, ransomFollowerButtonParam, false, rotation)
            end
        end
    end
end

function ransomFollowerButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local captor = nil
        for player, prisoners in pairs(allPrisoners) do
            for _, prisoner in ipairs(prisoners) do
                if object == prisoner then
                    captor = player
                end
                prisoner.clearButtons()
            end
        end
        table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        scorePoints(activePlayers[currentPlayer], 'Ransom', -3)
        if captor ~= nil then
            scorePoints(captor, 'Ransom', 3)
            allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. " was ransomed from " .. captor .. " for 3 points and returned to supply.", player_color_tints[object.getVar('owner')])
        else
            allErrorMessage("ERROR: Could not find the captor of the prisoner.")
        end
        return returnFigures(true)
    end
end

function getPrisoners()
    local prisoners = {}
    for _, player in ipairs(activePlayers) do
        prisoners[player] = {}
        local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
        local playerNumTokens = 0
        for _, obj in ipairs(playerPossessions) do
            if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) and obj.getVar('owner') ~= player then
                table.insert(prisoners[player], obj)
            end
        end
    end
    return prisoners
end

function exchangePrisoners()
    local prisoners = getPrisoners()
    prisonersOfOtherPlayer = {}
    if(prisoners[activePlayers[currentPlayer]][1] ~= nil and #prisoners[prisoners[activePlayers[currentPlayer]][1].getVar('owner')] ~= 0) then
        for _, prisoner in ipairs(prisoners[prisoners[activePlayers[currentPlayer]][1].getVar('owner')]) do
            if prisoner.getVar('owner') == activePlayers[currentPlayer] then
                table.insert(prisonersOfOtherPlayer, prisoner)
            end
        end
    end
    if #prisonersOfOtherPlayer == 0 then
        prisoners[activePlayers[currentPlayer]][1].setLock(true)
        return nextState('next')
    elseif #prisonersOfOtherPlayer == 1 then
        prisoners[activePlayers[currentPlayer]][1].clearButtons()
        prisonersOfOtherPlayer[1].clearButtons()
        table.insert(removedFigures, {guid=prisoners[activePlayers[currentPlayer]][1].getGUID(), winner=false})
        table.insert(removedFigures, {guid=prisonersOfOtherPlayer[1].getGUID(), winner=false})
        allGameMessage(prisoners[activePlayers[currentPlayer]][1].getVar('owner') .. RGBToBracketedHex(NEUTRAL_COLOR) .. ' and ' .. RGBToBracketedHex(player_color_tints[activePlayers[currentPlayer]]) .. activePlayers[currentPlayer] .. RGBToBracketedHex(NEUTRAL_COLOR) .. " return each others' followers", player_color_tints[prisoners[activePlayers[currentPlayer]][1].getVar('owner')])
        return nextState('return followers')
    else
        prisoners[activePlayers[currentPlayer]][1].clearButtons()
        table.insert(removedFigures, {guid=prisoners[activePlayers[currentPlayer]][1].getGUID(), winner=false})
        allGameMessage(activePlayers[currentPlayer] .. ' must choose a prisoner from ' .. prisoners[activePlayers[currentPlayer]][1].getVar('owner') .. ' to exchange for ', player_color_tints[activePlayers[currentPlayer]])
        for _, prisoner in ipairs(prisonersOfOtherPlayer) do
            prisoner.clearButtons()
            local returnFollowerButtonParam = {
               index = 1, label = 'Return\n' .. prisoner.getName(), click_function = 'returnFollowerButton',
               position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0}, width = 1700, height=600, font_size = 200, function_owner = nil
            }
            createNormalizedButton(prisoner, returnFollowerButtonParam, true)
        end
    end
end

function returnFollowerButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        --although we later remove these buttons, there is a slight delay during the figure removal, so we remove them now
        clearArbitraryButtons(true)
        for _, prisoner in ipairs(prisonersOfOtherPlayer) do
            prisoner.clearButtons()
        end

        table.insert(removedFigures, {guid=object.getGUID(), winner=false})
        allGameMessage(object.getDescription() .. (object.getDescription() ~= "" and " " or "") .. object.getName() .. " was returned to its owner in exchange for a prisoner", player_color_tints[object.getVar('owner')])
        return nextState('return followers')
    end
end

--adds any special figures that were dependent on this figure to the removed figure list
function removeDependentFigures(object)
    local xIndex = math.floor((object.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local zIndex = math.floor((object.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local xPosition = (object.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
    local zPosition = (object.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
    xPosition = xPosition - xIndex
    zPosition = zPosition - zIndex
    if(tileGrid[xIndex] == nil or tileGrid[xIndex][zIndex] == nil) then
      allErrorMessage("ERROR: No tile detected at this figure. Was it moved? You may need to manually recover from this.", activePlayers[currentPlayer])
      return
    end
    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
    local rotation = tileGrid[xIndex][zIndex].rotation
    local closestPosition = findClosestPosition(xPosition, zPosition, tile, rotation, true)
    getFeatureComponents(xIndex, zIndex, closestPosition, 2, true)
    local followersCount = 0
    for _, follower in ipairs(traversedFollowers) do
        if follower.getGUID() ~= object.getGUID() and follower.getVar('owner') == object.getVar('owner') then
            followersCount = followersCount + 1
        end
    end
    if followersCount == 0 then
        for _, figure in ipairs(traversedSpecialFigures) do
            if (figure.getVar('figureName') == 'Pig' or figure.getVar('figureName') == 'Builder') and figure.getVar('owner') == object.getVar('owner') then
                table.insert(removedFigures, {guid=figure.getGUID(), winner=false})
                allGameMessage(figure.getVar('owner') .. " no longer has a follower for their " .. figure.getName() .. " and must be removed.", player_color_tints[figure.getVar('owner')])
            end
        end
    end
end

function clearFigureOptions()
    clearArbitraryButtons(true)
    if flierOffset ~= nil and tileGrid[lastPlacedTileX + flierOffset.x] ~= nil and tileGrid[lastPlacedTileX + flierOffset.x][lastPlacedTileZ + flierOffset.z] ~= nil then
        local possibleTile = getObjectFromGUID(tileGrid[lastPlacedTileX + flierOffset.x][lastPlacedTileZ + flierOffset.z].tile_guid)
        if possibleTile ~= nil then
            possibleTile.highlightOff()
        end
    end
    local fairy = getObjectFromGUID(fairy_GUID)
    if controlPanelSettings['PnDFairy'] and fairy ~= nil then
        fairy.setLock(true)
        fairy.highlightOff()
    end
end

function clearArbitraryButtons(alsoClearHighlights)
    local prisoners = getPrisoners()
    for _, object in ipairs(getAllObjects()) do
        if tostring(object) == 'Card(Clone) (LuaGameObjectScript)' then
            if alsoClearHighlights then
                object.highlightOff()
            end
            object.clearButtons()
        elseif table.contains(FOLLOWER_TYPES, object.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, object.getVar('figureName')) then
            local isPrisoner = false
            for player, prisoners in pairs(allPrisoners) do
                for _, prisoner in ipairs(prisoners) do
                    if prisoner == object then
                        isPrisoner = true
                        break
                    end
                end
            end
            if not isPrisoner then
                object.highlightOff()
                object.clearButtons()
            end
        end
    end
    if alsoClearHighlights then
        highlightLastPlacedTiles()
    end
    if lastPlacedTileX ~= nil then
        getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).clearButtons()
    end
    if currentPlayerAbbot ~= nil then
        getObjectFromGUID(currentPlayerAbbot).clearButtons()
    end
    for _, knight in ipairs(seducedKnights) do
        getObjectFromGUID(knight).clearButtons()
    end
    if shepherdAwaitingAction ~= nil then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        shepherd.clearButtons()
    end
    getObjectFromGUID(BUTTON_ANCHOR_GUID).clearButtons()
    for _, buttonAnchor in ipairs(arbitraryButtonAnchors) do
        buttonAnchor.destruct()
    end
    arbitraryButtonAnchors = {}
end

function highlightLastPlacedTiles()
    for player, coordinates in pairs(lastPlacedPlayerTiles) do
        if tileGridOccupied(coordinates.x, coordinates.z) then
            local tile = getObjectFromGUID(tileGrid[coordinates.x][coordinates.z].tile_guid)
            tile.highlightOn(player_color_tints[player])
        end
    end
end

function promptShepherd()
    -- local shepherdExpandButtonParam = {
    --    index = 1, label = 'Expand the\nflock', click_function = 'addSheepToFlockButton',
    --    position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.5}, width = 1400, height=700, font_size = 200, function_owner = nil
    -- }
    -- local shepherdHerdButtonParam = {
    --    index = 2, label = 'Herd the flock\ninto the stable', click_function = 'scoreFlockButton',
    --    position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=2.3}, width = 1400, height=700, font_size = 200, function_owner = nil
    -- }
    local shepherdExpandButtonParam = {
       index = 1, label = 'Expand the\nflock', click_function = 'addSheepToFlockButton',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=1.5}, width = 1400, height=700, font_size = 200, function_owner = nil
    }
    local shepherdHerdButtonParam = {
       index = 2, label = 'Herd the flock\ninto the stable', click_function = 'scoreFlockButton',
       position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=2.3}, width = 1400, height=700, font_size = 200, function_owner = nil
    }
    local shepherd = getObjectFromGUID(shepherdAwaitingAction)
    createNormalizedButton(shepherd, shepherdExpandButtonParam, true)
    createNormalizedButton(shepherd, shepherdHerdButtonParam, true)
    allGameMessage(activePlayers[currentPlayer] .. " added to their Shepherd's field and has an opportunity to expand their flock", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
    return
end

function addSheepToFlockButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        clearArbitraryButtons()
        if controlPanelSettings['PnDDragon'] then
            addSheepToTile(shepherd)
        else
            addSheepToField(shepherd)
        end
    end
end

function addSheepToField(shep)
    shepherd = shep
    --startLuaCoroutine(self, 'scoreFlockCoroutine')

    local CoNew = coroutine.create(addSheepToFieldCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--will go through all possible locations on the field and find an empty spot where the sheep tile can be put
--Note: according to this forum post, this behavior actually violates the rules: https://boardgamegeek.com/thread/1434965/question-about-location-sheep-tokens
--At first, I thought I could get around this by making the dragon not eat the sheep, but in the event that multiple fields are joined together, there needs to be a way to separate the different sheep groups
--We can still use it for games that do not include the dragon, because I think it looks nicer
function addSheepToFieldCoroutine()
    --no error checking for the shepherd. Assume that it is still in a legal position
    local shepherdTileXIndex = math.floor((shepherd.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local shepherdTileZIndex = math.floor((shepherd.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local shepherdxPosition = (shepherd.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
    local shepherdzPosition = (shepherd.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
    shepherdxPosition = shepherdxPosition - shepherdTileXIndex
    shepherdzPosition = shepherdzPosition - shepherdTileZIndex
    local shepherdClosestPosition = findClosestPosition(shepherdxPosition, shepherdzPosition, getObjectFromGUID(tileGrid[shepherdTileXIndex][shepherdTileZIndex].tile_guid), tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation, true)
    getFeatureComponents(shepherdTileXIndex, shepherdTileZIndex, shepherdClosestPosition, 1, true)
    --now that we've traversed for this shepherd, check all positions in the field for an open spot
    for _, traversedTileCoord in ipairs(traversedTileCoords) do
        if traversedFeaturePositions[traversedTileCoord.x] ~= nil and traversedFeaturePositions[traversedTileCoord.x][traversedTileCoord.z] ~= nil then
            for location, traversedFeaturePosition in pairs(traversedFeaturePositions[traversedTileCoord.x][traversedTileCoord.z]) do
                if location > 4 and location < 13 and traversedFeaturePosition == 1 then
                    local occupied = false
                    --debugMessage(1, "checking x: " .. traversedTileCoord.x .. " z: " .. traversedTileCoord.z .. " location: " .. location .. " for empty sheep location")
                    for _, figureSet in ipairs({traversedFollowers, traversedSheepTokens, traversedSpecialFigures}) do
                        for _, figure in ipairs(figureSet) do
                            local xIndex = math.floor((figure.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                            local zIndex = math.floor((figure.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                            if xIndex == traversedTileCoord.x and zIndex == traversedTileCoord.z then
                                local xPosition = (figure.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                                local zPosition = (figure.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                                xPosition = xPosition - xIndex
                                zPosition = zPosition - zIndex
                                local x, z = getFeatureLocation(location, getObjectFromGUID(tileGrid[traversedTileCoord.x][traversedTileCoord.z].tile_guid), tileGrid[traversedTileCoord.x][traversedTileCoord.z].rotation)
                                if ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) < 0.1 then
                                    --debugMessage(2, "Too close to sheep location (" .. ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) .. ")")
                                    occupied = true
                                    break
                                end
                            end
                        end
                    end
                    if not occupied then
                        local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
                        if sheepTileBag ~= nil then
                            local params = {}
                            local x, z = getFeatureLocation(location, getObjectFromGUID(tileGrid[traversedTileCoord.x][traversedTileCoord.z].tile_guid), tileGrid[traversedTileCoord.x][traversedTileCoord.z].rotation)
                            params.position = {x=(x * TILE_SPACING) + (traversedTileCoord.x * TILE_SPACING) - MIDDLE_OFFSET.x, y=1.5, z=(z * TILE_SPACING) + (traversedTileCoord.z * TILE_SPACING) - MIDDLE_OFFSET.z}

                            local direction = (3 + location + (tileGrid[traversedTileCoord.x][traversedTileCoord.z].rotation * 2)) % 8 + 5
                            params.position.x = params.position.x - (SIDE_DELTA[math.floor((direction - 3) / 2)].x * 0.1 * TILE_SPACING)
                            params.position.z = params.position.z - (SIDE_DELTA[math.floor((direction - 3) / 2)].z * 0.1 * TILE_SPACING)

                            params.callback_owner = Global
                            params.callback = "drawingSheepUnlock"

                            sheepTileBag.shuffle()
                            drawingSheepLock = true
                            local newTile = sheepTileBag.takeObject(params)
                            while drawingSheepLock do
                                coroutine.yield(0)
                            end
                            if newTile.getVar('tokenName') == "Wolf" then
                                Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='scoreFlock', function_owner=nil, parameters={shepherd=shepherd}, delay=1.0})
                            else
                                Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=1.0})
                            end
                            return
                        else
                            allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to draw sheep tokens")
                            return
                        end
                    end
                end
            end
        end
    end
    gameNotification("No more room on field! Placing sheep on shepherd", NEUTRAL_COLOR, activePlayers[currentPlayer])
    addSheepToShepherd(shepherd)
end

function addSheepToTile(shep)
    shepherd = shep
    --startLuaCoroutine(self, 'scoreFlockCoroutine')

    local CoNew = coroutine.create(addSheepToTileCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--adds a sheep to the tile that the shepherd is on, if there is room
function addSheepToTileCoroutine()
    --no error checking for the shepherd. Assume that it is still in a legal position
    local shepherdTileXIndex = math.floor((shepherd.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
    local shepherdTileZIndex = math.floor((shepherd.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
    local tile = getObjectFromGUID(tileGrid[shepherdTileXIndex][shepherdTileZIndex].tile_guid)
    local rotation = tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation
    local shepherdxPosition = (shepherd.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
    local shepherdzPosition = (shepherd.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
    shepherdxPosition = shepherdxPosition - shepherdTileXIndex
    shepherdzPosition = shepherdzPosition - shepherdTileZIndex
    local shepherdClosestPosition = findClosestPosition(shepherdxPosition, shepherdzPosition, getObjectFromGUID(tileGrid[shepherdTileXIndex][shepherdTileZIndex].tile_guid), tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation, true)
    for _, linkedOctants in pairs(tile.getTable('linkedOctants')) do
        if table.contains(linkedOctants, shepherdClosestPosition) then
            for _, location in pairs(linkedOctants) do
                local x, z = getFeatureLocation(location, tile, rotation)
                local occupied = false
                local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                for _, object in ipairs(objs) do
                    if table.contains(FOLLOWER_TYPES, object.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, object.getVar('figureName')) or
                    table.contains(NEUTRAL_FIGURE_TYPES, object.getVar('figureName')) or table.contains(SHEEP_TOKEN_TYPES, object.getVar('tokenName')) then
                        local xIndex = math.floor((object.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                        local zIndex = math.floor((object.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                        if xIndex == shepherdTileXIndex and zIndex == shepherdTileZIndex then
                            local xPosition = (object.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                            local zPosition = (object.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                            xPosition = xPosition - xIndex
                            zPosition = zPosition - zIndex
                            if ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) < 0.1 then
                                --debugMessage(2, "Too close to sheep location (" .. ((xPosition - x) * (xPosition - x)) + ((zPosition - z) * (zPosition - z)) .. ")")
                                occupied = true
                                break
                            end
                        end
                    end
                end
                if not occupied then
                    local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
                    if sheepTileBag ~= nil then
                        local params = {}
                        params.position = {x=(x * TILE_SPACING) + (shepherdTileXIndex * TILE_SPACING) - MIDDLE_OFFSET.x, y=1.5, z=(z * TILE_SPACING) + (shepherdTileZIndex * TILE_SPACING) - MIDDLE_OFFSET.z}

                        local direction = (3 + location + (tileGrid[shepherdTileXIndex][shepherdTileZIndex].rotation * 2)) % 8 + 5
                        params.position.x = params.position.x - (SIDE_DELTA[math.floor((direction - 3) / 2)].x * 0.1 * TILE_SPACING)
                        params.position.z = params.position.z - (SIDE_DELTA[math.floor((direction - 3) / 2)].z * 0.1 * TILE_SPACING)

                        params.callback_owner = Global
                        params.callback = "drawingSheepUnlock"

                        sheepTileBag.shuffle()
                        drawingSheepLock = true
                        local newTile = sheepTileBag.takeObject(params)
                        while drawingSheepLock do
                            coroutine.yield(0)
                        end
                        if newTile.getVar('tokenName') == "Wolf" then
                            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='scoreFlock', function_owner=nil, parameters={shepherd=shepherd}, delay=1.0})
                        else
                            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=1.0})
                        end
                        return
                    else
                        allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to draw sheep tokens")
                        return
                    end
                end
            end
        end
    end
    gameNotification("No more room on field! Placing sheep on shepherd", NEUTRAL_COLOR, activePlayers[currentPlayer])
    addSheepToShepherd(shepherd)
end

--if there is no room to add a sheep to a field, it will be placed on the shepherd's head
function addSheepToShepherd(shepherd)
    local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
    if sheepTileBag ~= nil then
        local params = {}
        params.position = {shepherd.getPosition().x, shepherd.getPosition().y + 2, shepherd.getPosition().z}

        params.callback_owner = Global
        params.callback = "drawingSheepUnlock"

        sheepTileBag.shuffle()
        drawingSheepLock = true
        local newTile = sheepTileBag.takeObject(params)
        while drawingSheepLock do
            coroutine.yield(0)
        end
        if newTile.getVar('tokenName') == "Wolf" then
            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='scoreFlock', function_owner=nil, parameters={shepherd=shepherd}, delay=1.0})
        else
            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='progressState', function_owner=nil, parameters=nil, delay=1.0})
        end
    else
        allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to draw sheep tokens")
    end
end

--unlocks the coroutine that drew the sheep, so that it can check the variables on the now-loaded token
function drawingSheepUnlock()
    drawingSheepLock = false
end

function scoreFlockButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        local shepherd = getObjectFromGUID(shepherdAwaitingAction)
        clearArbitraryButtons()
        local params = {}
        params.shepherd = shepherd
        scoreFlock(params)
    end
end

function scoreFlock(params)
    shepherd = params.shepherd
    --startLuaCoroutine(self, 'scoreFlockCoroutine')

    local CoNew = coroutine.create(scoreFlockCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

function scoreFlockCoroutine()
    local sheepTileBag = getObjectFromGUID(expansionBags['HnS'].contents['HnSSheepBag'].guid)
    if sheepTileBag ~= nil then
        local xIndex = math.floor((shepherd.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((shepherd.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        local xPosition = (shepherd.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
        local zPosition = (shepherd.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
        xPosition = xPosition - xIndex
        zPosition = zPosition - zIndex
        local closestPosition = findClosestPosition(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation, true)
        --only need a traversal level of 1, since we don't care about completed cities on the field
        getFeatureComponents(xIndex, zIndex, closestPosition, 1, true)
        local score = 0
        local hasWolf = false

        for _, token in ipairs(traversedSheepTokens) do
            if token.getVar('tokenName') == 'Sheep' then
                score = score + token.getVar('count')
            elseif token.getVar('tokenName') == 'Wolf' then
                hasWolf = true
            end
            sheepTileBag.putObject(token)
        end
        for _, feature in ipairs(traversedSpecialFeatures) do
            if feature == 'Sheep' then
                score = score + 1
                break
            end
        end
        if hasWolf then score = 0 end
        for _, figure in ipairs(traversedSpecialFigures) do
            if figure.getVar('figureName') == 'Shepherd' then
                local winner
                if score > 0 then winner = true else winner = false end
                table.insert(removedFigures, {guid=figure.getGUID(), winner=winner})
                if not hasWolf then
                    allGameMessage(figure.getVar('owner') .. "'s Shepherd scores " .. score .. " points for " .. score .. " sheep.", player_color_tints[figure.getVar('owner')])
                else
                    allGameMessage(figure.getVar('owner') .. "'s Shepherd loses all of its sheep to a wolf. No points scored.", player_color_tints[figure.getVar('owner')])
                end
                scorePoints(figure.getVar('owner'), 'Shepherd', score)
                figure.setLock(false)
                figure.use_gravity = false
                figure.interactable = false
                --raise the figure in the air
                figure.setPositionSmooth({figure.getPosition().x, figure.getPosition().y + 2.5, figure.getPosition().z}, false, false)
            end
        end
        if showMarkers == 'Both' or showMarkers == 'Scoring' then
            Timer.create({identifier=shepherd.getGUID() .. os.clock(), function_name='praiseShepherd', function_owner=nil, parameters=nil, delay=0.9})
        else
            returnShepherds()
        end
    else
        allErrorMessage("Error: Sheep bag is missing! The bag needs to remain out in order to return sheep tokens")
        nextState('next')
    end
    return 1
end

function praiseShepherd()
    --startLuaCoroutine(self, 'praiseFiguresCoroutine')

    local CoNew = coroutine.create(praiseShepherdCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--makes the winning shepherds spin and marks the features that were scored
function praiseShepherdCoroutine()
    local hasWinner = false
    for _, figure in ipairs(removedFigures) do
        if figure.winner then
            hasWinner = true
            getObjectFromGUID(figure.guid).addTorque({0,25,0}, 4)
        end
    end
    if hasWinner then
        getObjectFromGUID(SOUNDBOARD_GUID).AssetBundle.playTriggerEffect(0)
    end
    if showMarkers == 'Scoring' or showMarkers == 'Both' then
        for _, traversedTileCoord in ipairs(traversedTileCoords) do
            if traversedFeaturePositions[traversedTileCoord.x] ~= nil and traversedFeaturePositions[traversedTileCoord.x][traversedTileCoord.z] ~= nil then
                for position, traversedFeaturePosition in pairs(traversedFeaturePositions[traversedTileCoord.x][traversedTileCoord.z]) do
                    if position < 13 or getObjectFromGUID(tileGrid[traversedTileCoord.x][traversedTileCoord.z].tile_guid).getTable('specialFeatures')[position - 12][3] ~= nil then
                        local tile = getObjectFromGUID(tileGrid[traversedTileCoord.x][traversedTileCoord.z].tile_guid)
                        local rotation = tileGrid[traversedTileCoord.x][traversedTileCoord.z].rotation
                        local x, z = getFeatureLocation(position, tile, rotation)
                        local params = {}
                        if traversedFeaturePosition == 1 then
                            params.type = "BlockSquare"
                        end
                        params.position = {(x * TILE_SPACING) + (traversedTileCoord.x * TILE_SPACING) - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (traversedTileCoord.z * TILE_SPACING) - MIDDLE_OFFSET.z}
                        params.scale = {0.25, 0.25, 0.25}
                        params.callback = "identifyFeature"
                        params.sound = false
                        local newObject = spawnObject(params)
                        table.insert(featureMarkers, newObject)
                    end
                end
                coroutine.yield(0)
            end
        end
    end
    Timer.create({identifier=os.clock(), function_name='returnShepherds', function_owner=nil, parameters=nil, delay=FIGURE_PRAISE_DELAY})
    return 1
end

function returnShepherds()
    --startLuaCoroutine(self, 'returnShepherdsCoroutine')

    local CoNew = coroutine.create(returnShepherdsCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--send figures back to the player supply area (assuming that's where they were when the game started)
function returnShepherdsCoroutine()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        figure_obj.setLock(false)
        figure_obj.use_gravity = true
        figure_obj.interactable = true

        if figurePositions[figure_obj.getVar('owner')] ~= nil and figurePositions[figure_obj.getVar('owner')][figure_obj.getGUID()] ~= nil then
            local figurePad = getObjectFromGUID(figurepad_GUIDs[figure_obj.getVar('owner')])
            local x, z = rotateCoordinatesDegrees(figurePositions[figure_obj.getVar('owner')][figure_obj.getGUID()].x, figurePositions[figure_obj.getVar('owner')][figure_obj.getGUID()].z, -figurePad.getRotation().y)
            figure_obj.setLock(false)
            figure_obj.setPositionSmooth({x = figurePad.getPosition().x + x, y = figurePad.getPosition().y + 1, z = figurePad.getPosition().z + z}, false, false)
            figure_obj.setRotationSmooth({x=0, y=figurePad.getRotation().y, z=0})
        else
            allErrorMessage("Warning: " .. figure_obj.getName() .. " doesn't have a home and must be returned manually", activePlayers[currentPlayer])
        end
        coroutine.yield(0)
    end
    removedFigures = {}

    nextState('next')
    return 1
end

function checkFlierDestination()
    if tileGridOccupied(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z) then
        local dragon = getObjectFromGUID(dragon_GUID)
        if controlPanelSettings['PnDDragon'] and dragon ~= nil then
            if lastPlacedTileX + flierOffset.x == math.floor((dragon.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
               lastPlacedTileZ + flierOffset.z == math.floor((dragon.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
                allGameMessage("The follower flew directly into the dragon's mouth! The dragon thanks you for the delicious aerial food delivery.", NEUTRAL_COLOR, activePlayers[currentPlayer])
                table.insert(removedFigures, {guid=flier, winner=false})
                return nextState('feature unavailable')
            end
        end
        resetTraversal()
        local destinationTile = getObjectFromGUID(tileGrid[lastPlacedTileX + flierOffset.x][lastPlacedTileZ + flierOffset.z].tile_guid)
        local hasIncompleteFeature = false
        for i=1, 12 do
            if getFeatureName(destinationTile, i) == 'City' or getFeatureName(destinationTile, i) == 'Road' then --fields are not valid destinations
                if getObjectFromGUID(flier).getVar('figureName') ~= 'Mayor' or getFeatureName(destinationTile, i) == 'City' then
                    if getFeatureComponents(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z, i, 1, false) > 0 then
                        hasIncompleteFeature = true
                    end
                end
            end
        end
        local specialFeatures = destinationTile.getTable('specialFeatures')
        for j, feature in pairs(specialFeatures) do
            if (feature[1] == 'Cloister' or feature[1] == 'Abbey') and getObjectFromGUID(flier).getVar('figureName') ~= 'Mayor' then
                if getFeatureComponents(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z, j + 12, 1, false) > 0 then
                    hasIncompleteFeature = true
                end
            end
            if feature[1] == 'Garden' and getObjectFromGUID(flier).getVar('figureName') == 'Abbot' then
                if getFeatureComponents(lastPlacedTileX + flierOffset.x, lastPlacedTileZ + flierOffset.z, j + 12, 1, false) > 0 then
                    hasIncompleteFeature = true
                end
            end
        end
        if hasIncompleteFeature then
            return nextState('feature available')
        else
            allGameMessage("The destination tile has no valid incomplete features that this follower can land on. Returning follower.", NEUTRAL_COLOR, activePlayers[currentPlayer])
        end
    else
        allGameMessage("No tile exists at flier destination. Returning follower.", NEUTRAL_COLOR, activePlayers[currentPlayer])
    end

    table.insert(removedFigures, {guid=flier, winner=false})
    return nextState('feature unavailable')
end

function promptMovingFromCoC()
    if currentMiniTurn == nil then
        if not gameover then
            currentMiniTurn = currentPlayer + 1
        else --this assumes that the script had moved to the next player, even though there were no tiles left. Should be the player after the one that placed the last tile
            currentMiniTurn = currentPlayer
        end
    end
    if controlPanelSettings['StartingTileCoC'] then
        --find the count so that ihe feature it is on can be excluded
        if carcassonneFigures == nil then
            carcassonneFigures = {}
            if barnFeatureNumbers == nil then
                barnFeatureNumbers = {}
            end

            local countnameOfFeature = nil
            if not controlPanelSettings['CoCNoCount'] then
                local count = getObjectFromGUID(expansionBags['CoC'].contents['CoCCount'].guid)
                local countxIndex = math.floor((count.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                local countzIndex = math.floor((count.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                if tileGrid[countxIndex] ~= nil and tileGrid[countxIndex][countzIndex] ~= nil then
                    local countxPosition = (count.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                    local countzPosition = (count.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                    countxPosition = countxPosition - countxIndex
                    countzPosition = countzPosition - countzIndex
                    local counttile = getObjectFromGUID(tileGrid[countxIndex][countzIndex].tile_guid)
                    local counttilerotation = tileGrid[countxIndex][countzIndex].rotation
                    local countclosestPosition = findClosestPosition(countxPosition, countzPosition, counttile, counttilerotation, false)
                    local countfeatureNum = featureMap[countxIndex][countzIndex][countclosestPosition]
                    countnameOfFeature = featureList[countfeatureNum].nameOfFeature
                end
            end

            --find all followers in the city of carcassonne
            for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
                if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) or obj.getVar('figureName') == 'Barn' then
                    local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                    local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                    if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                        local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                        local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                        xPosition = xPosition - xIndex
                        zPosition = zPosition - zIndex
                        local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                        local rotation = tileGrid[xIndex][zIndex].rotation
                        local closestPosition = findClosestPosition(xPosition, zPosition, tile, rotation, false)
                        local featureNum = featureMap[xIndex][zIndex][closestPosition]

                        if featureNum ~= nil and featureList[featureNum] ~= nil then
                            if obj.getVar('figureName') == 'Barn' then
                                table.insert(barnFeatureNumbers, featureNum)
                            else
                                local nameOfFeature = featureList[featureNum].nameOfFeature
                                if string.sub(nameOfFeature,1,8) == 'Quarter-' and nameOfFeature ~= countnameOfFeature then
                                    local quarter = string.sub(nameOfFeature,9)
                                    if carcassonneFigures[obj.getVar('owner')] == nil then
                                        carcassonneFigures[obj.getVar('owner')] = {}
                                    end
                                    carcassonneFigures[obj.getVar('owner')][obj.getGUID()] = quarter
                                end
                            end
                        end
                    end
                end
            end
        end
        --this is necessary if the game is loaded during this turn state. I don't want to save it to the save file so i have to make this check.
        if barnFeatureNumbers == nil then
            barnFeatureNumbers = {}
            for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
                if obj.getVar('figureName') == 'Barn' then
                    local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                    local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                    if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                        local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                        local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                        xPosition = xPosition - xIndex
                        zPosition = zPosition - zIndex
                        local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                        local rotation = tileGrid[xIndex][zIndex].rotation
                        local closestPosition = findClosestPosition(xPosition, zPosition, tile, rotation, false)
                        local featureNum = featureMap[xIndex][zIndex][closestPosition]

                        if featureNum ~= nil and featureList[featureNum] ~= nil then
                            if obj.getVar('figureName') == 'Barn' then
                                table.insert(barnFeatureNumbers, featureNum)
                            end
                        end
                    end
                end
            end
        end
        while true do
            if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
            --https://stackoverflow.com/a/1252776
            local next = next
            if next(carcassonneFigures) == nil then break end
            local hasCity = false
            local hasRoad = false
            local hasCloister = false
            local hasField = false
            if not gameover then
                local newTile = getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid)
                local tileRotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation
                if newTile.getTable('sides')[1] ~= 'Abbey' then
                    local specialFeatures = newTile.getTable('specialFeatures')
                    for i=1, 12 do --roads and cities
                        local direction
                        if i < 5 then
                            direction = (3 + i + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
                        elseif i < 13 then
                            direction = (3 + i + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                        end
                        local featureNum = featureMap[lastPlacedTileX][lastPlacedTileZ][direction]
                        if featureNum == nil and i < 5 and featureMap[lastPlacedTileX][lastPlacedTileZ][(direction * 2) + 3] ~= nil and featureMap[lastPlacedTileX][lastPlacedTileZ][(direction * 2) + 3] == featureMap[lastPlacedTileX][lastPlacedTileZ][(direction * 2) + 4] then
                           featureNum = featureMap[lastPlacedTileX][lastPlacedTileZ][(direction * 2) + 3]
                        end
                        if featureNum ~= nil and featureList[featureNum] ~= nil then
                            local nameOfFeature = featureList[featureNum].nameOfFeature
                            if nameOfFeature == 'Field' and table.contains(barnFeatureNumbers, featureNum) and not controlPanelSettings['BaseDisableFields'] then
                                hasField = true
                            elseif featureList[featureNum].openings == 0 then
                                if nameOfFeature == 'Road' and not controlPanelSettings['BaseDisableRoads'] then
                                    hasRoad = true
                                end
                                if nameOfFeature == 'City' and not controlPanelSettings['BaseDisableCities'] then
                                    hasCity = true
                                end
                                if table.contains(CLOISTER_FEATURES, nameOfFeature) and not controlPanelSettings['BaseDisableCloisters'] then
                                    hasCloister = true
                                end
                            end
                        end
                    end
                else --if an abbey was used, then we cannot simply traverse it's features like above in order to find completed features. instead, we traverse the surrounding features
                    for i=1, 12 do --roads and cities
                        local tile = newTile
                        local rotation = tileGrid[lastPlacedTileX][lastPlacedTileZ].rotation
                        local direction = (3 + i + rotation) % 4 + 1
                        local newX = lastPlacedTileX + SIDE_DELTA[direction].x
                        local newZ = lastPlacedTileZ + SIDE_DELTA[direction].z
                        if tileGridOccupied(newX, newZ) then
                            local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                            local newTileRotation = tileGrid[newX][newZ].rotation
                            local newTilePosition
                            if direction < 5 then
                                newTilePosition = (3 + direction + newTileRotation + TILE_STANDARD_ROTATION) % 4 + 1
                            elseif direction < 13 then
                                newTilePosition = (3 + direction + ((newTileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                            else
                                newTilePosition = direction
                            end
                            local featureNum = featureMap[newX][newZ][newTilePosition]
                            if featureNum == nil and direction < 5 and featureMap[newX][newZ][(newTilePosition * 2) + 3] ~= nil and featureMap[newX][newZ][(newTilePosition * 2) + 3] == featureMap[newX][newZ][(newTilePosition * 2) + 4] then
                               featureNum = featureMap[newX][newZ][(newTilePosition * 2) + 3]
                            end
                            if featureNum ~= nil and featureList[featureNum] ~= nil then
                                if featureList[featureNum].openings == 0 then
                                    local nameOfFeature = featureList[featureNum].nameOfFeature
                                    if nameOfFeature == 'Road' and not controlPanelSettings['BaseDisableRoads'] then
                                        hasRoad = true
                                    end
                                    if nameOfFeature == 'City' and not controlPanelSettings['BaseDisableCities'] then
                                        hasCity = true
                                    end
                                    if table.contains(CLOISTER_FEATURES, nameOfFeature) and not controlPanelSettings['BaseDisableCloisters'] then
                                        hasCloister = true
                                    end
                                end
                            end
                        end
                    end
                end

                --check neighbors for completed cloisters
                for _, offset in ipairs(DIAGONAL_DELTA) do
                    local neighborX = lastPlacedTileX + offset.x
                    local neighborZ = lastPlacedTileZ + offset.z
                    if tileGridOccupied(neighborX, neighborZ) then
                        for _, neighborFeatureNum in pairs(featureMap[neighborX][neighborZ]) do
                            if table.contains(CLOISTER_FEATURES, featureList[neighborFeatureNum].nameOfFeature) then
                                if featureList[neighborFeatureNum].openings == 0 then
                                    hasCloister = true
                                end
                            end
                        end
                    end
                end
            end

            local hasAnything = false
            if (hasRoad or gameover) and carcassonneFigures[activePlayers[currentMiniTurn]] ~= nil then
                --allGameMessage({"{c1} has followers at the Blacksmith that can be moved to the completed road.", {'{c1}', activePlayers[currentMiniTurn]}}, player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                for follower_guid, quarter in pairs(carcassonneFigures[activePlayers[currentMiniTurn]]) do
                    if quarter == 'Blacksmith' then
                        hasAnything = true
                        getObjectFromGUID(follower_guid).highlightOn({1,1,1})
                        getObjectFromGUID(follower_guid).setLock(false)
                    end
                end
            end
            if (hasCity or gameover) and carcassonneFigures[activePlayers[currentMiniTurn]] ~= nil then
                --allGameMessage({"{c1} has followers at the Blacksmith that can be moved to the completed road.", {'{c1}', activePlayers[currentMiniTurn]}}, player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                for follower_guid, quarter in pairs(carcassonneFigures[activePlayers[currentMiniTurn]]) do
                    if quarter == 'Castle' then
                        hasAnything = true
                        getObjectFromGUID(follower_guid).highlightOn({1,1,1})
                        getObjectFromGUID(follower_guid).setLock(false)
                    end
                end
            end
            if (hasCloister or gameover) and carcassonneFigures[activePlayers[currentMiniTurn]] ~= nil then
                --allGameMessage({"{c1} has followers at the Blacksmith that can be moved to the completed road.", {'{c1}', activePlayers[currentMiniTurn]}}, player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                for follower_guid, quarter in pairs(carcassonneFigures[activePlayers[currentMiniTurn]]) do
                    if quarter == 'Cathedral' then
                        hasAnything = true
                        getObjectFromGUID(follower_guid).highlightOn({1,1,1})
                        getObjectFromGUID(follower_guid).setLock(false)
                    end
                end
            end
            if (hasField or gameover) and carcassonneFigures[activePlayers[currentMiniTurn]] ~= nil then
                --allGameMessage({"{c1} has followers at the Blacksmith that can be moved to the completed road.", {'{c1}', activePlayers[currentMiniTurn]}}, player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                for follower_guid, quarter in pairs(carcassonneFigures[activePlayers[currentMiniTurn]]) do
                    if quarter == 'Market' then
                        hasAnything = true
                        getObjectFromGUID(follower_guid).highlightOn({1,1,1})
                        getObjectFromGUID(follower_guid).setLock(false)
                    end
                end
            end
            if hasAnything then
                allGameMessage({"{c1} has followers in the City of Carcassonne that can be moved to a completed feature.", {'{c1}', activePlayers[currentMiniTurn]}}, player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                local labelButtonParam = {
                   index = 1, label = 'Place a figure\nOR', click_function = 'doNothing',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=3.8}, width = 0, height=0, font_size = 200, function_owner = nil
                }
                local skipFigureButtonParam = {
                   index = 2, label = 'Skip placing\nfigure', click_function = 'skipCoCButton',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=4.5}, width = 1400, height=600, font_size = 200, function_owner = nil
                }
                local CoCMiddlePosition = getObjectFromGUID(expansionBags['CoC'].contents['CoCStartingTiles'].contents[6].guid).getPosition()
                CoCMiddlePosition.x = CoCMiddlePosition.x + TILE_SPACING / 2
                createNormalizedArbitraryButton({x=-CoCMiddlePosition.x, y=CoCMiddlePosition.y, z=-CoCMiddlePosition.z}, labelButtonParam, true)
                createNormalizedArbitraryButton({x=-CoCMiddlePosition.x, y=CoCMiddlePosition.y, z=-CoCMiddlePosition.z}, skipFigureButtonParam, true)
                return
            else
                carcassonneFigures[activePlayers[currentMiniTurn]] = nil
                currentMiniTurn = currentMiniTurn + 1
            end
        end
        currentMiniTurn = nil
        carcassonneFigures = nil
        barnFeatureNumbers = nil
    end
    return nextState('next')
end

function skipCoCButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        clearArbitraryButtons()
        for follower_guid, quarter in pairs(carcassonneFigures[activePlayers[currentMiniTurn]]) do
            getObjectFromGUID(follower_guid).highlightOff()
            getObjectFromGUID(follower_guid).setLock(true)
        end
        carcassonneFigures[activePlayers[currentMiniTurn]] = nil
        currentMiniTurn = currentMiniTurn + 1
        return promptMovingFromCoC()
    end
end

function scoreFeatures()
    scoring = true
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for i, figureTypes in ipairs({FOLLOWER_TYPES, SPECIAL_FIGURE_TYPES}) do
        for _, obj in ipairs(objs) do
            if table.contains(figureTypes, obj.getVar('figureName')) and not (i == 2 and (not gameover or obj.getVar('figureName') ~= 'Barn')) then
                if not table.contains(followersScored, obj) then
                    local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                    local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                    if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                        --debugMessage(1, "Checking " .. obj.getVar('owner') .. " " .. obj.getVar('tokenName') .. " for finished features at index: x: " .. xIndex .. " z: " .. zIndex)
                        local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                        local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                        xPosition = xPosition - xIndex
                        zPosition = zPosition - zIndex

                        local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                        local tileRotation = tileGrid[xIndex][zIndex].rotation
                        local closestPosition = findClosestPosition(xPosition, zPosition, tile, tileRotation, true)
                        local direction
                        if closestPosition < 5 then
                            direction = (3 + closestPosition + tileRotation + TILE_STANDARD_ROTATION) % 4 + 1
                        elseif closestPosition < 13 then
                            direction = (3 + closestPosition + ((tileRotation + TILE_STANDARD_ROTATION) * 2)) % 8 + 5
                        else
                            direction = closestPosition
                        end
                        local featureNum = featureMap[xIndex][zIndex][direction]
                        if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(direction * 2) + 3] ~= nil and featureMap[xIndex][zIndex][(direction * 2) + 3] == featureMap[xIndex][zIndex][(direction * 2) + 4] then
                           featureNum = featureMap[xIndex][zIndex][(direction * 2) + 3]
                        end
                        if featureNum ~= nil then
                            getActiveFigures()
                            -- getActiveNeutralFigures()
                            local nameOfFeature = featureList[featureNum].nameOfFeature

                            --debugMessage(2, "figure closest feature: index: x: " .. xIndex .. " z: " .. zIndex .. " position: " .. closestPosition .. " name: " .. nameOfFeature)

                            local featureComplete
                            if featureList[featureNum].openings == 0 then
                                featureComplete = true
                            else
                                featureComplete = false
                            end

                            local featureFollowers = {}
                            local featureSpecialFigures = {}
                            if activeFigures[featureNum] ~= nil then
                                featureFollowers = activeFigures[featureNum].followers
                                featureSpecialFigures = activeFigures[featureNum].specialFigures
                            end

                            local followerCounts = {}
                            local hasPig = {}
                            local hasHill = {}
                            local hasMayor = {}
                            local hasBarn = false
                            local hasNewBarn = false
                            local topWeight = -1
                            --find the relative weights for the followers on this feature
                            for _, follower in ipairs(featureFollowers) do
                                local weight = 0
                                if follower.getVar('figureName') == 'Follower' or follower.getVar('figureName') == 'Wagon' or follower.getVar('figureName') == 'Abbot' then weight = 1
                                elseif follower.getVar('figureName') == 'Big Follower' then weight = 2
                                elseif follower.getVar('figureName') == 'Mayor' then
                                    for _, specialFeature in ipairs(featureList[featureNum].specialFeatures) do
                                        if specialFeature == 'Pennant' then weight = weight + 1 end
                                    end
                                    hasMayor[follower.getVar('owner')] = true
                                end
                                if weight > 0 then
                                    local followerXIndex = math.floor((follower.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                    local followerZIndex = math.floor((follower.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                    local specialFeatures = getObjectFromGUID(tileGrid[followerXIndex][followerZIndex].tile_guid).getTable('specialFeatures')
                                    if controlPanelSettings['HnSHills'] and specialFeatures ~= nil then
                                        for _, specialFeature in ipairs(specialFeatures) do
                                            if specialFeature[1] == "Hill" then
                                                --although it would have been easier to just add 0.001 to the weight here, it would have technically violated the rules, since multiple hills are not supposed to give extra weight.
                                                hasHill[follower.getVar('owner')] = true
                                            end
                                        end
                                    end
                                end
                                if followerCounts[follower.getVar('owner')] == nil then
                                    followerCounts[follower.getVar('owner')] = weight
                                else
                                    followerCounts[follower.getVar('owner')] = followerCounts[follower.getVar('owner')] + weight
                                end
                            end
                            --add hill weight if there is a hill, find top weight for the feature
                            for player_color, value in pairs(followerCounts) do
                                if hasHill[player_color] then
                                    --if the follower is on a hill, add a small value to it to break any ties
                                    followerCounts[player_color] = followerCounts[player_color] + 0.001
                                end
                                if followerCounts[player_color] > topWeight then topWeight = followerCounts[player_color] end
                            end

                            for _, figure in ipairs(featureSpecialFigures) do
                                if figure.getVar('figureName') == 'Pig' then hasPig[figure.getVar('owner')] = true end
                                if figure.getVar('figureName') == 'Barn' then
                                    hasBarn = true
                                    if newBarn ~= nil and figure.getGUID() == newBarn then
                                        hasNewBarn = true
                                        newBarn = nil
                                    end
                                    --recalculate "follower count" with only barns. Technically they aren't followers but it was easier in code.
                                    if #featureFollowers == 0 then
                                        if followerCounts[figure.getVar('owner')] == nil then
                                            followerCounts[figure.getVar('owner')] = 1
                                        else
                                            followerCounts[figure.getVar('owner')] = followerCounts[figure.getVar('owner')] + 1
                                        end
                                        if followerCounts[figure.getVar('owner')] > topWeight then topWeight = followerCounts[figure.getVar('owner')] end
                                    end
                                end
                            end
                            if #featureFollowers == 0 and not hasBarn then
                                allErrorMessage("ERROR: no followers found. This should never happen. Tell the dev.")
                                return
                            end
                            local score = 0
                            local containsPigHerd = false
                            if nameOfFeature == 'City' then
                                score = featureList[featureNum].numTiles
                                local containsCathedral = false
                                for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                                    if feature == 'Pennant' then
                                        score = score + 1
                                    end
                                    if feature == 'Cathedral' and controlPanelSettings['InCCathedrals'] then
                                        containsCathedral = true
                                    end
                                end
                                if containsCathedral then
                                    if featureComplete then
                                        score = score * 3
                                    else
                                        score = 0
                                    end
                                else
                                    if featureComplete then
                                        score = score * 2
                                    end
                                end
                                --do not nerf cities that were completed by an abbey, or incomplete cities
                                if lastPlacedTileX ~= nil and getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid).getTable('sides')[1] ~= 'Abbey' and
                                   featureComplete and controlPanelSettings['BaseNerfSmallCity'] and score == 4 then score = 2 end
                            elseif nameOfFeature == 'Field' then
                                if linkedFeatures['City-Field'][featureNum] ~= nil then
                                    for connectedFeatureNum, _ in pairs(linkedFeatures['City-Field'][featureNum]) do
                                        if featureList[connectedFeatureNum].openings == 0 then
                                            score = score + 1
                                        end
                                    end
                                    for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                                        if feature == 'Pig-herd' and not controlPanelSettings['RIIDisablePigherd'] then
                                            containsPigHerd = true
                                        end
                                    end
                                end
                                featureComplete = false --so that this feature won't be scored before the end of the game
                            elseif nameOfFeature == 'Road' then
                                score = featureList[featureNum].numTiles
                                local containsInn = false
                                for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                                    if feature == 'Inn' and controlPanelSettings['InCInns'] then
                                        containsInn = true
                                    end
                                end
                                if containsInn then
                                    if featureComplete then
                                        score = score * 2
                                    else
                                        score = 0
                                    end
                                end
                            elseif table.contains(CLOISTER_FEATURES, nameOfFeature) then
                                score = featureList[featureNum].numTiles
                                if featureComplete and controlPanelSettings['HnSVineyards'] then
                                    for _, feature in ipairs(featureList[featureNum].specialFeatures) do
                                        if feature == 'Vineyard' then
                                            score = score + 3
                                        end
                                    end
                                end
                                if featureComplete then
                                    local challengerTile, challengedTile
                                    if nameOfFeature == 'Cloister' or nameOfFeature == 'Abbey' then
                                        challengerTile = 'Cloister'
                                        challengedTile = 'Shrine'
                                    else
                                        challengerTile = 'Shrine'
                                        challengedTile = 'Cloister'
                                    end
                                    for x=-1, 1 do
                                        for z=-1, 1 do
                                            if not (x == 0 and z == 0) and tileGridOccupied(xIndex + x, zIndex + z) then
                                                local specialFeatures = getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid).getTable('specialFeatures')
                                                if specialFeatures ~= nil then
                                                    for i, feature in ipairs(specialFeatures) do
                                                        local adjacentFeature = feature[1]
                                                        if adjacentFeature == 'Abbey' then adjacentFeature = 'Cloister' end
                                                        if adjacentFeature == challengedTile then
                                                            local numTiles = 0
                                                            for nested_x=-1, 1 do
                                                                for nested_z=-1, 1 do
                                                                    if tileGridOccupied(xIndex + x + nested_x, zIndex + z + nested_z) then
                                                                        numTiles = numTiles + 1
                                                                    end
                                                                end
                                                            end
                                                            if numTiles ~= 9 then
                                                                local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
                                                                for _, object in ipairs(objs) do
                                                                    if table.contains(FOLLOWER_TYPES, object.getVar('figureName')) then
                                                                        local objectXIndex = math.floor((object.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
                                                                        local objectZIndex = math.floor((object.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
                                                                        if objectXIndex == xIndex + x and objectZIndex == zIndex + z then
                                                                    				local xPosition = (object.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                                                                    				local zPosition = (object.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                                                                    				xPosition = xPosition - objectXIndex
                                                                    				zPosition = zPosition - objectZIndex
                                                                    				local nestedClosestPosition = findClosestPosition(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex + x][zIndex + z].tile_guid), rotation, true)
                                                                            if nestedClosestPosition == i + 12 then
                                                                                object.setLock(false)
                                                                                object.use_gravity = false
                                                                                object.interactable = false
                                                                                --raise the follower in the air
                                                                                object.setPositionSmooth({object.getPosition().x, object.getPosition().y + 2.5, object.getPosition().z}, false, false)
                                                                                table.insert(removedFigures, {guid=object.getGUID(), winner=false})
                                                                                allGameMessage(object.getVar('owner') .. " " .. object.getName() .. " has lost the Cloister/Shrine challenge.", player_color_tints[object.getVar('owner')])
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            elseif nameOfFeature == "Baba Yaga's Hut" then
                                score = 10 - featureList[featureNum].numTiles
                                --unclear if vineyards should be counted. Leaving out for now
                            elseif nameOfFeature == "Garden" then
                                score = featureList[featureNum].numTiles
                            end
                            for player, value in pairs(followerCounts) do
                                if nameOfFeature ~= 'Carcassonne' and string.sub(nameOfFeature,1,8) ~= 'Quarter-' and string.sub(nameOfFeature,1,6) ~= 'Crown-' and nameOfFeature ~= 'Tower Foundation' and string.sub(nameOfFeature,1,6) ~= 'Flier' then
                                    if gameover or featureComplete or (nameOfFeature == 'Field' and hasBarn and #featureFollowers > 0) or (gameover and hasBarn and #featureFollowers == 0) then
                                        if (topWeight > 0 and value >= topWeight) then
                                            local playerScore = score
                                            if nameOfFeature == 'Field' then
                                                local scoreMultiplier = 3
                                                if hasBarn then
                                                    if #featureFollowers > 0 then
                                                        if not hasNewBarn then
                                                            scoreMultiplier = 1
                                                        end
                                                    else
                                                        scoreMultiplier = 4
                                                    end
                                                end
                                                if hasPig[player] ~= nil then
                                                    scoreMultiplier = scoreMultiplier + 1
                                                end
                                                if containsPigHerd and #featureFollowers > 0 then -- CAR pg 67 ref 194
                                                    scoreMultiplier = scoreMultiplier + 1
                                                end
                                                playerScore = score * scoreMultiplier
                                            end
                                            allGameMessage(player .. " scores " .. playerScore .. " points on " .. nameOfFeature, player_color_tints[player]) -- .. " with a strength of " .. value .. " followers", player_color_tints[player])
                                            scorePoints(player, nameOfFeature, playerScore)
                                        elseif value > 0 then
                                            --allGameMessage(player .. " did not score any points with a strength of only " .. value .. " followers", player_color_tints[player])
                                        elseif topWeight == 0 and hasMayor[player] then
                                            allGameMessage(player .. " scores 0 points on " .. nameOfFeature .. ". A mayor can only score points if the city contains a Pennant!", player_color_tints[player])
                                        end
                                    end
                                end
                            end
                            for _, follower in ipairs(featureFollowers) do
                                if not table.contains(followersScored, follower) then
                                    table.insert(followersScored, follower)
                                end
                            end
                            if gameover and #featureFollowers == 0 then
                                for _, figure in ipairs(featureSpecialFigures) do
                                    if not table.contains(followersScored, figure) and figure.getVar('figureName') == 'Barn' then
                                        table.insert(followersScored, figure)
                                    end
                                end
                            end
                            if nameOfFeature ~= 'Carcassonne' and string.sub(nameOfFeature,1,8) ~= 'Quarter-' and string.sub(nameOfFeature,1,6) ~= 'Crown-' and nameOfFeature ~= 'Tower Foundation' then
                                if gameover or featureComplete or (nameOfFeature == 'Field' and hasBarn) then
                                    --The following is only used to check for traversedGoldBars
                                    getFeatureComponents(xIndex, zIndex, closestPosition, 2, true)
                                    for _, follower in ipairs(featureFollowers) do
                                        local closestFollower = fairyClosestFollower()
                                        if closestFollower == follower then
                                            allGameMessage(closestFollower.getVar('owner') .. " " .. closestFollower.getName() .. " scores 3 points for being next to the fairy when scoring a feature.", player_color_tints[closestFollower.getVar('owner')])
                                            scorePoints(closestFollower.getVar('owner'), 'Fairy', 3)
                                        end
                                        if follower.getVar('figureName') == "Wagon" then
                                            wagonFeatures[follower.getVar('owner')] = featureNum
                                        end
                                        local winner = false
                                        if topWeight > 0 and followerCounts[follower.getVar('owner')] >= topWeight and score > 0 then winner = true end
                                        if winner and nameOfFeature ~= 'Field' and #traversedGoldBars > 0 then
                                            if scoringRewards['Gold'] == nil then scoringRewards['Gold'] = {} end
                                            for _, gold in ipairs(traversedGoldBars) do
                                                if scoringRewards['Gold'][gold.getGUID()] == nil then scoringRewards['Gold'][gold.getGUID()] = {} end
                                                if not table.contains(scoringRewards['Gold'][gold.getGUID()], follower.getVar('owner')) then
                                                    table.insert(scoringRewards['Gold'][gold.getGUID()], follower.getVar('owner'))
                                                end
                                            end
                                        end
                                        table.insert(removedFigures, {guid=follower.getGUID(), winner=winner})
                                        follower.setLock(false)
                                        follower.use_gravity = false
                                        follower.interactable = false
                                        --raise the follower in the air
                                        follower.setPositionSmooth({follower.getPosition().x, follower.getPosition().y + 2.5, follower.getPosition().z}, false, false)
                                    end
                                    for _, figure in ipairs(featureSpecialFigures) do
                                        --shepherds are never removed outside of a flock collection
                                        --barns should only be scored at the end of the game, after all followers have been scored
                                        if figure.getVar('figureName') ~= 'Shepherd' and (figure.getVar('figureName') ~= 'Barn' or (figure.getVar('figureName') == 'Barn' and #featureFollowers == 0 and gameover)) then
                                            local winner = false
                                            --builder not involved in scoring, so shouldn't be praised
                                            if figure.getVar('figureName') ~= 'Builder' and topWeight > 0 and followerCounts[figure.getVar('owner')] >= topWeight and score > 0 then winner = true end
                                            table.insert(removedFigures, {guid=figure.getGUID(), winner=winner})
                                            figure.setLock(false)
                                            figure.use_gravity = false
                                            figure.interactable = false
                                            --raise the figure in the air
                                            figure.setPositionSmooth({figure.getPosition().x, figure.getPosition().y + 2.5, figure.getPosition().z}, false, false)
                                        end
                                    end
                                    if showMarkers == 'Both' or showMarkers == 'Scoring' then
                                        if gameover then
                                            praiseFiguresCameraFocus(false)
                                        end
                                        getFeatureComponents(xIndex, zIndex, closestPosition, 2, true)
                                        Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                                    else
                                        returnFigures()
                                    end
                                    return
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if gameover then --do possessions now
        if controlPanelSettings['TnBTradeGoods'] then
            for _, tokenType in ipairs(TRADE_TOKEN_TYPES) do --trade tokens
                local highestNumTokens = 0
                local tokenCounts = {}
                --find the highest count for this token
                for _, player in ipairs(activePlayers) do
                    local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                    local playerNumTokens = 0
                    for _, obj in ipairs(playerPossessions) do
                        if obj.getVar('tokenName') == tokenType then
                            local quantity = obj.getQuantity()
                            if quantity == -1 then quantity = 1 end
                            if tokenCounts[player] == nil then
                                tokenCounts[player] = quantity
                            else
                                tokenCounts[player] = tokenCounts[player] + quantity
                            end
                        end
                    end
                    if tokenCounts[player] ~= nil and tokenCounts[player] > highestNumTokens then
                        highestNumTokens = tokenCounts[player]
                    end
                end
                if highestNumTokens > 0 then
                    --give points to players with the most tokens
                    for _, player in ipairs(activePlayers) do
                        local winner
                        if tokenCounts[player] == highestNumTokens then
                            winner = true
                            allGameMessage(player .. " scores 10 points on " .. tokenType .. "s", player_color_tints[player])
                            scorePoints(player, 'Trade Goods', 10)
                        else
                            winner = false
                        end
                        local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                        for _, obj in ipairs(playerPossessions) do
                            if obj.getVar('tokenName') == tokenType then
                                table.insert(removedFigures, {guid=obj.getGUID(), winner=winner})
                                obj.setLock(false)
                                obj.use_gravity = false
                                obj.interactable = false
                                --raise the token in the air
                                if showMarkers == 'Both' or showMarkers == 'Scoring' then
                                    obj.setPositionSmooth({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                                else
                                    obj.setPosition({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                                end
                            end
                        end
                    end
                    traversedFeaturePositions = {}
                    if showMarkers == 'Both' or showMarkers == 'Scoring' then
                        praiseFiguresCameraFocus(true)
                        Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                    else
                        returnFigures()
                    end
                    return
                end
            end
        end
        if controlPanelSettings['GoldminesGold'] then
            --find the highest count for this token
            for _, player in ipairs(activePlayers) do
                local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                local playerNumGold = 0
                for _, obj in ipairs(playerPossessions) do
                    if obj.getVar('figureName') == GOLD_BAR_NAME then
                        local quantity = obj.getQuantity()
                        if quantity == -1 then quantity = 1 end
                        playerNumGold = playerNumGold + quantity
                        table.insert(removedFigures, {guid=obj.getGUID(), winner=true})
                        obj.setLock(false)
                        obj.use_gravity = false
                        obj.interactable = false
                        --raise the token in the air
                        obj.setPositionSmooth({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                    end
                end
                if playerNumGold > 0 then
                    local goldPoints
                    local goldMultiplier
                    if playerNumGold > 9 then
                        goldMultiplier =  4
                    elseif playerNumGold > 6 then
                        goldMultiplier = 3
                    elseif playerNumGold > 3 then
                        goldMultiplier = 2
                    else
                        goldMultiplier = 1
                    end
                    allGameMessage(player .. " scores " .. playerNumGold * goldMultiplier .. " points on " .. playerNumGold .. " gold bars (" .. goldMultiplier .. " points each).", player_color_tints[player])
                    scorePoints(player, 'Gold', playerNumGold * goldMultiplier)
                    traversedFeaturePositions = {}

                    if showMarkers == 'Both' or showMarkers == 'Scoring' then
                        praiseFiguresCameraFocus(true)
                        Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                    else
                        returnFigures()
                    end
                    return
                end
            end
        end
        --count total completed cities and roads for king and robber points
        local numCities = 0
        local numRoads = 0
        resetTraversal()
        if controlPanelSettings['KnRBKing'] or controlPanelSettings['KnRBRobber'] then
            for x, tileColumn in pairs(tileGrid) do
                for z, tileLocation in pairs(tileColumn) do
                    local tile = getObjectFromGUID(tileLocation.tile_guid)
                    for i=1, 12 do --roads and cities
                        if traversedGrid[x] == nil or traversedGrid[x][z] == nil or traversedGrid[x][z][i] == nil or traversedGrid[x][z][i] > 1 then
                            if controlPanelSettings['KnRBRobber'] and i < 5 and getFeatureName(tile, i) == 'Road' then
                                if getFeatureComponents(x, z, i, 1, false) == 0 then
                                    numRoads = numRoads + 1
                                end
                            elseif controlPanelSettings['KnRBKing'] and i >= 5 and (getFeatureName(tile, i) == 'City' or getFeatureName(tile, i) == 'Carcassonne') then
                                if getFeatureComponents(x, z, i, 1, false) == 0 then
                                    numCities = numCities + 1
                                end
                            end
                        end
                    end
                end
            end
            --find king and robber tokens and give points
            for _, player in ipairs(activePlayers) do
                local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                for _, obj in ipairs(playerPossessions) do
                    local score
                    if obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid then
                        score = numCities
                    elseif obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid then
                        score = numRoads
                    end
                    if (obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid and controlPanelSettings['KnRBKing']) or (obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid and controlPanelSettings['KnRBRobber']) then
                        allGameMessage(player .. " scores " .. score .. " points on " .. obj.getName(), player_color_tints[player])
                        scorePoints(player, 'King/Robber Tokens', score)
                        table.insert(removedFigures, {guid=obj.getGUID(), winner=true})
                        obj.setLock(false)
                        obj.use_gravity = false
                        obj.interactable = false
                        --raise the token in the air
                        obj.setPositionSmooth({obj.getPosition().x, obj.getPosition().y + 2.5, obj.getPosition().z}, false, false)
                        traversedFeaturePositions = {}

                        if showMarkers == 'Both' or showMarkers == 'Scoring' then
                            praiseFiguresCameraFocus(false)
                            Timer.create({identifier=os.clock(), function_name='praiseFigures', function_owner=nil, parameters=nil, delay=0.9})
                        else
                            returnFigures()
                        end
                        return
                    end
                end
            end
        end
    end
    scoring = false
    followersScored = {}
    if gameover then
        printedPlayers = {}
        local playerNum = 1
        local rank = 1
        local lastHighscore = 0
        while true do
            local highscore = 0
            local color = nil
            for _, player in ipairs(activePlayers) do
                local scoreCounter = getObjectFromGUID(score_counter_guids[player])
                if not table.contains(printedPlayers, player) and scoreCounter ~= nil then
                    if scoreCounter.Counter.getValue() > highscore then
                        highscore = scoreCounter.Counter.getValue()
                        color = player
                    end
                end
            end
            if highscore > 0 then
                if highscore < lastHighscore then rank = playerNum end
                local steam_name = ""
                if getPlayerOwner(color):sub(1,2) == 'AI' then
                    steam_name = getPlayerOwner(color)
                elseif controlPanelSettings[color .. 'Control'] ~= nil then
                    if Player[controlPanelSettings[color .. 'Control']].steam_name ~= nil then steam_name = Player[controlPanelSettings[color .. 'Control']].steam_name end
                else
                    if Player[color].steam_name ~= nil then steam_name = Player[color].steam_name end
                end
                allGameMessage("#" .. rank .. " - " .. highscore .. " points - ".. color .. " - " .. steam_name, player_color_tints[color])
            else
                break
            end
            table.insert(printedPlayers, color)
            playerNum = playerNum + 1
            lastHighscore = highscore
        end
        allGameMessage("Game over.", NEUTRAL_COLOR)
        allGameMessage("If you enjoyed the mod, please give it a like on the workshop. If you encountered any bugs, please upload a save file and describe it in the workshop comments.", NEUTRAL_COLOR)
    else
        return nextState('next')
    end
end

function rewardFairy()
    local closestFollower = fairyClosestFollower()
    if closestFollower ~= nil and closestFollower.getVar('owner') == activePlayers[currentPlayer] then
        local tileStack = getObjectFromGUID(tileStack_GUID)
        if tileStack == nil and finalTile_GUID == nil then
            allGameMessage("WARNING: No tile stack found. No points awarded for fairy. If you just placed the last tile, you can ignore this message.", NEUTRAL_COLOR)
        else
            allGameMessage(closestFollower.getVar('owner') .. " scores 1 point for being next to the fairy on their turn.", player_color_tints[closestFollower.getVar('owner')])
            scorePoints(closestFollower.getVar('owner'), 'Fairy', 1)
        end
    end
    return nextState('next')
end

function fairyClosestFollower()
    local closestFollower = nil
    local fairy = getObjectFromGUID(fairy_GUID)
    if fairy ~= nil then
        local xIndex = math.floor((fairy.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
        local zIndex = math.floor((fairy.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
        if tileGridOccupied(xIndex, zIndex) then
            local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
            local eligibleFollowers = {}
            for _, follower in ipairs(objs) do
                if table.contains(FOLLOWER_TYPES, follower.getVar('figureName')) then
                    if xIndex == math.floor((follower.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING) and
                     zIndex == math.floor((follower.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING) then
                        table.insert(eligibleFollowers, follower)
                    end
                end
            end
            if #eligibleFollowers == 1 then
                closestFollower = eligibleFollowers[1]
            elseif #eligibleFollowers > 1 then
                local closestDistanceToFairy = 999
                for i, follower in ipairs(eligibleFollowers) do
                    local distanceToFairy = (follower.getPosition().x - fairy.getPosition().x) * (follower.getPosition().x - fairy.getPosition().x) + (follower.getPosition().z - fairy.getPosition().z) * (follower.getPosition().z - fairy.getPosition().z)
                    if distanceToFairy < closestDistanceToFairy then
                        closestDistanceToFairy = distanceToFairy
                        closestFollower = follower
                    end
                end
            end
        end
    end
    return closestFollower
end

function hasOpenRiver()
    local hasOpenRiver = false
    for featureKey, feature in pairs(featureList) do
        if feature.nameOfFeature == 'River' then
            if feature.openings ~= 0 then
                hasOpenRiver = true
            end
        end
    end
    return hasOpenRiver
end

function hasFinishedRiver()
    local riverFinished = false
    for featureKey, feature in pairs(featureList) do
        if feature.nameOfFeature == 'River' then
            if feature.openings == 0 then
                riverFinished = true
            end
        end
    end
    return riverFinished
end

function rewardGold()
    if currentMiniTurn == nil then
        currentMiniTurn = currentPlayer
    else
        currentMiniTurn = currentMiniTurn + 1
    end
    local test = 0
    if scoringRewards['Gold'] ~= nil then
        while true do
            if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
            local eligiblePlayers = {}
            eligibleGold = {}
            for gold_guid, players in pairs(scoringRewards['Gold']) do
                for _, player in ipairs(players) do
                    if not table.contains(eligiblePlayers, player) then
                        table.insert(eligiblePlayers, player)
                    end
                end
                if table.contains(players, activePlayers[currentMiniTurn]) then
                    table.insert(eligibleGold, gold_guid)
                end
            end
            if #eligibleGold == 1 or (#eligibleGold > 0 and #eligiblePlayers == 1) then
                allGameMessage(activePlayers[currentMiniTurn] .. " was awarded a gold bar for having control over a finished feature.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                return giveGold(eligibleGold[1], activePlayers[currentMiniTurn])
            elseif #eligibleGold > 1 then
                allGameMessage(activePlayers[currentMiniTurn] .. " may choose a gold bar for having control over a finished feature.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                return promptGoldChoice(eligibleGold)
            end
            local count = 0
            for _, gold in pairs(scoringRewards['Gold']) do
                if gold ~= nil then
                    count = count + 1
                end
            end
            currentMiniTurn = currentMiniTurn + 1
            if count == 0 then break end
        end
    end
    currentMiniTurn = nil
    scoringRewards['Gold'] = nil
    return nextState('next')
end

function promptGoldChoice()
    for _, gold in ipairs(eligibleGold) do
        local goldButtonParam = {
           index = 1, label = 'Take\ngold', click_function = 'takeGoldButton',
           position = {x=0, y=FLOATING_BUTTON_HEIGHT_LOW, z=1.0}, width = 1100, height=600, font_size = 200, function_owner = nil
        }
        createNormalizedButton(getObjectFromGUID(gold), goldButtonParam, true)
    end
end

function takeGoldButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        for _, gold in pairs(eligibleGold) do
            getObjectFromGUID(gold).clearButtons()
        end
        return giveGold(object.getGUID(), sPlayer)
    end
end

function getGold()
    local gold = {}
    for _, player_color in ipairs(activePlayers) do
        local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player_color]).getObjects()
        local playerNumGold = 0
        for _, obj in ipairs(playerPossessions) do
            if obj.getVar('figureName') == GOLD_BAR_NAME then
                playerNumGold = playerNumGold + 1
            end
        end
        gold[player_color] = playerNumGold
    end
    return gold
end

function giveGold(gold, player_color)
    local tradeGoodPile
    local x, z = rotateCoordinates(PLAYER_POSSESSION_POSITIONS['Gold'].x, PLAYER_POSSESSION_POSITIONS['Gold'].z, player_possession_areas[player_color].rotation)
    x = player_possession_areas[activePlayers[currentMiniTurn]].x + x
    z = player_possession_areas[activePlayers[currentMiniTurn]].z + z

    x = x + PLAYER_POSSESSION_SPACING * tempGoldCounts[player_color]

    getObjectFromGUID(gold).setPositionSmooth({x, 2, z})
    getObjectFromGUID(gold).setRotationSmooth({0,  player_possession_areas[activePlayers[currentMiniTurn]].rotation * -90 + 90, 0})

    tempGoldCounts[player_color] = tempGoldCounts[player_color] + 1
    scoringRewards['Gold'][gold] = nil
    return rewardGold()
end

function replaceFinishedWagons()
    while true do
        if currentMiniTurn == nil then
            currentMiniTurn = currentPlayer
        else
            currentMiniTurn = currentMiniTurn + 1
            if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
            if currentMiniTurn == currentPlayer then break end
        end
        if wagonFeatures[activePlayers[currentMiniTurn]] ~= nil then
            if hasAvailableWagonFeature(wagonFeatures[activePlayers[currentMiniTurn]]) then
                allGameMessage(activePlayers[currentMiniTurn] .. "'s wagon has finished and may now be placed back on a connected feature.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
                -- local labelButtonParam = {
                --    index = 1, label = 'Replace your wagon\nOR', click_function = 'doNothing',
                --    position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=1.8}, width = 0, height=0, font_size = 200, function_owner = nil
                -- }
                -- local skipFigureButtonParam = {
                --    index = 2, label = 'Skip placing\nwagon', click_function = 'skipWagonButton',
                --    position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=2.5}, width = 1400, height=600, font_size = 200, function_owner = nil
                -- }
                local labelButtonParam = {
                   index = 1, label = 'Replace your wagon\nOR', click_function = 'doNothing',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=1.8}, width = 0, height=0, font_size = 200, function_owner = nil
                }
                local skipFigureButtonParam = {
                   index = 2, label = 'Skip placing\nwagon', click_function = 'skipWagonButton',
                   position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=2.5}, width = 1400, height=600, font_size = 200, function_owner = nil
                }
                createNormalizedArbitraryButton({x=-lastPlacedTileX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y + TILE_THICKNESS / 2, z=lastPlacedTileZ * TILE_SPACING - MIDDLE_OFFSET.z}, labelButtonParam, true)
                createNormalizedArbitraryButton({x=-lastPlacedTileX * TILE_SPACING + MIDDLE_OFFSET.x, y=TABLE_SURFACE_Y + TILE_THICKNESS / 2, z=lastPlacedTileZ * TILE_SPACING - MIDDLE_OFFSET.z}, skipFigureButtonParam, true)
                --createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), labelButtonParam, true)
                --createNormalizedButton(getObjectFromGUID(tileGrid[lastPlacedTileX][lastPlacedTileZ].tile_guid), skipFigureButtonParam, true)
                return
            else
                wagonFeatures[activePlayers[currentMiniTurn]] = nil
                allGameMessage(activePlayers[currentMiniTurn] .. "'s wagon has finished, but there were no available features connected.", player_color_tints[activePlayers[currentMiniTurn]], activePlayers[currentMiniTurn])
            end
        end
    end
    currentMiniTurn = nil
    return nextState('next')
end

function promptMovingToCarcassonne()
    if controlPanelSettings['StartingTileCoC'] then
        local someoneGotPoints = false
        for player_color, points in pairs(earnedPointsThisTile) do
            if points > 0 then
                someoneGotPoints = true
                break
            end
        end
        if someoneGotPoints and (earnedPointsThisTile[activePlayers[currentPlayer]] == nil or earnedPointsThisTile[activePlayers[currentPlayer]] == 0) then
            allGameMessage(activePlayers[currentPlayer] .. "'s move scored points for others but not themself. They can now place a follower in the City of Carcassonne if they choose.", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
            local labelButtonParam = {
               index = 1, label = 'Place a figure in\nCity of Carcassonne\nOR', click_function = 'doNothing',
               position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=3.8}, width = 0, height=0, font_size = 200, function_owner = nil
            }
            local skipFigureButtonParam = {
               index = 2, label = 'Skip placing\nfigure', click_function = 'skipFigureButton',
               position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=4.5}, width = 1400, height=600, font_size = 200, function_owner = nil
            }
            local CoCMiddlePosition = getObjectFromGUID(expansionBags['CoC'].contents['CoCStartingTiles'].contents[6].guid).getPosition()
            CoCMiddlePosition.x = CoCMiddlePosition.x + TILE_SPACING / 2
            createNormalizedArbitraryButton({x=-CoCMiddlePosition.x, y=CoCMiddlePosition.y, z=-CoCMiddlePosition.z}, labelButtonParam, true)
            createNormalizedArbitraryButton({x=-CoCMiddlePosition.x, y=CoCMiddlePosition.y, z=-CoCMiddlePosition.z}, skipFigureButtonParam, true)
            return
        end
    end
    return nextState('not eligible')
end

function promptMovingCount()
    if controlPanelSettings['StartingTileCoC'] and not controlPanelSettings['CoCNoCount'] then
        allGameMessage(activePlayers[currentPlayer] .. " may now move the Count if they wish.", player_color_tints[activePlayers[currentPlayer]], activePlayers[currentPlayer])
        getObjectFromGUID(expansionBags['CoC'].contents['CoCCount'].guid).setLock(false)
        local labelButtonParam = {
           index = 1, label = 'Move the count\nto another quarter\nOR', click_function = 'doNothing',
           position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=3.8}, width = 0, height=0, font_size = 200, function_owner = nil
        }
        local skipFigureButtonParam = {
           index = 2, label = 'Skip moving\nthe count', click_function = 'skipFigureButton',
           position = {x=0, y=FLOATING_BUTTON_HEIGHT, z=4.5}, width = 1400, height=600, font_size = 200, function_owner = nil
        }
        local CoCMiddlePosition = getObjectFromGUID(expansionBags['CoC'].contents['CoCStartingTiles'].contents[6].guid).getPosition()
        CoCMiddlePosition.x = CoCMiddlePosition.x + TILE_SPACING / 2
        createNormalizedArbitraryButton({x=-CoCMiddlePosition.x, y=CoCMiddlePosition.y, z=-CoCMiddlePosition.z}, labelButtonParam, true)
        createNormalizedArbitraryButton({x=-CoCMiddlePosition.x, y=CoCMiddlePosition.y, z=-CoCMiddlePosition.z}, skipFigureButtonParam, true)
        return
    end
    return nextState('not eligible')
end

function hasAvailableWagonFeature(wagonFeatureNum)
    if linkedFeatures['Road Intersection'][wagonFeatureNum] == nil then return false end
    local linkedRoadFeatures = table.shallow_copy(linkedFeatures['Road Intersection'][wagonFeatureNum])

    --trim the features that are already complete
    for linkedFeatureNum, _ in pairs(linkedRoadFeatures) do
        if featureList[linkedFeatureNum] ~= nil then
            if table.contains(CLOISTER_FEATURES, featureList[linkedFeatureNum].nameOfFeature) then
                local numOpenings = 8
                for x=-1, 1 do
                    for z=-1, 1 do
                        if not (x == 0 and z == 0) and tileGridOccupied(featureList[linkedFeatureNum].featureLocation.x + x, featureList[linkedFeatureNum].featureLocation.z + z) then
                            numOpenings = numOpenings - 1
                        end
                    end
                end
                if numOpenings <= 0 then
                    linkedRoadFeatures[linkedFeatureNum] = nil
                end
            elseif featureList[linkedFeatureNum].openings == 0 then
                linkedRoadFeatures[linkedFeatureNum] = nil
            end
        else
            linkedRoadFeatures[linkedFeatureNum] = nil
        end
    end

    for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
        if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) then
            local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            if tileGrid[xIndex] ~= nil and tileGrid[xIndex][zIndex] ~= nil then
                local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                xPosition = xPosition - xIndex
                zPosition = zPosition - zIndex
                local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                local rotation = tileGrid[xIndex][zIndex].rotation
                local closestPosition = findClosestPosition(xPosition, zPosition, tile, rotation, false)
                local featureNum = featureMap[xIndex][zIndex][closestPosition]

                if featureNum == nil and closestPosition < 5 and featureMap[xIndex][zIndex][(closestPosition * 2) + 3] ~= nil then
                    if featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'Road' and featureList[featureMap[xIndex][zIndex][(closestPosition * 2) + 3]].nameOfFeature ~= 'River' then
                        featureNum = featureMap[xIndex][zIndex][(closestPosition * 2) + 3]
                    end
                end
                if featureNum ~= nil then
                    for linkedFeatureNum, _ in pairs(linkedRoadFeatures) do
                        if linkedFeatureNum == featureNum then
                            linkedRoadFeatures[linkedFeatureNum] = nil
                            break
                        end
                    end
                end
            end
        end
    end

    local numberOfLinkedFeatures = 0
    for _, _ in pairs(linkedRoadFeatures) do
        numberOfLinkedFeatures = numberOfLinkedFeatures + 1
    end
    if numberOfLinkedFeatures > 0 then return true else return false end
end

function skipWagonButton(object, sPlayer)
    if checkGameButtonPrivileges(sPlayer) then
        clearArbitraryButtons()
        wagonFeatures[activePlayers[currentMiniTurn]] = nil
        return replaceFinishedWagons()
    end
end

--focus the camera on the currently praised figures
--params:
-- bool - only winning figures will be focused on
function praiseFiguresCameraFocus(onlyWinners)
    local camera_position = {x = 0.0, y = 0.0, z = 0.0}
    local num_winners = 0
    local max_separation = 0
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        if not onlyWinners or figure.winner then
            camera_position.x = camera_position.x + figure_obj.getPosition().x
            camera_position.y = camera_position.y + figure_obj.getPosition().y
            camera_position.z = camera_position.z + figure_obj.getPosition().z
            num_winners = num_winners + 1
            for _, other_figure in ipairs(removedFigures) do
                local other_figure_obj = getObjectFromGUID(other_figure.guid)
                local separation = math.sqrt((figure_obj.getPosition().x - other_figure_obj.getPosition().x) * (figure_obj.getPosition().x - other_figure_obj.getPosition().x) +
                          (figure_obj.getPosition().z - other_figure_obj.getPosition().z) * (figure_obj.getPosition().z - other_figure_obj.getPosition().z))
                if separation > max_separation then
                    max_separation = separation
                end
            end
        end
    end
    if num_winners > 0 then
        camera_position.x = camera_position.x / num_winners
        camera_position.y = camera_position.y / num_winners
        camera_position.z = camera_position.z / num_winners
    end
    for _, player in ipairs(activePlayers) do
        if getPlayerOwner(player):sub(1,2) ~= 'AI' and Player[getPlayerOwner(player)].seated then
            --getPointerRotation gives the player's current yaw (though +180 degrees). Use this to keep the yaw steady.
            local camera_yaw = Player[getPlayerOwner(player)].getPointerRotation() + 180
            if camera_yaw > 360 then camera_yaw = camera_yaw - 360 end
            local camera_params = {
                position = camera_position,
                yaw = camera_yaw,
                pitch = 35.0,
                --in theory this formula should give the camera distance needed to fit both objects in the screen
                --local camera_distance = math.tan((180 - fov) / 2) * (max_separation / 2)
                -- if the FoV is 90 degrees, then the altitude of the triangle is half the hypotenuse (which is the distance between the objects)
                -- is it correct? probably not, but it sounds good enough to me
                distance = 15.0 + (max_separation * 0.5)
            }
            Player[getPlayerOwner(player)].lookAt(camera_params)
        end
    end
end

function praiseFigures()
    --startLuaCoroutine(self, 'praiseFiguresCoroutine')

    local CoNew = coroutine.create(praiseFiguresCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--makes the winning followers spin and marks the features that were scored
function praiseFiguresCoroutine()
    local hasWinner = false
    for _, figure in ipairs(removedFigures) do
        if figure.winner then
            hasWinner = true
            getObjectFromGUID(figure.guid).addTorque({0,25,0}, 4)
        end
    end
    if hasWinner then
        getObjectFromGUID(SOUNDBOARD_GUID).AssetBundle.playTriggerEffect(0)
    end
    if showMarkers == 'Scoring' or showMarkers == 'Both' then
        for _, traversedTileCoord in ipairs(traversedTileCoords) do
            if traversedFeaturePositions[traversedTileCoord.x] ~= nil and traversedFeaturePositions[traversedTileCoord.x][traversedTileCoord.z] ~= nil then
                for position, traversedFeaturePosition in pairs(traversedFeaturePositions[traversedTileCoord.x][traversedTileCoord.z]) do
                    if position < 13 or getObjectFromGUID(tileGrid[traversedTileCoord.x][traversedTileCoord.z].tile_guid).getTable('specialFeatures')[position - 12][3] ~= nil then
                        local tile = getObjectFromGUID(tileGrid[traversedTileCoord.x][traversedTileCoord.z].tile_guid)
                        local rotation = tileGrid[traversedTileCoord.x][traversedTileCoord.z].rotation
                        local x, z = getFeatureLocation(position, tile, rotation)
                        local params = {}
                        if traversedFeaturePosition == 1 then
                            params.type = "BlockSquare"
                        elseif traversedFeaturePosition == 2 then
                            params.type = "BlockTriangle"
                        end
                        params.position = {(x * TILE_SPACING) + (traversedTileCoord.x * TILE_SPACING) - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (traversedTileCoord.z * TILE_SPACING) - MIDDLE_OFFSET.z}
                        params.scale = {0.25, 0.25, 0.25}
                        params.callback = "identifyFeature"
                        params.sound = false
                        local newObject = spawnObject(params)
                        table.insert(featureMarkers, newObject)
                    end
                end
                coroutine.yield(0)
            end
        end
    end
    Timer.create({identifier=os.clock(), function_name='returnFigures', function_owner=nil, parameters=nil, delay=FIGURE_PRAISE_DELAY})
    return 1
end

--when we spawn an object (to mark a feature), immediately lock it
function identifyFeature(obj)
    obj.setLock(true)
end

function returnFigures(skipStates)
    --startLuaCoroutine(self, 'returnFiguresCoroutine')

    --HACK: ransoming followers shouldn't progress the state machine
    if skipStates then
        skipStateProgression = true
    else
        skipStateProgression = false
    end
    local CoNew = coroutine.create(returnFiguresCoroutine)
    --add it to the list of active coroutines
    table.insert(m_Routines, {Co = CoNew, iYield = 0})
    --run it...
    local iIdx = #m_Routines
    coroutine.resume(m_Routines[iIdx].Co, m_Routines[iIdx].iYield)
end

--send figures back to the player supply area (assuming that's where they were when the game started)
function returnFiguresCoroutine()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
    for _, figure in ipairs(removedFigures) do
        local figure_obj = getObjectFromGUID(figure.guid)
        figure_obj.setLock(false)
        figure_obj.use_gravity = true
        figure_obj.interactable = true

        if figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid or figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid or table.contains(TRADE_TOKEN_TYPES, figure_obj.getVar('tokenName')) or figure_obj.getVar('figureName') == GOLD_BAR_NAME then
            -- move the tokens away from the player possession area. It doesn't really matter where, as long as we move them so they aren't counted twice.
            local targetPosition = {x = NEUTRAL_ITEMS_LOCATION.x, y = NEUTRAL_ITEMS_LOCATION.y, z = NEUTRAL_ITEMS_LOCATION.z}
            if figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBKing'].guid then
                targetPosition.x = targetPosition.x + 1 --arbitrary location
            elseif figure_obj.getGUID() == expansionBags['KnRB'].contents['KnRBRobber'].guid then
                targetPosition.x = targetPosition.x + 3 --arbitrary location
            end

            local container = nil
            if figure_obj.getVar('tokenName') == 'Wheat Token' then
                container = getObjectFromGUID(expansionBags['TnB'].contents['TnBWheatTokenStack'].guid)
            elseif figure_obj.getVar('tokenName') == 'Wine Token' then
                container = getObjectFromGUID(expansionBags['TnB'].contents['TnBWineTokenStack'].guid)
            elseif figure_obj.getVar('tokenName') == 'Cloth Token' then
                container = getObjectFromGUID(expansionBags['TnB'].contents['TnBClothTokenStack'].guid)
            elseif figure_obj.getVar('figureName') == GOLD_BAR_NAME then
                container = getObjectFromGUID(expansionBags['Goldmines'].contents['GoldminesGold'].guid)
            end
            if container ~= nil then
                container.putObject(figure_obj)
            elseif table.contains(TRADE_TOKEN_TYPES, figure_obj.getVar('tokenName')) then
                allErrorMessage("Warning: Could not find target container for " .. figure_obj.getName() .. ". It is being moved to an arbitrary location.", activePlayers[currentPlayer])
                figure_obj.setPositionSmooth(targetPosition, false, false)
            else
                figure_obj.setPositionSmooth(targetPosition, false, false)
            end
        else
            if figurePositions[figure_obj.getVar('owner')] ~= nil and figurePositions[figure_obj.getVar('owner')][figure_obj.getGUID()] ~= nil then
                local figurePad = getObjectFromGUID(figurepad_GUIDs[figure_obj.getVar('owner')])
                local x, z = rotateCoordinatesDegrees(figurePositions[figure_obj.getVar('owner')][figure_obj.getGUID()].x, figurePositions[figure_obj.getVar('owner')][figure_obj.getGUID()].z, -figurePad.getRotation().y)
                figure_obj.setLock(false)
                figure_obj.setPositionSmooth({x = figurePad.getPosition().x + x, y = figurePad.getPosition().y + 1, z = figurePad.getPosition().z + z}, false, false)
                figure_obj.setRotationSmooth({x=0, y=figurePad.getRotation().y, z=0})
            else
                allErrorMessage("Warning: " .. figure_obj.getName() .. " doesn't have a home and must be returned manually", activePlayers[currentPlayer])
            end
        end
        coroutine.yield(0)
    end
    removedFigures = {}

    --make sure to give enough time for pieces to travel back or they might be counted twice
    if not skipStateProgression then
        wait(FIGURE_RETURN_DELAY)
        nextState('figures returned')
    end
    return 1
end

function startAnimation(animation)
    function animate()
        local animation_finished = false
        local wheelCenterPosition = getWheelCenterPosition()
        while not animation_finished do
            if animation.type == 'WoFPig' then
                local pig = getObjectFromGUID(expansionBags['WoF'].contents['WoFPig'].guid)
                local time_elapsed = os.clock() - animation.start_time
                local degrees_rotated = (animation.start_position - 1) * 60
                if time_elapsed < ANIMATION_PIG_ACCEL_TIME then
                    --using d = (a * elapsed time^2) / 2
                    degrees_rotated = degrees_rotated + ANIMATION_PIG_ACCEL * time_elapsed * time_elapsed / 2
                elseif time_elapsed < ANIMATION_PIG_ACCEL_TIME + (ANIMATION_PIG_TIME_PER_SPACE * (animation.num_positions_moved - 1)) then
                    degrees_rotated = degrees_rotated + ANIMATION_PIG_ACCEL_DEGREES + (ANIMATION_PIG_MAX_VELOCITY * (time_elapsed - ANIMATION_PIG_ACCEL_TIME))
                elseif time_elapsed < ANIMATION_PIG_ACCEL_TIME * 2 + (ANIMATION_PIG_TIME_PER_SPACE * (animation.num_positions_moved - 1)) then
                    local time_decelerating = (time_elapsed - ANIMATION_PIG_ACCEL_TIME - ANIMATION_PIG_TIME_PER_SPACE * (animation.num_positions_moved - 1))
                    degrees_rotated = degrees_rotated + ANIMATION_PIG_ACCEL_DEGREES + (60 * (animation.num_positions_moved - 1)) +
                    -- using d = vi t + (a t * t) / 2
                        (ANIMATION_PIG_MAX_VELOCITY * time_decelerating) + (-ANIMATION_PIG_ACCEL * time_decelerating * time_decelerating / 2)
                else
                    degrees_rotated = degrees_rotated + 60 * animation.num_positions_moved
                    animation_finished = true
                end
                local x, z = rotateCoordinatesDegrees(wheelPigStartingOffset.x, wheelPigStartingOffset.z, -degrees_rotated)
                pig.setPosition({x=x + wheelCenterPosition.x, y=startingTileSettings['StartingTileWoF']['WoF']['WoFPig'].position.y, z=z + wheelCenterPosition.z})
                pig.setRotation({x=startingTileSettings['StartingTileWoF']['WoF']['WoFPig'].rotation.x, y=startingTileSettings['StartingTileWoF']['WoF']['WoFPig'].rotation.y, z=degrees_rotated})
            end
            coroutine.yield()
        end
        return 1
    end
    startLuaCoroutine(Global, "animate")
end

--Find the center
function getWheelCenterPosition()
    local x = 0
    local z = 0
    for _, i in ipairs({6, 7, 10, 11}) do
        local wheelCenterTile = getObjectFromGUID(expansionBags['WoF'].contents['WoFStartingTiles'].contents[i].guid)
        if wheelCenterTile == nil then return end
        local wheelCenterTilePosition = wheelCenterTile.getPosition()
        x = x + wheelCenterTilePosition.x
        z = z + wheelCenterTilePosition.z
    end
    x = x / 4
    z = z / 4
    return {x=x, z=z}
end

function pigIsEnabled()
    if controlPanelSettings['StartingTileWoF'] and
        (controlPanelSettings['WoFCrowns'] or controlPanelSettings['WoFFortune'] or controlPanelSettings['WoFTaxes'] or
        controlPanelSettings['WoFFamine'] or controlPanelSettings['WoFStorm'] or controlPanelSettings['WoFInquisition'] or
        controlPanelSettings['WoFPlague']) then
        return true
    end
    return false
end

function debugShowTraversal()
    for xIndex, gridColumn in pairs(traversedFeaturePositions) do
        for zIndex, tileLocation in pairs(gridColumn) do
            for position, traversedFeaturePosition in pairs(tileLocation) do
                if position < 13 or getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).getTable('specialFeatures')[position - 12][3] ~= nil then
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local rotation = tileGrid[xIndex][zIndex].rotation
                    local x, z = getFeatureLocation(position, tile, rotation)
                    if traversedFeaturePosition ~= 2 then
                        local params = {}
                        if traversedFeaturePosition == 1 then
                            params.type = "BlockSquare"
                        elseif traversedFeaturePosition == 2 then
                            params.type = "BlockTriangle"
                        end
                        params.position = {(x * TILE_SPACING) + (xIndex * TILE_SPACING) - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (zIndex * TILE_SPACING) - MIDDLE_OFFSET.z}
                        params.scale = {0.25, 0.25, 0.25}
                        params.callback = "identifyFeature"
                        params.sound = false
                        local newObject = spawnObject(params)
                        table.insert(featureMarkers, newObject)
                    end
                end
            end
        end
    end
    for xIndex, gridColumn in pairs(traversedGrid) do
        for zIndex, tileLocation in pairs(gridColumn) do
            for position, traversedPosition in pairs(tileLocation) do
                if position < 13 or getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid).getTable('specialFeatures')[position - 12][3] ~= nil then
                    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
                    local rotation = tileGrid[xIndex][zIndex].rotation
                    local x, z = getFeatureLocation(position, tile, rotation)
                    local params = {}
                    if traversedPosition ~= nil and (traversedFeaturePositions[xIndex] == nil or traversedFeaturePositions[xIndex][zIndex] == nil or traversedFeaturePositions[xIndex][zIndex][position] == nil or traversedFeaturePositions[xIndex][zIndex][position] == 2) then
                        params.type = "BlockRectangle"
                    end
                    params.position = {(x * TILE_SPACING) + (xIndex * TILE_SPACING) - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (zIndex * TILE_SPACING) - MIDDLE_OFFSET.z}
                    params.scale = {0.25, 0.25, 0.25}
                    params.callback = "identifyFeature"
                    params.sound = false
                    local newObject = spawnObject(params)
                    table.insert(featureMarkers, newObject)
                end
            end
        end
    end
    Timer.create({identifier=os.clock(), function_name='deleteMarkers', function_owner=nil, parameters=nil, delay=8})
end

function debugShowFeatureMap()
    --this will break if the starting tile is moved
    local minX = MIDDLE_X_OFFSET
    local maxX = MIDDLE_X_OFFSET
    local minZ = MIDDLE_Z_OFFSET
    local maxZ = MIDDLE_Z_OFFSET
    local chatWindowMaxWidth
    if featureIndex < 100 then
        chatWindowMaxWidth = 11
    else
        chatWindowMaxWidth = 6
    end

    for xIndex, gridColumn in pairs(featureMap) do
        if xIndex < minX then minX = xIndex end
        if xIndex > maxX then maxX = xIndex end
        for zIndex, tileLocation in pairs(gridColumn) do
            if zIndex < minZ then minZ = zIndex end
            if zIndex > maxZ then maxZ = zIndex end
        end
    end

    local printColumnMinX = minX
    for printColumnMaxX = minX + chatWindowMaxWidth, maxX + chatWindowMaxWidth, chatWindowMaxWidth + 1 do
        if printColumnMaxX > maxX then printColumnMaxX = maxX end
        print("printing feature map x:" .. printColumnMinX .. "-" .. printColumnMaxX .. " z:" .. minZ .. "-" .. maxZ)
        for zIndex=maxZ, minZ, -1 do
            for i, positionRow in ipairs({{99, 5, 1, 6, 99}, {12, 99, 99, 99, 7}, {4, 99, 99, 99, 2}, {11, 99, 99, 99, 8}, {99, 10, 3, 9, 99}}) do
                local printLine = ""
                for xIndex=printColumnMinX, printColumnMaxX do
                    if featureMap[xIndex] ~= nil then
                        if featureMap[xIndex][zIndex] ~= nil then
                            local tilePositionRow = table.shallow_copy(positionRow)
                            if i >= 2 and i <= 4 then
                                for j=2, 4 do
                                    local closestPosition = findClosestPosition((j - 3) * 0.25, (3 - i) * 0.25, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation, false)
                                    if closestPosition > 12 then
                                        tilePositionRow[j] = closestPosition
                                    end
                                end
                            end
                            for _, position in ipairs(tilePositionRow) do
                                if position == 99 then
                                    if featureIndex < 100 then
                                        printLine = printLine .. '    '
                                    else
                                        printLine = printLine .. '      '
                                    end
                                else
                                    -- local nameOfFeature
                                    -- if featureMap[xIndex][zIndex][position] ~= nil then
                                    --     nameOfFeature = featureList[featureMap[xIndex][zIndex][position]].nameOfFeature
                                    -- else
                                    --     nameOfFeature = featureList[featureMap[xIndex][zIndex][(position * 2) + 3]].nameOfFeature
                                    -- end
                                    -- printLine = printLine .. nameOfFeature:sub(1,1)

                                    local featureNum = featureMap[xIndex][zIndex][position]
                                    if featureNum == nil and position < 5 and featureMap[xIndex][zIndex][(position * 2) + 3] ~= nil and featureMap[xIndex][zIndex][(position * 2) + 3] == featureMap[xIndex][zIndex][(position * 2) + 4] then
                                        featureNum = featureMap[xIndex][zIndex][(position * 2) + 3]
                                    end
                                    if featureNum == nil then
                                        --print("no feature found for x:" .. xIndex .. " z:" .. zIndex .. " position:" .. position .. " on tile:" .. tileGrid[xIndex][zIndex].tile_guid)
                                        if featureIndex < 100 then
                                            featureNum = 'XX'
                                        else
                                            featureNum = 'XXX'
                                        end
                                    else
                                        featureNum = tonumber(featureNum)
                                        if featureIndex < 100 then
                                            if featureNum < 10 then featureNum = '0' .. featureNum end
                                        else
                                            if featureNum < 10 then featureNum = '00' .. featureNum elseif featureNum < 100 then featureNum = '0' .. featureNum end
                                        end
                                    end
                                    printLine = printLine .. featureNum
                                end
                            end
                        else
                            if featureIndex < 100 then
                                printLine = printLine .. '                    '
                            else
                                printLine = printLine .. '                              '
                            end
                        end
                    end
                end
                --substituing 1's for L's to keep the character width consistent
                printLine = printLine:gsub("1", "L")
                print(printLine)
            end
        end
        printColumnMinX = printColumnMinX + chatWindowMaxWidth + 1
    end
    print("printing features...")
    for featureKey, feature in pairs(featureList) do
        local specialFeatures = ""
        for i, specialFeature in ipairs(feature.specialFeatures) do
            specialFeatures = specialFeatures .. specialFeature
            if i ~= #feature.specialFeatures then
                specialFeatures = specialFeatures .. ", "
            end
        end
        local numFeatureOpenings = feature.openings
        local featureOpenings = ""
        for key, _ in pairs(feature.openingCoords) do
            featureOpenings = featureOpenings .. key .. ", "
        end
        featureOpenings = featureOpenings:sub(1, -3) --get rid of the last comma and space
        if feature.nameOfFeature ~= 'Road' and feature.nameOfFeature ~= 'River' and not table.contains(PROXIMITY_FEATURES, feature.nameOfFeature) then numFeatureOpenings = numFeatureOpenings / 2 end
        featureKey = "" .. tonumber(featureKey)
        featureKey = featureKey:gsub("1", "L")
        print(featureKey .. " (" .. feature.nameOfFeature .. "): has " .. feature.numTiles .. " tiles and " .. numFeatureOpenings .. " openings: " .. featureOpenings .. " Special Features: " .. specialFeatures)
    end
    print("printing links...")
    for linkType, originFeatures in pairs(linkedFeatures) do
        local printLine = linkType .. ": "
        local first = true
        for origin, destinationFeatures in pairs(originFeatures) do
            origin = tonumber(origin)
            local nestedFirst = true
            if not first then printLine = printLine .. "; " end
            first = false
            printLine = printLine .. origin .. " - "
            for destination, _ in pairs(destinationFeatures) do
                destination = tonumber(destination)
                if not nestedFirst then printLine = printLine .. ", " end
                nestedFirst = false
                printLine = printLine .. destination
            end
        end
        printLine = printLine:gsub("1", "L")
        print(printLine)
    end
end

function debugShowTileOdds()
    print("printing connection odds...")
    for openingCoord, tileOdds in pairs(tileConnectionOdds) do --iterate through all valid tile lists and remove the added tile
        local printLine = openingCoord .. ": "
        for key, numChances in pairs(tileOdds) do
            printLine = printLine .. key .. ":" .. numChances .. ", "
        end
        printLine = printLine:sub(1, -3) --get rid of the last comma and space
        print(printLine)
    end
end

function deleteMarkers()
    for _, featureMarker in ipairs(featureMarkers) do
        featureMarker.destruct()
    end
    featureMarkers = {}
end

--findClosestPosition
-- params:
--  int: x
--  int: z
--  obj: tile to check
--  int: rotation (1-4)
--  bool: true if the coordinates should be rotated for realtime lookups (not used for featureMap) (special feature coordinates are rotated regardless since they are checked at runtime)
-- returns:
--  int: 1-4 for quadrants, 5-12 for octants, 13.. for additional features
function findClosestPosition(xPosition, zPosition, tile, rotation, rotateCoords)
    --debugMessage(3, "finding closest feature for object at x:" .. xPosition .. " z:" .. zPosition .. " for rotation:" .. rotation)
    rotatedXPosition, rotatedZPosition = rotateCoordinates(xPosition, zPosition, ((rotation + TILE_STANDARD_ROTATION - 1) % 4) + 1)

    local position = 1
    local closestPosition = 1
    local closestDistance = 999 --presumably every position should be closer than this

    local ignoredFeatures = tile.getTable('ignoredFeatures')
    for a = 0, 1 do -- a==0 is for quadrants, a==1 is for octants
        for side = 1, 4 do
            for j = 0, a do -- should do 1 loop for quadrants, 2 loops for octants
                if ignoredFeatures == nil or not table.contains(ignoredFeatures, position) then
                    local x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, 5 - side)
                    local distance
                    if rotateCoords then
                        distance = (rotatedXPosition - x) * (rotatedXPosition - x) + (rotatedZPosition - z) * (rotatedZPosition - z)
                    else
                        distance = (xPosition - x) * (xPosition - x) + (zPosition - z) * (zPosition - z)
                    end
                    --debugMessage(3, "compare to position " .. position .. ": x: " .. x .. " z: " .. z .. " distance: " .. distance)
                    if distance < closestDistance then
                        closestPosition = position
                        closestDistance = distance
                    end
                end
                position = position + 1
            end
        end
    end
    local specialFeatures = tile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        --check for specialFeatures with a position
        for _, feature in ipairs(specialFeatures) do
            if feature[3] ~= nil then
                local distance = (rotatedXPosition - feature[3][1]) * (rotatedXPosition - feature[3][1]) + (rotatedZPosition - feature[3][2]) * (rotatedZPosition - feature[3][2])
                --debugMessage(3, "compare to position " .. position .. ": x: " .. feature[3][1] .. " z: " .. feature[3][2] .. " distance: " .. distance)
                if distance < closestDistance then
                    closestPosition = position
                    closestDistance = distance
                end
            end
            position = position + 1
        end
    end
    return closestPosition
end

function getFeatureLocation(feature, tile, rotation)
    local x, z
    if feature < 13 then
        local a, side, j
        if feature < 5 then
            side = feature
            a = 0
            j = 0
        else
            side = math.floor((feature - 3) / 2)
            a = 1
            j = (feature - 3) % 2
        end
        x, z = rotateCoordinates((-0.25 + (j * 0.5)) * a, 0.5 - FIGURE_DISTANCE_FROM_EDGE, ((8 + TILE_STANDARD_ROTATION - side - rotation) % 4) + 1)
    else
        local specialFeatures = tile.getTable('specialFeatures')
        x, z = rotateCoordinates(specialFeatures[feature - 12][3][1], specialFeatures[feature - 12][3][2], (TILE_STANDARD_ROTATION - 1 - rotation) % 4 + 1)
    end
    return x, z
end

--getFeatureName
--
-- Gets the name of the feature on the tile at the specified position
--
-- params:
--  obj: tile
--  position: 1-12, 13-...
-- returns:
--  string: name
function getFeatureName(tile, position)
    local nameOfFeature
    if position < 5 then
        nameOfFeature = tile.getTable('sides')[position]
    elseif position < 13 then
        local splitSides = string.split(tile.getTable('sides')[math.floor((position - 3) / 2)], "/")
        if #splitSides == 1 then
            nameOfFeature = splitSides[1]
            if nameOfFeature == 'Road' or nameOfFeature == 'River' then nameOfFeature = 'Field' end
        else
            if position % 2 == 1 then
                nameOfFeature = splitSides[1]
            else
                nameOfFeature = splitSides[2]
            end
        end
    else
        local specialFeatures = tile.getTable('specialFeatures')
        if specialFeatures[position - 12] ~= nil then
            nameOfFeature = specialFeatures[position - 12][1]
        else
            nameOfFeature = "ERROR: Feature at position " .. position .. " doesn't exist"
        end
    end
    return nameOfFeature
end

--getFeatureComponents
--
-- Traverses the tiles recursively, storing all associated tiles, features, and followers into their respective global variables
--
-- params:
--  int: xIndex
--  int: zIndex
--  int: position number to check
--  int: number of traversal levels do check
--  bool: false if multiple getFeatureComponents calls will be made. This prevents resetting the traversal and also does not check for followers each time. The goal is to save on performance.
-- returns:
--  bool: true if the feature is complete, false if not complete
function getFeatureComponents(xIndex, zIndex, position, traversalLevels, reset, reverseCityTraversal)
    if reset then --for when we want to make multiple feature traversals without revisiting already visited positions
        resetTraversal()
    end

    local nameOfFeature = getFeatureName(getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), position)
    local finished = 0
    if position < 5 then
        --if nameOfFeature == 'River' then return 0
        if nameOfFeature == 'Road' or nameOfFeature == 'River' then
            finished = getTileComponents(xIndex, zIndex, position, traversalLevels, 1, reverseCityTraversal)
        else
            --in theory this shouldn't happen unless a player allows a figure to stay somewhere they're not supposed to
            --if it happens, just pick an arbitrary octant
            finished = getTileComponents(xIndex, zIndex, (position * 2) + 3, traversalLevels, 1, reverseCityTraversal)
        end
    else
        finished = getTileComponents(xIndex, zIndex, position, traversalLevels, 1, reverseCityTraversal)
    end

    if reset then -- don't run for each call of getFeatureComponents. Instead, getFigureComponents should be called from the calling method.
        getFigureComponents()
    end

    -- if finished == 0 then
    --     debugMessage(2, "Feature is complete")
    -- else
    --     debugMessage(2, "Feature is not complete: " .. finished .. " openings.")
    -- end

    return finished
end

--getFigureComponents
--
-- Traverses the all objects in the play area, storing followers and tokens that were in the traversed positions
function getFigureComponents()
    local objs = getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()
    for _, obj in ipairs(objs) do
        if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) or table.contains(SPECIAL_FIGURE_TYPES, obj.getVar('figureName')) or table.contains(SHEEP_TOKEN_TYPES, obj.getVar('tokenName')) or obj.getVar('figureName') == GOLD_BAR_NAME then
            local xIndex = math.floor((obj.getPosition().x + MIDDLE_OFFSET.x + TILE_SPACING / 2) / TILE_SPACING)
            local zIndex = math.floor((obj.getPosition().z + MIDDLE_OFFSET.z + TILE_SPACING / 2) / TILE_SPACING)
            --debugMessage(2, "Object on tile: x: " .. xIndex .. " z: " .. zIndex)
            if obj.getVar('figureName') == GOLD_BAR_NAME and table.contains(traversedTileCoords, {x=xIndex, z=zIndex}) then
                --debugMessage(2, obj.getVar('figureName') .. " added to traversedGoldBars table")
                table.insert(traversedGoldBars, obj)
            elseif traversedFeaturePositions[xIndex] ~= nil and traversedFeaturePositions[xIndex][zIndex] ~= nil then
                local xPosition = (obj.getPosition().x + MIDDLE_OFFSET.x) / TILE_SPACING
                local zPosition = (obj.getPosition().z + MIDDLE_OFFSET.z) / TILE_SPACING
                xPosition = xPosition - xIndex
                zPosition = zPosition - zIndex
                local closestPosition = findClosestPosition(xPosition, zPosition, getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid), tileGrid[xIndex][zIndex].rotation, true)
                --debugMessage(2, "Object closest feature: index: x: " .. xIndex .. " z: " .. zIndex .. " feature: " .. closestPosition)
                if traversedFeaturePositions[xIndex][zIndex][closestPosition] == 1 then
                    if table.contains(FOLLOWER_TYPES, obj.getVar('figureName')) then
                        --debugMessage(2, obj.getVar('owner') .. " " .. obj.getVar('tokenName') .. " added to traversedFollowers table")
                        table.insert(traversedFollowers, obj)
                    elseif table.contains(SPECIAL_FIGURE_TYPES, obj.getVar('figureName')) then
                        --debugMessage(2, obj.getVar('owner') .. " " .. obj.getVar('tokenName') .. " added to traversedSpecialFigures table")
                        table.insert(traversedSpecialFigures, obj)
                    elseif table.contains(SHEEP_TOKEN_TYPES, obj.getVar('tokenName')) then
                        --debugMessage(2, obj.getVar('tokenName') .. " added to traversedSheepTokens table")
                        table.insert(traversedSheepTokens, obj)
                    end
                end
            end
        end
    end
    --debugMessage(1, "Traversed " .. #traversedTileCoords .. " tiles, " .. #traversedFollowers .. " followers, " .. #traversedSpecialFigures .. " special figures, " .. #traversedSpecialFeatures .. " special features, " .. #traversedSheepTokens .. " sheep tokens, and " .. #traversedGoldBars .. " gold bars")
end

--getTileComponents
--
-- Traverses the tiles recursively, storing all associated tiles, features, and followers into their respective global variables
--
-- params:
--  int: xIndex
--  int: zIndex
--  int: position number to check
--  int: how many traversal levels to check
--       2 levels would be used for checking secondary features such as completed cities and road intersections
--  int: current traversal level
--  bool: reverseCityTraversal - traverses from cities to fields, when the feature is a city. Currently only used for recalculating field connections from the city's point of view
-- returns:
--  bool: true if the feature is complete, false if not complete
function getTileComponents(xIndex, zIndex, position, traversalLevels, traversalNum, reverseCityTraversal)
    if traversalNum > traversalLevels then return 0 end
    --debugMessage(2, "checking tile at x: " .. xIndex .. " z: " .. zIndex .. " position: " .. position .. " trans num: " .. traversalNum)
    local tile = getObjectFromGUID(tileGrid[xIndex][zIndex].tile_guid)
    local rotation = tileGrid[xIndex][zIndex].rotation
    if traversedGrid[xIndex] == nil then
        traversedGrid[xIndex] = {}
    end
    if traversedGrid[xIndex][zIndex] == nil then
        traversedGrid[xIndex][zIndex] = {}
    end
    if traversedFeaturePositions[xIndex] == nil then
        traversedFeaturePositions[xIndex] = {}
    end
    if traversedFeaturePositions[xIndex][zIndex] == nil then
        traversedFeaturePositions[xIndex][zIndex] = {}
    end
    if traversalNum == 1 and not table.contains(traversedTileCoords, {x=xIndex, z=zIndex}) then
        table.insert(traversedTileCoords, {x=xIndex, z=zIndex})
        --debugMessage(2, "adding tile to traversedTileCoords: x: " .. xIndex .. " z: " .. zIndex)
    end
    if traversedGrid[xIndex][zIndex][position] ~= nil and traversedGrid[xIndex][zIndex][position] <= traversalNum then return 0 end
    local finished = 0
    local specialFeatures = tile.getTable('specialFeatures')
    if position < 5 then
        local links = tile.getTable('linkedQuadrants')
        while traversedGrid[xIndex][zIndex][position] == nil or traversedGrid[xIndex][zIndex][position] > traversalNum do
            if links ~= nil then
                for _, link in ipairs(links) do
                    if table.contains(link, position) then
                        for _, quadrant in ipairs(link) do
                            if traversedGrid[xIndex][zIndex][quadrant] == nil or traversedGrid[xIndex][zIndex][quadrant] > traversalNum then
                                traversedGrid[xIndex][zIndex][quadrant] = traversalNum
                                if traversalNum == 1 then
                                    traversedFeaturePositions[xIndex][zIndex][quadrant] = 1
                                end
                                local direction = (3 + quadrant + rotation) % 4 + 1
                                local newX = xIndex + SIDE_DELTA[direction].x
                                local newZ = zIndex + SIDE_DELTA[direction].z
                                --debugMessage(2, "checking x:" .. xIndex .. " z:" .. zIndex .. " quadrant:" .. quadrant .. " direction:" .. direction .. " newX:" .. newX .. " newZ:" .. newZ .. " trans num: " .. traversalNum)
                                if tileGridOccupied(newX, newZ) then
                                    local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                                    local newTileRotation = tileGrid[newX][newZ].rotation
                                    local newTilePosition = (3 + quadrant + rotation - newTileRotation + TILE_180_ROTATION) % 4 + 1
                                    --debugMessage(2, "newTilePosition: " .. newTilePosition)
                                    if getFeatureName(newTile, newTilePosition) ~= 'Abbey' and getFeatureName(tile, position) ~= 'Abbey' then
                                        finished = finished + getTileComponents(newX, newZ, newTilePosition, traversalLevels, traversalNum, reverseCityTraversal)
                                    elseif traversalNum == 1 then
                                        if getFeatureName(newTile, newTilePosition) == 'Abbey' then
                                            getTileComponents(newX, newZ, (newTilePosition * 2) + 3, traversalLevels, traversalNum + 1, reverseCityTraversal)
                                        elseif getFeatureName(newTile, newTilePosition) ~= 'Field' then
                                            getTileComponents(newX, newZ, newTilePosition, traversalLevels, traversalNum + 1, reverseCityTraversal)
                                        end
                                    end
                                else
                                    --debugMessage(2, "Next tile is empty. Feature is not finished")
                                    finished = finished + 1
                                    if traversalNum == 1 then
                                        traversedOpeningCoords[newX .. "-" .. newZ] = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
             --workaround for when the target position has no links and is the first tile of the chain
             --in that case, the target position would never be checked, and, therefore, none of its neighbors
             --so we force it to be checked by running again with a links table containing the element
            if traversedGrid[xIndex][zIndex][position] == nil or traversedGrid[xIndex][zIndex][position] > traversalNum then
                links = {{position}}
            end
        end
    elseif position < 13 then
        local links = tile.getTable('linkedOctants')
        while traversedGrid[xIndex][zIndex][position] == nil or traversedGrid[xIndex][zIndex][position] > traversalNum do
            if links ~= nil then
                for _, link in ipairs(links) do
                    if table.contains(link, position) then
                        for _, octant in ipairs(link) do
                            if traversedGrid[xIndex][zIndex][octant] == nil or traversedGrid[xIndex][zIndex][octant] > traversalNum then
                                traversedGrid[xIndex][zIndex][octant] = traversalNum
                                if traversalNum == 1 then
                                    traversedFeaturePositions[xIndex][zIndex][octant] = 1
                                end
                                local direction = (3 + octant + (rotation * 2)) % 8 + 5
                                local newX = xIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].x
                                local newZ = zIndex + SIDE_DELTA[math.floor((direction - 3) / 2)].z
                                --debugMessage(2, "checking x:" .. xIndex .. " z:" .. zIndex .. " octant:" .. octant .. " direction:" .. direction .. " newX:" .. newX .. " newZ:" .. newZ .. " trans num: " .. traversalNum)
                                if tileGridOccupied(newX, newZ) then
                                    local newTile = getObjectFromGUID(tileGrid[newX][newZ].tile_guid)
                                    local newTileRotation = tileGrid[newX][newZ].rotation
                                    local newTilePosition = (((direction % 2) * 2) + TILE_180_ROTATION + direction - (newTileRotation * 2) - 4) % 8 + 5
                                    --debugMessage(2, "newTileRotation: " .. newTileRotation .. " newTilePosition: " .. newTilePosition)
                                    if getFeatureName(newTile, newTilePosition) ~= 'Abbey' and getFeatureName(tile, position) ~= 'Abbey' then
                                        finished = finished + getTileComponents(newX, newZ, newTilePosition, traversalLevels, traversalNum, reverseCityTraversal)
                                    elseif traversalNum == 1 then -- all of this is for Abbeys and Wagons
                                        if getFeatureName(newTile, (newTilePosition - 3) / 2) == 'Road' then
                                            getTileComponents(newX, newZ, math.floor((newTilePosition - 3) / 2), traversalLevels, traversalNum + 1, reverseCityTraversal)
                                        elseif getFeatureName(newTile, newTilePosition) ~= 'Field' then
                                            getTileComponents(newX, newZ, newTilePosition, traversalLevels, traversalNum + 1, reverseCityTraversal)
                                        end
                                    end
                                else
                                    --debugMessage(2, "Next tile is empty. Feature is not finished")
                                    finished = finished + 1
                                    if traversalNum == 1 then
                                        traversedOpeningCoords[newX .. "-" .. newZ] = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
             --workaround for when the target position has no links and is the first tile of the chain
             --in that case, the target position would never be checked, and, therefore, none of its neighbors
             --so we force it to be checked by running again with a links table containing the element
            if traversedGrid[xIndex][zIndex][position] == nil or traversedGrid[xIndex][zIndex][position] > traversalNum then
                links = {{position}}
            end
        end
    else
        if traversedGrid[xIndex][zIndex][position] == nil or traversedGrid[xIndex][zIndex][position] > traversalNum then
            traversedGrid[xIndex][zIndex][position] = traversalNum
            if traversalNum == 1 then
                traversedFeaturePositions[xIndex][zIndex][position] = 1
            end
            local feature = specialFeatures[position - 12]
            if table.contains(PROXIMITY_FEATURES, feature[1]) then
                if traversalNum == 1 then
                    table.insert(traversedSpecialFeatures, feature[1])
                    --debugMessage(2, feature[1] .. " added to traversedSpecialFeatures")
                end
                local tileNum = 1
                for i = -1, 1 do
                    for j = -1, 1 do
                        if tileGridOccupied(xIndex + i, zIndex + j) then
                            if not (i == 0 and j == 0) then --we already added the tile
                                tileNum = tileNum + 1
                                if traversalNum == 1 then
                                    table.insert(traversedTileCoords, {x=xIndex + i, z=zIndex + j})
                                    local nestedSpecialFeatures = getObjectFromGUID(tileGrid[xIndex + i][zIndex + j].tile_guid).getTable('specialFeatures')
                                    if nestedSpecialFeatures ~= nil then
                                        for _, specialFeature in ipairs(nestedSpecialFeatures) do
                                            if specialFeature[1] == "Vineyard" then
                                                table.insert(traversedSpecialFeatures, specialFeature[1])
                                                --debugMessage(2, specialFeature[1] .. " added to traversedSpecialFeatures")
                                            end
                                        end
                                    end
                                end
                            end
                            --this is purely for graphical effect of showing what tiles were used in scoring the cloister
                            if traversalNum == 1 and not (i == 0 and j == 0 and feature[1] == 'Abbey') then
                                if traversedFeaturePositions[xIndex + i] == nil then
                                    traversedFeaturePositions[xIndex + i] = {}
                                end
                                if traversedFeaturePositions[xIndex + i][zIndex + j] == nil then
                                    traversedFeaturePositions[xIndex + i][zIndex + j] = {}
                                end
                                for k = 1, 12 do
                                    if traversedFeaturePositions[xIndex + i][zIndex + j][k] == nil then
                                        traversedFeaturePositions[xIndex + i][zIndex + j][k] = 2
                                    end
                                end
                            end
                        else
                            traversedOpeningCoords[xIndex + i .. "-" .. zIndex + j] = true
                        end
                    end
                end
                if tileNum < 9 then finished = finished + 9 - tileNum end
            end
            if feature[1] == 'City' or feature[1] == 'Road' or feature[1] == 'Field' or feature[1] == 'Abbey' then
                if feature[2] ~= nil then
                    for _, location in ipairs(feature[2]) do
                        if traversedGrid[xIndex][zIndex][location] == nil or traversedGrid[xIndex][zIndex][location] > traversalNum then
                            if traversalNum == 1 then
                                traversedFeaturePositions[xIndex][zIndex][location] = 1
                            end
                            finished = finished + getTileComponents(xIndex, zIndex, location, traversalLevels, traversalNum, reverseCityTraversal)
                        end
                    end
                end
            end
        end
    end
    if specialFeatures ~= nil then
        for i, feature in ipairs(specialFeatures) do
            if feature[2] ~= nil then
                if table.contains(feature[2], position) then
                    if (traversedGrid[xIndex][zIndex][i+12] == nil or traversedGrid[xIndex][zIndex][i+12] > traversalNum) and not (feature[1] == 'City-Field' and ((not reverseCityTraversal and getFeatureName(tile, position) ~= 'Field') or (reverseCityTraversal and getFeatureName(tile, position) ~= 'City'))) then
                        if feature[1] == 'Abbey' then
                            finished = finished + getTileComponents(xIndex, zIndex, i+12, traversalLevels, traversalNum, reverseCityTraversal)
                        else
                            traversedGrid[xIndex][zIndex][i+12] = traversalNum
                            if traversalNum == 1 then
                                traversedFeaturePositions[xIndex][zIndex][i+12] = 1
                                if feature[1] == 'City-Field' then
                                    if getFeatureName(tile, position) == 'Field' or (reverseCityTraversal and (getFeatureName(tile, position) == 'City' or getFeatureName(tile, octant) == 'Carcassonne')) then
                                        for _, octant in ipairs(feature[2]) do
                                            if getFeatureName(tile, octant) == 'City' or getFeatureName(tile, octant) == 'Carcassonne' or (reverseCityTraversal and getFeatureName(tile, octant) == 'Field') then
                                                if traversedGrid[xIndex][zIndex][octant] == nil or traversedGrid[xIndex][zIndex][octant] > traversalNum + 1 then
                                                    if getTileComponents(xIndex, zIndex, octant, traversalLevels, traversalNum + 1, reverseCityTraversal) == 0 or reverseCityTraversal then
                                                        if not reverseCityTraversal then
                                                            table.insert(traversedSpecialFeatures, "Completed City")
                                                            --debugMessage(2, "Completed City added to traversedSpecialFeatures")
                                                        end
                                                        traversedFeaturePositions[xIndex][zIndex][octant] = 2
                                                    end
                                                end
                                            end
                                        end
                                    end
                                elseif feature[1] == 'Road Intersection' then
                                    for _, location in ipairs(feature[2]) do
                                        if getTileComponents(xIndex, zIndex, location, traversalLevels, traversalNum + 1, reverseCityTraversal) > 0 then
                                            --we don't really care if the feature is finished or not. In fact, we really don't need to traverse intersections at all, except for the removeTile method
                                        end
                                    end
                                elseif feature[1] == 'Pennant' or feature[1] == 'Inn' or feature[1] == 'Cathedral' or
                                    table.contains(TRADE_GOOD_TYPES, feature[1]) or
                                    feature[1] == 'Pig-herd' or feature[1] == 'Sheep' then
                                    table.insert(traversedSpecialFeatures, feature[1])
                                    --debugMessage(2, feature[1] .. " added to traversedSpecialFeatures")
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    for i=1, 4 do
        --this one is necessary for followers placed on center positions for quadrant features to be processed correctly
        if getFeatureName(tile, i) ~= 'Road' and getFeatureName(tile, i) ~= 'River' then
            if traversedFeaturePositions[xIndex][zIndex][i] ~= nil then
                if traversedFeaturePositions[xIndex][zIndex][i * 2 + 3] == nil or traversedFeaturePositions[xIndex][zIndex][i * 2 + 3] > traversedFeaturePositions[xIndex][zIndex][i] then
                    traversedFeaturePositions[xIndex][zIndex][i * 2 + 3] = traversedFeaturePositions[xIndex][zIndex][i]
                end
                if traversedFeaturePositions[xIndex][zIndex][i * 2 + 4] == nil or traversedFeaturePositions[xIndex][zIndex][i * 2 + 4] > traversedFeaturePositions[xIndex][zIndex][i] then
                    traversedFeaturePositions[xIndex][zIndex][i * 2 + 4] = traversedFeaturePositions[xIndex][zIndex][i]
                end
            end
            --this is just used for graphical effect
            if traversedFeaturePositions[xIndex][zIndex][i * 2 + 3] ~= nil and traversedFeaturePositions[xIndex][zIndex][i * 2 + 4] ~= nil and traversedFeaturePositions[xIndex][zIndex][i * 2 + 3] == traversedFeaturePositions[xIndex][zIndex][i * 2 + 4] then
                traversedFeaturePositions[xIndex][zIndex][i] = traversedFeaturePositions[xIndex][zIndex][i * 2 + 3]
            end
            if addToTempPositions and traversedGrid[xIndex][zIndex][i * 2 + 3] ~= nil and traversedGrid[xIndex][zIndex][i * 2 + 4] ~= nil and traversedGrid[xIndex][zIndex][i * 2 + 3] == traversedGrid[xIndex][zIndex][i * 2 + 4] then
                traversedGrid[xIndex][zIndex][i] = traversedGrid[xIndex][zIndex][i * 2 + 3]
            end
        end
    end
    return finished
end

--resetTraversal
--Empties the traversal tables, so that they are ready for the next traversal
function resetTraversal()
    --debugMessage(2, "Clearing traversal tables")
    traversedGrid = {}
    traversedFeaturePositions = {}
    traversedTileCoords = {}
    traversedOpeningCoords = {}
    traversedSpecialFeatures = {}
    traversedFollowers = {}
    traversedSpecialFigures = {}
    traversedSheepTokens = {}
    traversedGoldBars = {}
    return
end

#include !\TTSCarcassonne\scripts\helper_functions

#include !\TTSCarcassonne\scripts\ai
